/*
 * This file is part of the Panini project at Iowa State University.
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * 
 * For more details and the latest version of this code please see
 * http://paninij.org
 * 
 * Contributor(s): Yuheng Long
 */

package org.paninij.analysis;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.TreeSet;

import javax.lang.model.element.ElementKind;
import javax.lang.model.type.TypeKind;

import com.sun.tools.javac.code.Flags;
import com.sun.tools.javac.code.Symbol;
import com.sun.tools.javac.code.Symbol.*;
import com.sun.tools.javac.code.Type;
import com.sun.tools.javac.code.Type.*;
import com.sun.tools.javac.code.Symbol.ClassSymbol;
import com.sun.tools.javac.code.Symbol.MethodSymbol;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.JCTree.*;
import com.sun.tools.javac.util.List;

public class AnalysisUtil {
	public static HashSet<Symbol> allCapsuleStates(JCTree tree) {
		JCCapsuleDecl cap_decl = (JCCapsuleDecl)tree;
		HashSet<Symbol> result = new HashSet<Symbol>();

		for (JCTree def : cap_decl.defs) {
			if (def instanceof JCVariableDecl) {
				JCVariableDecl jcvd = (JCVariableDecl)def;
				Type t = jcvd.type;

				if (((jcvd.mods.flags & Flags.STATIC) == 0 ||
						(jcvd.mods.flags & Flags.FINAL) == 0) &&
						!capType(t)) {
					result.add(jcvd.sym);
				}
			}
		}
		return result;
	}

	private static boolean capType(Type type) {
		if (type instanceof ClassType) {
			ClassType ct = (ClassType)type;
			TypeSymbol ts = ct.tsym;
			if (ts instanceof ClassSymbol) {
				ClassSymbol cs = (ClassSymbol)ts;
				if (cs.capsule_info != null) {
					return true;
				}
			}
		} else if (type instanceof ArrayType) {
			Type elemtype = ((ArrayType) type).elemtype;
			return capType(elemtype);
		}

		return false;
	}
	// whether a capusle has any reference to other capsule.
	public static boolean leafCapsule(JCTree tree) {
		JCCapsuleDecl cap_decl = (JCCapsuleDecl)tree;

		for (JCTree def : cap_decl.defs) {
			if (def instanceof JCVariableDecl) {
				JCVariableDecl jcvd = (JCVariableDecl)def;
				Type t = jcvd.type;

				if (capType(t)) {
					return false;
				}
			} else if (def instanceof JCDesignBlock) {
				return false;
			}
		}
		return true;
	}

	public static boolean statelessCapsule(JCTree tree) {
		JCCapsuleDecl cap_decl = (JCCapsuleDecl)tree;

		for (JCTree def : cap_decl.defs) {
			if (def instanceof JCVariableDecl) {
				JCVariableDecl jcvd = (JCVariableDecl)def;
				if (jcvd.mods.flags == 0) {
					return false;
				}
			}
		}
		return true;
	}

	public static boolean primitiveStateCapsule(JCTree tree) {
		JCCapsuleDecl cap_decl = (JCCapsuleDecl)tree;

		for (JCTree def : cap_decl.defs) {
			if (def instanceof JCVariableDecl) {
				JCVariableDecl jcvd = (JCVariableDecl)def;

				if (!jcvd.type.isPrimitive()) {
					return false;
				}
			}
		}
		return true;
	}

	public static boolean shouldAnalyze(JCCapsuleDecl capsule,
			JCMethodDecl meth) {
		if ((meth.mods.flags & Flags.PRIVATE) != 0 ||
				// an active Capsule.
				activeRun(capsule.sym, meth.sym)) {
			return true;
		}
		return false;
	}

	// for the leak detection, test whether a method should be analyzed
	public static boolean shouldLeakAnalyze(JCCapsuleDecl capsule,
			JCMethodDecl meth) {
		if ((meth.mods.flags & Flags.PRIVATE) != 0 ||
				meth.sym.toString().contains("$Original") ||
				// an active Capsule.
				activeRun(capsule.sym, meth.sym)) {
			return true;
		}
		return false;
	}

	public static boolean activeRun(ClassSymbol cs, MethodSymbol meth) {
		return (cs.capsule_info.definedRun &&
				meth.toString().compareTo("run()") == 0);
	}

	public static boolean activeThread(ClassSymbol cs, String tree_name) {
		return cs.capsule_info.definedRun && tree_name.indexOf("$") == -1;
	}

	/* Check whether a method is the input method is declared in the source
	 * code or generated by the compiler. */
	public static boolean originalMethod(ClassSymbol cs, JCMethodDecl meth,
			String tree_name) {
		String capsule_name = cs.toString();
		return (capsule_name.substring(capsule_name.indexOf("$")
				+ 1).compareTo("thread") == 0) &&
				(tree_name.indexOf("$Original") != -1 ||
						(meth.mods.flags & Flags.PRIVATE) != 0);
	}

	// Test whether the method is from the source input, not a rewritten one.
	public static boolean originalMethod(MethodSymbol meth) {
		return meth.toString().indexOf("$Original") != -1;
	}

	public static JCExpression getEssentialExpr(JCExpression expr) {
		while (expr instanceof JCTypeCast || expr instanceof JCParens) {
			if (expr instanceof JCTypeCast) {
				expr = ((JCTypeCast)expr).expr;
			} else if (expr instanceof JCParens) {
				expr = ((JCParens)expr).expr;
			}
		}
		return expr;
	}

	public static JCTree getEssentialTree(JCTree expr) {
		while (expr instanceof JCTypeCast || expr instanceof JCParens ||
				expr instanceof JCExpressionStatement) {
			if (expr instanceof JCTypeCast) {
				expr = ((JCTypeCast)expr).expr;
			} else if (expr instanceof JCParens) {
				expr = ((JCParens)expr).expr;
			} else if (expr instanceof JCExpressionStatement) {
				expr = ((JCExpressionStatement)expr).expr;
			}
		}
		return expr;
	}

	public static String rmDollar(String input) {
		int index = input.indexOf("$");

		if (index != -1) {
			return input.substring(0, index);
		}
		return input;
	}

	public static String rmDollarOriginal(String input) {
		int index = input.indexOf("$");

		if (index != -1) {
			return input.substring(0, index) +
					input.substring(index + 9, input.length());
		}
		return input;
	}

	public static boolean isVarThis(JCTree that) {
		if (that instanceof JCIdent) {
			JCIdent tree = (JCIdent)that;
			Symbol sym = tree.sym;
			if (sym != null) {
				ElementKind symKind = sym.getKind();
				if (symKind == ElementKind.FIELD) {
					if (sym.name.toString().compareTo("this") == 0) {
						return true;
					}
				}
			}
		}
		return false;
	}

	// Check whether a symbol is field that is declared in inside a Capsule.
	public static boolean isInnerField(List<JCTree> defs, Symbol s) {
		for (JCTree def : defs) {
			if (def instanceof JCVariableDecl) {
				JCVariableDecl field = (JCVariableDecl)def;
				if (field.sym == s /* &&
						((field.mods.flags & Flags.PRIVATE) != 0) */
						&& (field.mods.flags == 0)) {
					return s.getKind() == ElementKind.FIELD;
				}
			}
		}
		return false;
	}

	public static void addCallEdge(Symbol caller, Symbol callee,
			HashMap<Symbol, HashSet<Symbol>> reversed) {
		HashSet<Symbol> callers = reversed.get(callee);
		if (callers == null) {
			callers = new HashSet<Symbol>();
			reversed.put(callee, callers);
		}
		callers.add(caller);
	}

	// The following two methods are for constructing the order for the for the
	// analysis for methods.
	public static TreeSet<JCTree> constructWorklist(ArrayList<JCTree> order) {
		return new TreeSet<JCTree>(new InnerComparator(order));
	}

	private static class InnerComparator implements Comparator<JCTree> {
		public final ArrayList<JCTree> order;

		public InnerComparator(ArrayList<JCTree> order) {
			this.order = order;
		}

		public int compare(JCTree o1, JCTree o2) {
			int i1 = order.indexOf(o1);
			int i2 = order.indexOf(o2);
			return i1 - i2;
		}
	}

	public static boolean immute_type(Type type) {
		String type_string = type.toString();
		return type_string.compareTo("java.lang.String") == 0 ||
			type_string.compareTo("java.math.BigDecimal") == 0;
	}

	// Get the successors of the input for loop.
	public static final HashSet<JCTree> forloopsuccessors(JCForLoop forloop) {
		HashSet<JCTree> result = new HashSet<JCTree>();
		for (JCTree end : forloop.endNodes) {
			for (JCTree next : end.successors) {
				if (!forloop.body.startNodes.contains(next)) {
					result.add(next);
				}
			}
		}
		return result;
	}

	public static final void add_loop_index(JCForLoop jcf,
			HashSet<Symbol> vars) {
		for (JCStatement stmt : jcf.init) {
        	if (stmt instanceof JCVariableDecl) {
        		vars.add(((JCVariableDecl)stmt).sym);
        	} else if (stmt instanceof JCExpressionStatement) {
        		JCExpressionStatement jces = (JCExpressionStatement) stmt;
        		JCExpression expr =
        			AnalysisUtil.getEssentialExpr(jces.expr);
        		if (expr instanceof JCAssign) {
        			JCExpression lhs =
        				AnalysisUtil.getEssentialExpr(((JCAssign)expr).lhs);
        			if (lhs instanceof JCIdent) {
        				vars.add(((JCIdent)lhs).sym);
        			}
        		}
        	}
        }
	}

	public static final boolean int_type(Type type) {
		return type.getKind() == TypeKind.INT;
	}

	private static boolean isCloneMethod(JCMethodInvocation jcmi) {
		JCExpression meth = getEssentialExpr(jcmi.meth);
		if (jcmi.args.isEmpty() && meth instanceof JCFieldAccess) {
			JCFieldAccess jcfa = (JCFieldAccess)meth;
			if (jcfa.sym.toString().compareTo("clone()") == 0) {
				return jcfa.selected.type instanceof ArrayType;
			}
		}
		return false;
	}
	public static boolean isNewExpression(JCExpression exp) {
		exp = getEssentialExpr(exp);
		if ((exp instanceof JCNewClass) || (exp instanceof JCNewArray)) {
			return true;
		}

		// array clone returns an new object;
		if (exp instanceof JCTypeCast) {
			JCTypeCast jctc = (JCTypeCast)exp;
			JCTree clazz = jctc.clazz;
			JCExpression expr = getEssentialExpr(jctc.expr);

			if (clazz instanceof JCArrayTypeTree &&
					expr instanceof JCMethodInvocation) {
				return isCloneMethod((JCMethodInvocation)expr);
			}
		} else if (exp instanceof JCMethodInvocation) {
			return isCloneMethod((JCMethodInvocation)exp);
		}

		return false;
	}

	// decide whether a expression is the constant 0
	public static final boolean isZero(JCExpression tree) {
		tree = getEssentialExpr(tree);
		if (tree instanceof JCLiteral) {
			JCLiteral jci = (JCLiteral)tree;
			Object obj = jci.value;
			if (obj instanceof Integer) {
				int value = (Integer)obj;
				return value == 0;
			}
		}
		return false;
	}
}
