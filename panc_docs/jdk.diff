Only in javac/api: BasicJavacTask.java
diff -u -r javac/api/ClientCodeWrapper.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/api/ClientCodeWrapper.java
--- javac/api/ClientCodeWrapper.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/api/ClientCodeWrapper.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,36 +31,33 @@
 import java.io.OutputStream;
 import java.io.Reader;
 import java.io.Writer;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
 import java.net.URI;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.NestingKind;
 import javax.tools.Diagnostic;
-import javax.tools.DiagnosticListener;
 import javax.tools.FileObject;
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileManager.Location;
 import javax.tools.JavaFileObject;
-import javax.tools.JavaFileObject.Kind;
 
 import com.sun.source.util.TaskEvent;
 import com.sun.source.util.TaskListener;
 import com.sun.tools.javac.util.ClientCodeException;
 import com.sun.tools.javac.util.Context;
-import com.sun.tools.javac.util.JCDiagnostic;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import javax.lang.model.element.Modifier;
+import javax.tools.DiagnosticListener;
+import javax.tools.JavaFileObject.Kind;
 
 /**
  *  Wrap objects to enable unchecked exceptions to be caught and handled.
@@ -149,7 +146,7 @@
             return fo;
     }
 
-    <T /*super JavaFileOject*/> DiagnosticListener<T> wrap(DiagnosticListener<T> dl) {
+    <T> DiagnosticListener<T> wrap(DiagnosticListener<T> dl) {
         if (isTrusted(dl))
             return dl;
         return new WrappedDiagnosticListener<T>(dl);
@@ -161,30 +158,6 @@
         return new WrappedTaskListener(tl);
     }
 
-    TaskListener unwrap(TaskListener l) {
-        if (l instanceof WrappedTaskListener)
-            return ((WrappedTaskListener) l).clientTaskListener;
-        else
-            return l;
-    }
-
-    Collection<TaskListener> unwrap(Collection<? extends TaskListener> listeners) {
-        Collection<TaskListener> c = new ArrayList<TaskListener>(listeners.size());
-        for (TaskListener l: listeners)
-            c.add(unwrap(l));
-        return c;
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T> Diagnostic<T> unwrap(final Diagnostic<T> diagnostic) {
-        if (diagnostic instanceof JCDiagnostic) {
-            JCDiagnostic d = (JCDiagnostic) diagnostic;
-            return (Diagnostic<T>) new DiagnosticSourceUnwrapper(d);
-        } else {
-            return diagnostic;
-        }
-    }
-
     protected boolean isTrusted(Object o) {
         Class<?> c = o.getClass();
         Boolean trusted = trustedClasses.get(c);
@@ -196,10 +169,6 @@
         return trusted;
     }
 
-    private String wrappedToString(Class<?> wrapperClass, Object wrapped) {
-        return wrapperClass.getSimpleName() + "[" + wrapped + "]";
-    }
-
     // <editor-fold defaultstate="collapsed" desc="Wrapper classes">
 
     // FIXME: all these classes should be converted to use multi-catch when
@@ -380,11 +349,6 @@
                 throw new ClientCodeException(e);
             }
         }
-
-        @Override
-        public String toString() {
-            return wrappedToString(getClass(), clientJavaFileManager);
-        }
     }
 
     protected class WrappedFileObject implements FileObject {
@@ -510,11 +474,6 @@
                 throw new ClientCodeException(e);
             }
         }
-
-        @Override
-        public String toString() {
-            return wrappedToString(getClass(), clientFileObject);
-        }
     }
 
     protected class WrappedJavaFileObject extends WrappedFileObject implements JavaFileObject {
@@ -573,14 +532,9 @@
                 throw new ClientCodeException(e);
             }
         }
-
-        @Override
-        public String toString() {
-            return wrappedToString(getClass(), clientFileObject);
-        }
     }
 
-    protected class WrappedDiagnosticListener<T /*super JavaFileObject*/> implements DiagnosticListener<T> {
+    protected class WrappedDiagnosticListener<T> implements DiagnosticListener<T> {
         protected DiagnosticListener<T> clientDiagnosticListener;
         WrappedDiagnosticListener(DiagnosticListener<T> clientDiagnosticListener) {
             clientDiagnosticListener.getClass(); // null check
@@ -590,7 +544,7 @@
         @Override
         public void report(Diagnostic<? extends T> diagnostic) {
             try {
-                clientDiagnosticListener.report(unwrap(diagnostic));
+                clientDiagnosticListener.report(diagnostic);
             } catch (ClientCodeException e) {
                 throw e;
             } catch (RuntimeException e) {
@@ -599,60 +553,6 @@
                 throw new ClientCodeException(e);
             }
         }
-
-        @Override
-        public String toString() {
-            return wrappedToString(getClass(), clientDiagnosticListener);
-        }
-    }
-
-    public class DiagnosticSourceUnwrapper implements Diagnostic<JavaFileObject> {
-        public final JCDiagnostic d;
-
-        DiagnosticSourceUnwrapper(JCDiagnostic d) {
-            this.d = d;
-        }
-
-        public Diagnostic.Kind getKind() {
-            return d.getKind();
-        }
-
-        public JavaFileObject getSource() {
-            return unwrap(d.getSource());
-        }
-
-        public long getPosition() {
-            return d.getPosition();
-        }
-
-        public long getStartPosition() {
-            return d.getStartPosition();
-        }
-
-        public long getEndPosition() {
-            return d.getEndPosition();
-        }
-
-        public long getLineNumber() {
-            return d.getLineNumber();
-        }
-
-        public long getColumnNumber() {
-            return d.getColumnNumber();
-        }
-
-        public String getCode() {
-            return d.getCode();
-        }
-
-        public String getMessage(Locale locale) {
-            return d.getMessage(locale);
-        }
-
-        @Override
-        public String toString() {
-            return d.toString();
-        }
     }
 
     protected class WrappedTaskListener implements TaskListener {
@@ -687,11 +587,6 @@
                 throw new ClientCodeException(e);
             }
         }
-
-        @Override
-        public String toString() {
-            return wrappedToString(getClass(), clientTaskListener);
-        }
     }
 
     // </editor-fold>
diff -u -r javac/api/JavacTaskImpl.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/api/JavacTaskImpl.java
--- javac/api/JavacTaskImpl.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/api/JavacTaskImpl.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -44,7 +44,6 @@
 import com.sun.tools.javac.comp.*;
 import com.sun.tools.javac.file.JavacFileManager;
 import com.sun.tools.javac.main.*;
-import com.sun.tools.javac.main.JavaCompiler;
 import com.sun.tools.javac.model.*;
 import com.sun.tools.javac.parser.Parser;
 import com.sun.tools.javac.parser.ParserFactory;
@@ -52,6 +51,7 @@
 import com.sun.tools.javac.tree.JCTree.*;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.List;
+import com.sun.tools.javac.main.JavaCompiler;
 
 /**
  * Provides access to functionality specific to the JDK Java Compiler, javac.
@@ -64,31 +64,29 @@
  * @author Peter von der Ah&eacute;
  * @author Jonathan Gibbons
  */
-public class JavacTaskImpl extends BasicJavacTask {
+public class JavacTaskImpl extends JavacTask {
     private ClientCodeWrapper ccw;
     private Main compilerMain;
     private JavaCompiler compiler;
     private Locale locale;
     private String[] args;
-    private String[] classNames;
+    private Context context;
     private List<JavaFileObject> fileObjects;
     private Map<JavaFileObject, JCCompilationUnit> notYetEntered;
     private ListBuffer<Env<AttrContext>> genList;
+    private TaskListener taskListener;
     private AtomicBoolean used = new AtomicBoolean();
     private Iterable<? extends Processor> processors;
 
-    private Main.Result result = null;
+    private Integer result = null;
 
     JavacTaskImpl(Main compilerMain,
                 String[] args,
-                String[] classNames,
                 Context context,
                 List<JavaFileObject> fileObjects) {
-        super(null, false);
         this.ccw = ClientCodeWrapper.instance(context);
         this.compilerMain = compilerMain;
         this.args = args;
-        this.classNames = classNames;
         this.context = context;
         this.fileObjects = fileObjects;
         setLocale(Locale.getDefault());
@@ -103,14 +101,17 @@
                 Context context,
                 Iterable<String> classes,
                 Iterable<? extends JavaFileObject> fileObjects) {
-        this(compilerMain, toArray(flags), toArray(classes), context, toList(fileObjects));
+        this(compilerMain, toArray(flags, classes), context, toList(fileObjects));
     }
 
-    static private String[] toArray(Iterable<String> iter) {
+    static private String[] toArray(Iterable<String> flags, Iterable<String> classes) {
         ListBuffer<String> result = new ListBuffer<String>();
-        if (iter != null)
-            for (String s : iter)
-                result.append(s);
+        if (flags != null)
+            for (String flag : flags)
+                result.append(flag);
+        if (classes != null)
+            for (String cls : classes)
+                result.append(cls);
         return result.toArray(new String[result.length()]);
     }
 
@@ -128,9 +129,9 @@
             initContext();
             notYetEntered = new HashMap<JavaFileObject, JCCompilationUnit>();
             compilerMain.setAPIMode(true);
-            result = compilerMain.compile(args, classNames, context, fileObjects, processors);
+            result = compilerMain.compile(args, context, fileObjects, processors);
             cleanup();
-            return result.isOK();
+            return result == 0;
         } else {
             throw new IllegalStateException("multiple calls to method 'call'");
         }
@@ -157,10 +158,10 @@
         } else {
             initContext();
             compilerMain.setOptions(Options.instance(context));
-            compilerMain.filenames = new LinkedHashSet<File>();
-            Collection<File> filenames = compilerMain.processArgs(CommandLine.parse(args), classNames);
+            compilerMain.filenames = new ListBuffer<File>();
+            List<File> filenames = compilerMain.processArgs(CommandLine.parse(args));
             if (!filenames.isEmpty())
-                throw new IllegalArgumentException("Malformed arguments " + toString(filenames, " "));
+                throw new IllegalArgumentException("Malformed arguments " + filenames.toString(" "));
             compiler = JavaCompiler.instance(context);
             compiler.keepComments = true;
             compiler.genEndPos = true;
@@ -173,23 +174,15 @@
             // endContext will be called when all classes have been generated
             // TODO: should handle the case after each phase if errors have occurred
             args = null;
-            classNames = null;
-        }
-    }
-
-    <T> String toString(Iterable<T> items, String sep) {
-        String currSep = "";
-        StringBuilder sb = new StringBuilder();
-        for (T item: items) {
-            sb.append(currSep);
-            sb.append(item.toString());
-            currSep = sep;
         }
-        return sb.toString();
     }
 
     private void initContext() {
-        context.put(JavacTask.class, this);
+        context.put(JavacTaskImpl.class, this);
+        if (context.get(TaskListener.class) != null)
+            context.put(TaskListener.class, (TaskListener)null);
+        if (taskListener != null)
+            context.put(TaskListener.class, ccw.wrap(taskListener));
         //initialize compiler's default locale
         context.put(Locale.class, locale);
     }
@@ -200,7 +193,6 @@
         compiler = null;
         compilerMain = null;
         args = null;
-        classNames = null;
         context = null;
         fileObjects = null;
         notYetEntered = null;
@@ -219,6 +211,10 @@
         return fm.getRegularFile(file);
     }
 
+    public void setTaskListener(TaskListener taskListener) {
+        this.taskListener = taskListener;
+    }
+
     /**
      * Parse the specified files returning a list of abstract syntax trees.
      *
@@ -267,9 +263,6 @@
     public Iterable<? extends TypeElement> enter(Iterable<? extends CompilationUnitTree> trees)
         throws IOException
     {
-        if (trees == null && notYetEntered != null && notYetEntered.isEmpty())
-            return List.nil();
-
         prepareCompiler();
 
         ListBuffer<JCCompilationUnit> roots = null;
@@ -318,7 +311,7 @@
             ListBuffer<TypeElement> elements = new ListBuffer<TypeElement>();
             for (JCCompilationUnit unit : units) {
                 for (JCTree node : unit.defs) {
-                    if (node.hasTag(JCTree.Tag.CLASSDEF)) {
+                    if (node.getTag() == JCTree.CLASSDEF) {
                         JCClassDecl cdef = (JCClassDecl) node;
                         if (cdef.sym != null) // maybe null if errors in anno processing
                             elements.append(cdef.sym);
@@ -376,12 +369,12 @@
         private void handleFlowResults(Queue<Env<AttrContext>> queue, ListBuffer<Element> elems) {
             for (Env<AttrContext> env: queue) {
                 switch (env.tree.getTag()) {
-                    case CLASSDEF:
+                    case JCTree.CLASSDEF:
                         JCClassDecl cdef = (JCClassDecl) env.tree;
                         if (cdef.sym != null)
                             elems.append(cdef.sym);
                         break;
-                    case TOPLEVEL:
+                    case JCTree.TOPLEVEL:
                         JCCompilationUnit unit = (JCCompilationUnit) env.tree;
                         if (unit.packge != null)
                             elems.append(unit.packge);
diff -u -r javac/api/JavacTool.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/api/JavacTool.java
--- javac/api/JavacTool.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/api/JavacTool.java	2011-06-27 15:21:47.000000000 -0500
@@ -25,15 +25,18 @@
 
 package com.sun.tools.javac.api;
 
+import java.io.File;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.io.Writer;
 import java.nio.charset.Charset;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Locale;
 import java.util.Set;
 import javax.lang.model.SourceVersion;
@@ -41,15 +44,16 @@
 
 import com.sun.source.util.JavacTask;
 import com.sun.tools.javac.file.JavacFileManager;
+import com.sun.tools.javac.main.JavacOption.OptionKind;
+import com.sun.tools.javac.main.JavacOption;
 import com.sun.tools.javac.main.Main;
-import com.sun.tools.javac.main.Option;
-import com.sun.tools.javac.main.OptionHelper;
-import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;
+import com.sun.tools.javac.main.RecognizedOptions.GrumpyHelper;
+import com.sun.tools.javac.main.RecognizedOptions;
 import com.sun.tools.javac.util.ClientCodeException;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.Log;
-import com.sun.tools.javac.util.Log.PrefixKind;
 import com.sun.tools.javac.util.Options;
+import com.sun.tools.javac.util.Pair;
 
 /**
  * TODO: describe com.sun.tools.javac.api.Tool
@@ -62,10 +66,23 @@
  * @author Peter von der Ah\u00e9
  */
 public final class JavacTool implements JavaCompiler {
+    private final List<Pair<String,String>> options
+        = new ArrayList<Pair<String,String>>();
+    private final Context dummyContext = new Context();
+
+    private final PrintWriter silent = new PrintWriter(new OutputStream(){
+        public void write(int b) {}
+    });
+
+    private final Main sharedCompiler = new Main("javac", silent);
+    {
+        sharedCompiler.setOptions(Options.instance(dummyContext));
+    }
+
     /**
-     * Constructor used by service provider mechanism.  The recommended way to
-     * obtain an instance of this class is by using {@link #create} or the
-     * service provider mechanism.
+     * Constructor used by service provider mechanism.  The correct way to
+     * obtain an instance of this class is using create or the service provider
+     * mechanism.
      * @see javax.tools.JavaCompilerTool
      * @see javax.tools.ToolProvider
      * @see #create
@@ -81,6 +98,49 @@
         return new JavacTool();
     }
 
+    private String argsToString(Object... args) {
+        String newArgs = null;
+        if (args.length > 0) {
+            StringBuilder sb = new StringBuilder();
+            String separator = "";
+            for (Object arg : args) {
+                sb.append(separator).append(arg.toString());
+                separator = File.pathSeparator;
+            }
+            newArgs = sb.toString();
+        }
+        return newArgs;
+    }
+
+    private void setOption1(String name, OptionKind kind, Object... args) {
+        String arg = argsToString(args);
+        JavacOption option = sharedCompiler.getOption(name);
+        if (option == null || !match(kind, option.getKind()))
+            throw new IllegalArgumentException(name);
+        if ((args.length != 0) != option.hasArg())
+            throw new IllegalArgumentException(name);
+        if (option.hasArg()) {
+            if (option.process(null, name, arg)) // FIXME
+                throw new IllegalArgumentException(name);
+        } else {
+            if (option.process(null, name)) // FIXME
+                throw new IllegalArgumentException(name);
+        }
+        options.add(new Pair<String,String>(name,arg));
+    }
+
+    public void setOption(String name, Object... args) {
+        setOption1(name, OptionKind.NORMAL, args);
+    }
+
+    public void setExtendedOption(String name, Object... args)  {
+        setOption1(name, OptionKind.EXTENDED, args);
+    }
+
+    private static boolean match(OptionKind clientKind, OptionKind optionKind) {
+        return (clientKind == (optionKind == OptionKind.HIDDEN ? OptionKind.EXTENDED : optionKind));
+    }
+
     public JavacFileManager getStandardFileManager(
         DiagnosticListener<? super JavaFileObject> diagnosticListener,
         Locale locale,
@@ -96,28 +156,15 @@
         return new JavacFileManager(context, true, charset);
     }
 
-    @Override
     public JavacTask getTask(Writer out,
                              JavaFileManager fileManager,
                              DiagnosticListener<? super JavaFileObject> diagnosticListener,
                              Iterable<String> options,
                              Iterable<String> classes,
-                             Iterable<? extends JavaFileObject> compilationUnits) {
-        Context context = new Context();
-        return getTask(out, fileManager, diagnosticListener,
-                options, classes, compilationUnits,
-                context);
-    }
-
-    public JavacTask getTask(Writer out,
-                             JavaFileManager fileManager,
-                             DiagnosticListener<? super JavaFileObject> diagnosticListener,
-                             Iterable<String> options,
-                             Iterable<String> classes,
-                             Iterable<? extends JavaFileObject> compilationUnits,
-                             Context context)
+                             Iterable<? extends JavaFileObject> compilationUnits)
     {
         try {
+            Context context = new Context();
             ClientCodeWrapper ccw = ClientCodeWrapper.instance(context);
 
             final String kindMsg = "All compilation units must be of SOURCE kind";
@@ -148,9 +195,7 @@
             if (fileManager == null)
                 fileManager = getStandardFileManager(diagnosticListener, null, null);
             fileManager = ccw.wrap(fileManager);
-
             context.put(JavaFileManager.class, fileManager);
-
             processOptions(context, fileManager, options);
             Main compiler = new Main("javacTask", context.get(Log.outKey));
             return new JavacTaskImpl(compiler, options, context, classes, compilationUnits);
@@ -166,28 +211,10 @@
         if (options == null)
             return;
 
-        final Options optionTable = Options.instance(context);
-        Log log = Log.instance(context);
-
-        Option[] recognizedOptions =
-                Option.getJavacToolOptions().toArray(new Option[0]);
-        OptionHelper optionHelper = new GrumpyHelper(log) {
-            @Override
-            public String get(Option option) {
-                return optionTable.get(option.getText());
-            }
-
-            @Override
-            public void put(String name, String value) {
-                optionTable.put(name, value);
-            }
-
-            @Override
-            public void remove(String name) {
-                optionTable.remove(name);
-            }
-        };
+        Options optionTable = Options.instance(context);
 
+        JavacOption[] recognizedOptions =
+            RecognizedOptions.getJavacToolOptions(new GrumpyHelper());
         Iterator<String> flags = options.iterator();
         while (flags.hasNext()) {
             String flag = flags.next();
@@ -200,31 +227,29 @@
                 if (fileManager.handleOption(flag, flags)) {
                     continue;
                 } else {
-                    String msg = log.localize(PrefixKind.JAVAC, "err.invalid.flag", flag);
+                    String msg = Main.getLocalizedString("err.invalid.flag", flag);
                     throw new IllegalArgumentException(msg);
                 }
             }
 
-            Option option = recognizedOptions[j];
+            JavacOption option = recognizedOptions[j];
             if (option.hasArg()) {
                 if (!flags.hasNext()) {
-                    String msg = log.localize(PrefixKind.JAVAC, "err.req.arg", flag);
+                    String msg = Main.getLocalizedString("err.req.arg", flag);
                     throw new IllegalArgumentException(msg);
                 }
                 String operand = flags.next();
-                if (option.process(optionHelper, flag, operand))
+                if (option.process(optionTable, flag, operand))
                     // should not happen as the GrumpyHelper will throw exceptions
                     // in case of errors
                     throw new IllegalArgumentException(flag + " " + operand);
             } else {
-                if (option.process(optionHelper, flag))
+                if (option.process(optionTable, flag))
                     // should not happen as the GrumpyHelper will throw exceptions
                     // in case of errors
                     throw new IllegalArgumentException(flag);
             }
         }
-
-        optionTable.notifyListeners();
     }
 
     public int run(InputStream in, OutputStream out, OutputStream err, String... arguments) {
@@ -241,8 +266,9 @@
     }
 
     public int isSupportedOption(String option) {
-        Set<Option> recognizedOptions = Option.getJavacToolOptions();
-        for (Option o : recognizedOptions) {
+        JavacOption[] recognizedOptions =
+            RecognizedOptions.getJavacToolOptions(new GrumpyHelper());
+        for (JavacOption o : recognizedOptions) {
             if (o.matches(option))
                 return o.hasArg() ? 1 : 0;
         }
diff -u -r javac/api/JavacTrees.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/api/JavacTrees.java
--- javac/api/JavacTrees.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/api/JavacTrees.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,7 +26,7 @@
 package com.sun.tools.javac.api;
 
 import java.io.IOException;
-
+import java.util.Map;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -44,14 +44,13 @@
 import com.sun.source.tree.CompilationUnitTree;
 import com.sun.source.tree.Scope;
 import com.sun.source.tree.Tree;
-import com.sun.source.util.JavacTask;
 import com.sun.source.util.SourcePositions;
 import com.sun.source.util.TreePath;
 import com.sun.source.util.Trees;
 import com.sun.tools.javac.code.Flags;
-import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 import com.sun.tools.javac.code.Symbol.TypeSymbol;
+import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Type.UnionClassType;
 import com.sun.tools.javac.comp.Attr;
 import com.sun.tools.javac.comp.AttrContext;
@@ -60,14 +59,12 @@
 import com.sun.tools.javac.comp.MemberEnter;
 import com.sun.tools.javac.comp.Resolve;
 import com.sun.tools.javac.model.JavacElements;
-import com.sun.tools.javac.parser.EndPosTable;
 import com.sun.tools.javac.processing.JavacProcessingEnvironment;
-import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.*;
+import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.TreeCopier;
 import com.sun.tools.javac.tree.TreeInfo;
 import com.sun.tools.javac.tree.TreeMaker;
-import com.sun.tools.javac.util.Assert;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.JCDiagnostic;
 import com.sun.tools.javac.util.List;
@@ -96,14 +93,12 @@
     private JavacElements elements;
     private JavacTaskImpl javacTaskImpl;
 
-    // called reflectively from Trees.instance(CompilationTask task)
     public static JavacTrees instance(JavaCompiler.CompilationTask task) {
         if (!(task instanceof JavacTaskImpl))
             throw new IllegalArgumentException();
         return instance(((JavacTaskImpl)task).getContext());
     }
 
-    // called reflectively from Trees.instance(ProcessingEnvironment env)
     public static JavacTrees instance(ProcessingEnvironment env) {
         if (!(env instanceof JavacProcessingEnvironment))
             throw new IllegalArgumentException();
@@ -134,10 +129,7 @@
         resolve = Resolve.instance(context);
         treeMaker = TreeMaker.instance(context);
         memberEnter = MemberEnter.instance(context);
-
-        JavacTask t = context.get(JavacTask.class);
-        if (t instanceof JavacTaskImpl)
-            javacTaskImpl = (JavacTaskImpl) t;
+        javacTaskImpl = context.get(JavacTaskImpl.class);
     }
 
     public SourcePositions getSourcePositions() {
@@ -147,8 +139,8 @@
                 }
 
                 public long getEndPosition(CompilationUnitTree file, Tree tree) {
-                    EndPosTable endPosTable = ((JCCompilationUnit) file).endPositions;
-                    return TreeInfo.getEndPos((JCTree) tree, endPosTable);
+                    Map<JCTree,Integer> endPositions = ((JCCompilationUnit) file).endPositions;
+                    return TreeInfo.getEndPos((JCTree) tree, endPositions);
                 }
             };
     }
@@ -214,7 +206,7 @@
         if (sym == null && TreeInfo.isDeclaration(tree)) {
             for (TreePath p = path; p != null; p = p.getParentPath()) {
                 JCTree t = (JCTree) p.getLeaf();
-                if (t.hasTag(JCTree.Tag.CLASSDEF)) {
+                if (t.getTag() == JCTree.CLASSDEF) {
                     JCClassDecl ct = (JCClassDecl) t;
                     if (ct.sym != null) {
                         if ((ct.sym.flags_field & Flags.UNATTRIBUTED) != 0) {
@@ -271,10 +263,9 @@
         if (!(path.getLeaf() instanceof JCTree))  // implicit null-check
             throw new IllegalArgumentException();
 
-        // if we're being invoked from a Tree API client via parse/enter/analyze,
-        // we need to make sure all the classes have been entered;
-        // if we're being invoked from JSR 199 or JSR 269, then the classes
-        // will already have been entered.
+        // if we're being invoked via from a JSR199 client, we need to make sure
+        // all the classes have been entered; if we're being invoked from JSR269,
+        // then the classes will already have been entered.
         if (javacTaskImpl != null) {
             try {
                 javacTaskImpl.enter(null);
@@ -322,19 +313,10 @@
                     break;
                 case BLOCK: {
 //                    System.err.println("BLOCK: ");
-                    if (method != null) {
-                        try {
-                            Assert.check(method.body == tree);
-                            method.body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
-                            env = memberEnter.getMethodEnv(method, env);
-                            env = attribStatToTree(method.body, env, copier.leafCopy);
-                        } finally {
-                            method.body = (JCBlock) tree;
-                        }
-                    } else {
-                        JCBlock body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
-                        env = attribStatToTree(body, env, copier.leafCopy);
-                    }
+                    if (method != null)
+                        env = memberEnter.getMethodEnv(method, env);
+                    JCTree body = copier.copy((JCTree)tree, (JCTree) path.getLeaf());
+                    env = attribStatToTree(body, env, copier.leafCopy);
                     return env;
                 }
                 default:
@@ -347,7 +329,7 @@
                     }
             }
         }
-        return (field != null) ? memberEnter.getInitEnv(field, env) : env;
+        return field != null ? memberEnter.getInitEnv(field, env) : env;
     }
 
     private Env<AttrContext> attribStatToTree(JCTree stat, Env<AttrContext>env, JCTree tree) {
Only in javac/api: MultiTaskListener.java
diff -u -r javac/code/Flags.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Flags.java
--- javac/code/Flags.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Flags.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -221,7 +221,7 @@
 
     /** Flag that marks a hypothetical method that need not really be
      *  generated in the binary, but is present in the symbol table to
-     *  simplify checking for erasure clashes - also used for 292 poly sig methods.
+     *  simplify checking for erasure clashes.
      */
     public static final long HYPOTHETICAL   = 1L<<37;
 
@@ -236,20 +236,26 @@
     public static final long UNION = 1L<<39;
 
     /**
+     * Flag that marks a signature-polymorphic invoke method.
+     * (These occur inside java.lang.invoke.MethodHandle.)
+     */
+    public static final long POLYMORPHIC_SIGNATURE = 1L<<40;
+
+    /**
      * Flag that marks a special kind of bridge methods (the ones that
      * come from restricted supertype bounds)
      */
-    public static final long OVERRIDE_BRIDGE = 1L<<40;
+    public static final long OVERRIDE_BRIDGE = 1L<<41;
 
     /**
      * Flag that marks an 'effectively final' local variable
      */
-    public static final long EFFECTIVELY_FINAL = 1L<<41;
+    public static final long EFFECTIVELY_FINAL = 1L<<42;
 
     /**
      * Flag that marks non-override equivalent methods with the same signature
      */
-    public static final long CLASH = 1L<<42;
+    public static final long CLASH = 1L<<43;
 
     /** Modifier masks.
      */
diff -u -r javac/code/Kinds.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Kinds.java
--- javac/code/Kinds.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Kinds.java	2011-06-27 15:21:47.000000000 -0500
@@ -103,8 +103,6 @@
         VAL("kindname.value"),
         METHOD("kindname.method"),
         CLASS("kindname.class"),
-        STATIC_INIT("kindname.static.init"),
-        INSTANCE_INIT("kindname.instance.init"),
         PACKAGE("kindname.package");
 
         private String name;
@@ -172,11 +170,9 @@
             return KindName.CONSTRUCTOR;
 
         case METHOD:
-            return KindName.METHOD;
         case STATIC_INIT:
-            return KindName.STATIC_INIT;
         case INSTANCE_INIT:
-            return KindName.INSTANCE_INIT;
+            return KindName.METHOD;
 
         default:
             if (sym.kind == VAL)
diff -u -r javac/code/Printer.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Printer.java
--- javac/code/Printer.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Printer.java	2011-06-27 15:21:47.000000000 -0500
@@ -258,7 +258,7 @@
             ClassType norm = (ClassType) t.tsym.type;
             if (norm == null) {
                 s = localize(locale, "compiler.misc.anonymous.class", (Object) null);
-            } else if (norm.interfaces_field != null && norm.interfaces_field.nonEmpty()) {
+            } else if (norm.interfaces_field.nonEmpty()) {
                 s = localize(locale, "compiler.misc.anonymous.class",
                         visit(norm.interfaces_field.head, locale));
             } else {
@@ -311,7 +311,7 @@
 
     @Override
     public String visitMethodSymbol(MethodSymbol s, Locale locale) {
-        if (s.isStaticOrInstanceInit()) {
+        if ((s.flags() & BLOCK) != 0) {
             return s.owner.name.toString();
         } else {
             String ms = (s.name == s.name.table.names.init)
diff -u -r javac/code/Source.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Source.java
--- javac/code/Source.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Source.java	2011-06-27 15:21:47.000000000 -0500
@@ -32,7 +32,7 @@
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.jvm.Target;
 
-import static com.sun.tools.javac.main.Option.*;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /** The source language version accepted.
  *
@@ -64,11 +64,8 @@
     /** 1.6 reports encoding problems as errors instead of warnings. */
     JDK1_6("1.6"),
 
-    /** 1.7 introduced try-with-resources, multi-catch, string switch, etc. */
-    JDK1_7("1.7"),
-
-    /** 1.8 covers the to be determined language features that will be added in JDK 8. */
-    JDK1_8("1.8");
+    /** 1.7 covers the to be determined language features that will be added in JDK 7. */
+    JDK1_7("1.7");
 
     private static final Context.Key<Source> sourceKey
         = new Context.Key<Source>();
@@ -95,21 +92,19 @@
         tab.put("5", JDK1_5); // Make 5 an alias for 1.5
         tab.put("6", JDK1_6); // Make 6 an alias for 1.6
         tab.put("7", JDK1_7); // Make 7 an alias for 1.7
-        tab.put("8", JDK1_8); // Make 8 an alias for 1.8
     }
 
     private Source(String name) {
         this.name = name;
     }
 
-    public static final Source DEFAULT = JDK1_8;
+    public static final Source DEFAULT = JDK1_7;
 
     public static Source lookup(String name) {
         return tab.get(name);
     }
 
     public Target requiredTarget() {
-        if (this.compareTo(JDK1_8) >= 0) return Target.JDK1_8;
         if (this.compareTo(JDK1_7) >= 0) return Target.JDK1_7;
         if (this.compareTo(JDK1_6) >= 0) return Target.JDK1_6;
         if (this.compareTo(JDK1_5) >= 0) return Target.JDK1_5;
@@ -194,12 +189,6 @@
     public boolean allowObjectToPrimitiveCast() {
         return compareTo(JDK1_7) >= 0;
     }
-    public boolean allowLambda() {
-        return compareTo(JDK1_8) >= 0;
-    }
-    public boolean allowMethodReferences() {
-        return compareTo(JDK1_8) >= 0;
-    }
     public static SourceVersion toSourceVersion(Source source) {
         switch(source) {
         case JDK1_2:
@@ -214,8 +203,6 @@
             return RELEASE_6;
         case JDK1_7:
             return RELEASE_7;
-        case JDK1_8:
-            return RELEASE_8;
         default:
             return null;
         }
diff -u -r javac/code/Symbol.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Symbol.java
--- javac/code/Symbol.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Symbol.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -149,8 +149,7 @@
      * the default package; otherwise, the owner symbol is returned
      */
     public Symbol location() {
-        if (owner.name == null || (owner.name.isEmpty() &&
-                (owner.flags() & BLOCK) == 0 && owner.kind != PCK && owner.kind != TYP)) {
+        if (owner.name == null || (owner.name.isEmpty() && owner.kind != PCK && owner.kind != TYP)) {
             return null;
         }
         return owner;
@@ -202,6 +201,16 @@
         return (flags() & INTERFACE) != 0;
     }
 
+    /** Recognize if this symbol was marked @PolymorphicSignature in the source. */
+    public boolean isPolymorphicSignatureGeneric() {
+        return (flags() & (POLYMORPHIC_SIGNATURE | HYPOTHETICAL)) == POLYMORPHIC_SIGNATURE;
+    }
+
+    /** Recognize if this symbol was split from a @PolymorphicSignature symbol in the source. */
+    public boolean isPolymorphicSignatureInstance() {
+        return (flags() & (POLYMORPHIC_SIGNATURE | HYPOTHETICAL)) == (POLYMORPHIC_SIGNATURE | HYPOTHETICAL);
+    }
+
     /** Is this symbol declared (directly or indirectly) local
      *  to a method or variable initializer?
      *  Also includes fields of inner classes which are in
@@ -716,11 +725,6 @@
          */
         public JavaFileObject classfile;
 
-        /** the list of translated local classes (used for generating
-         * InnerClasses attribute)
-         */
-        public List<ClassSymbol> trans_local;
-
         /** the constant pool of the class
          */
         public Pool pool;
@@ -1225,7 +1229,7 @@
             // if origin is derived from a raw type, we might have missed
             // an implementation because we do not know enough about instantiations.
             // in this case continue with the supertype as origin.
-            if (types.isDerivedRaw(origin.type) && !origin.isInterface())
+            if (types.isDerivedRaw(origin.type))
                 return implementation(types.supertype(origin.type).tsym, types, checkResult);
             else
                 return null;
@@ -1295,36 +1299,10 @@
                 return ElementKind.CONSTRUCTOR;
             else if (name == name.table.names.clinit)
                 return ElementKind.STATIC_INIT;
-            else if ((flags() & BLOCK) != 0)
-                return isStatic() ? ElementKind.STATIC_INIT : ElementKind.INSTANCE_INIT;
             else
                 return ElementKind.METHOD;
         }
 
-        public boolean isStaticOrInstanceInit() {
-            return getKind() == ElementKind.STATIC_INIT ||
-                    getKind() == ElementKind.INSTANCE_INIT;
-        }
-
-        /**
-         * A polymorphic signature method (JLS SE 7, 8.4.1) is a method that
-         * (i) is declared in the java.lang.invoke.MethodHandle class, (ii) takes
-         * a single variable arity parameter (iii) whose declared type is Object[],
-         * (iv) has a return type of Object and (v) is native.
-         */
-        public boolean isSignaturePolymorphic(Types types) {
-            List<Type> argtypes = type.getParameterTypes();
-            Type firstElemType = argtypes.nonEmpty() ?
-                    types.elemtype(argtypes.head) :
-                    null;
-            return owner == types.syms.methodHandleType.tsym &&
-                    argtypes.length() == 1 &&
-                    firstElemType != null &&
-                    types.isSameType(firstElemType, types.syms.objectType) &&
-                    types.isSameType(type.getReturnType(), types.syms.objectType) &&
-                    (flags() & NATIVE) != 0;
-        }
-
         public Attribute getDefaultValue() {
             return defaultValue;
         }
diff -u -r javac/code/Symtab.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Symtab.java
--- javac/code/Symtab.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Symtab.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -126,7 +126,7 @@
     public final Type cloneableType;
     public final Type serializableType;
     public final Type methodHandleType;
-    public final Type nativeHeaderType;
+    public final Type polymorphicSignatureType;
     public final Type throwableType;
     public final Type errorType;
     public final Type interruptedExceptionType;
@@ -435,6 +435,7 @@
         throwableType = enterClass("java.lang.Throwable");
         serializableType = enterClass("java.io.Serializable");
         methodHandleType = enterClass("java.lang.invoke.MethodHandle");
+        polymorphicSignatureType = enterClass("java.lang.invoke.MethodHandle$PolymorphicSignature");
         errorType = enterClass("java.lang.Error");
         illegalArgumentExceptionType = enterClass("java.lang.IllegalArgumentException");
         interruptedExceptionType = enterClass("java.lang.InterruptedException");
@@ -476,11 +477,11 @@
                                             List.of(exceptionType), methodClass),
                              autoCloseableType.tsym);
         trustMeType = enterClass("java.lang.SafeVarargs");
-        nativeHeaderType = enterClass("javax.tools.annotation.GenerateNativeHeader");
 
         synthesizeEmptyInterfaceIfMissing(autoCloseableType);
         synthesizeEmptyInterfaceIfMissing(cloneableType);
         synthesizeEmptyInterfaceIfMissing(serializableType);
+        synthesizeEmptyInterfaceIfMissing(polymorphicSignatureType);
         synthesizeBoxTypeIfMissing(doubleType);
         synthesizeBoxTypeIfMissing(floatType);
         synthesizeBoxTypeIfMissing(voidType);
diff -u -r javac/code/Type.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Type.java
--- javac/code/Type.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Type.java	2011-06-27 15:21:47.000000000 -0500
@@ -1147,6 +1147,29 @@
         }
 
         /**
+         * Kind of type-constraint derived during type inference
+         */
+        public enum ConstraintKind {
+            /**
+             * upper bound constraint (a type variable must be instantiated
+             * with a type T, where T is a subtype of all the types specified by
+             * its EXTENDS constraints).
+             */
+            EXTENDS,
+            /**
+             * lower bound constraint (a type variable must be instantiated
+             * with a type T, where T is a supertype of all the types specified by
+             * its SUPER constraints).
+             */
+            SUPER,
+            /**
+             * equality constraint (a type variable must be instantiated to the type
+             * specified by its EQUAL constraint.
+             */
+            EQUAL;
+        }
+
+        /**
          * Get the type-constraints of a given kind for a given type-variable of
          * this ForAll type. Subclasses should override in order to return more
          * accurate sets of constraints.
@@ -1155,7 +1178,7 @@
          * @param ck the constraint kind to be retrieved
          * @return the list of types specified by the selected constraint
          */
-        public List<Type> undetvars() {
+        public List<Type> getConstraints(TypeVar tv, ConstraintKind ck) {
             return List.nil();
         }
 
@@ -1197,7 +1220,6 @@
     public static class UndetVar extends DelegatedType {
         public List<Type> lobounds = List.nil();
         public List<Type> hibounds = List.nil();
-        public List<Type> eq = List.nil();
         public Type inst = null;
 
         @Override
diff -u -r javac/code/Types.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Types.java
--- javac/code/Types.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/code/Types.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -269,15 +269,14 @@
 
     // <editor-fold defaultstate="collapsed" desc="isConvertible">
     /**
-     * Is t a subtype of or convertible via boxing/unboxing
-     * conversion to s?
+     * Is t a subtype of or convertiable via boxing/unboxing
+     * convertions to s?
      */
     public boolean isConvertible(Type t, Type s, Warner warn) {
-        if (t.tag == ERROR)
-            return true;
         boolean tPrimitive = t.isPrimitive();
         boolean sPrimitive = s.isPrimitive();
         if (tPrimitive == sPrimitive) {
+            checkUnsafeVarargsConversion(t, s, warn);
             return isSubtypeUnchecked(t, s, warn);
         }
         if (!allowBoxing) return false;
@@ -285,6 +284,27 @@
             ? isSubtype(boxedClass(t).type, s)
             : isSubtype(unboxedType(t), s);
     }
+    //where
+    private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
+        if (t.tag != ARRAY || isReifiable(t)) return;
+        ArrayType from = (ArrayType)t;
+        boolean shouldWarn = false;
+        switch (s.tag) {
+            case ARRAY:
+                ArrayType to = (ArrayType)s;
+                shouldWarn = from.isVarargs() &&
+                        !to.isVarargs() &&
+                        !isReifiable(from);
+                break;
+            case CLASS:
+                shouldWarn = from.isVarargs() &&
+                        isSubtype(from, s);
+                break;
+        }
+        if (shouldWarn) {
+            warn.warn(LintCategory.VARARGS);
+        }
+    }
 
     /**
      * Is t a subtype of or convertiable via boxing/unboxing
@@ -306,58 +326,42 @@
      * Is t an unchecked subtype of s?
      */
     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
-        boolean result = isSubtypeUncheckedInternal(t, s, warn);
-        if (result) {
-            checkUnsafeVarargsConversion(t, s, warn);
-        }
-        return result;
-    }
-    //where
-        private boolean isSubtypeUncheckedInternal(Type t, Type s, Warner warn) {
-            if (t.tag == ARRAY && s.tag == ARRAY) {
-                if (((ArrayType)t).elemtype.tag <= lastBaseTag) {
-                    return isSameType(elemtype(t), elemtype(s));
-                } else {
-                    return isSubtypeUnchecked(elemtype(t), elemtype(s), warn);
-                }
-            } else if (isSubtype(t, s)) {
-                return true;
-            }
-            else if (t.tag == TYPEVAR) {
-                return isSubtypeUnchecked(t.getUpperBound(), s, warn);
-            }
-            else if (!s.isRaw()) {
-                Type t2 = asSuper(t, s.tsym);
-                if (t2 != null && t2.isRaw()) {
-                    if (isReifiable(s))
-                        warn.silentWarn(LintCategory.UNCHECKED);
-                    else
-                        warn.warn(LintCategory.UNCHECKED);
-                    return true;
+        if (t.tag == ARRAY && s.tag == ARRAY) {
+            if (((ArrayType)t).elemtype.tag <= lastBaseTag) {
+                return isSameType(elemtype(t), elemtype(s));
+            } else {
+                ArrayType from = (ArrayType)t;
+                ArrayType to = (ArrayType)s;
+                if (from.isVarargs() &&
+                        !to.isVarargs() &&
+                        !isReifiable(from)) {
+                    warn.warn(LintCategory.VARARGS);
                 }
+                return isSubtypeUnchecked(elemtype(t), elemtype(s), warn);
             }
-            return false;
+        } else if (isSubtype(t, s)) {
+            return true;
         }
-
-        private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
-            if (t.tag != ARRAY || isReifiable(t)) return;
-            ArrayType from = (ArrayType)t;
-            boolean shouldWarn = false;
-            switch (s.tag) {
-                case ARRAY:
-                    ArrayType to = (ArrayType)s;
-                    shouldWarn = from.isVarargs() &&
-                            !to.isVarargs() &&
-                            !isReifiable(from);
-                    break;
-                case CLASS:
-                    shouldWarn = from.isVarargs();
-                    break;
-            }
-            if (shouldWarn) {
-                warn.warn(LintCategory.VARARGS);
+        else if (t.tag == TYPEVAR) {
+            return isSubtypeUnchecked(t.getUpperBound(), s, warn);
+        }
+        else if (s.tag == UNDETVAR) {
+            UndetVar uv = (UndetVar)s;
+            if (uv.inst != null)
+                return isSubtypeUnchecked(t, uv.inst, warn);
+        }
+        else if (!s.isRaw()) {
+            Type t2 = asSuper(t, s.tsym);
+            if (t2 != null && t2.isRaw()) {
+                if (isReifiable(s))
+                    warn.silentWarn(LintCategory.UNCHECKED);
+                else
+                    warn.warn(LintCategory.UNCHECKED);
+                return true;
             }
         }
+        return false;
+    }
 
     /**
      * Is t a subtype of s?<br>
@@ -502,13 +506,11 @@
             @Override
             public Boolean visitUndetVar(UndetVar t, Type s) {
                 //todo: test against origin needed? or replace with substitution?
-                if (t == s || t.qtype == s || s.tag == ERROR || s.tag == UNKNOWN) {
+                if (t == s || t.qtype == s || s.tag == ERROR || s.tag == UNKNOWN)
                     return true;
-                } else if (s.tag == BOT) {
-                    //if 's' is 'null' there's no instantiated type U for which
-                    //U <: s (but 'null' itself, which is not a valid type)
-                    return false;
-                }
+
+                if (t.inst != null)
+                    return isSubtypeNoCapture(t.inst, s); // TODO: ", warn"?
 
                 t.hibounds = t.hibounds.prepend(s);
                 return true;
@@ -578,6 +580,8 @@
                 undet.qtype == s ||
                 s.tag == ERROR ||
                 s.tag == BOT) return true;
+            if (undet.inst != null)
+                return isSubtype(s, undet.inst);
             undet.lobounds = undet.lobounds.prepend(s);
             return true;
         }
@@ -723,8 +727,18 @@
                 if (t == s || t.qtype == s || s.tag == ERROR || s.tag == UNKNOWN)
                     return true;
 
-                t.eq = t.eq.prepend(s);
+                if (t.inst != null)
+                    return visit(t.inst, s);
 
+                t.inst = fromUnknownFun.apply(s);
+                for (List<Type> l = t.lobounds; l.nonEmpty(); l = l.tail) {
+                    if (!isSubtype(l.head, t.inst))
+                        return false;
+                }
+                for (List<Type> l = t.hibounds; l.nonEmpty(); l = l.tail) {
+                    if (!isSubtype(t.inst, l.head))
+                        return false;
+                }
                 return true;
             }
 
@@ -759,11 +773,23 @@
                     case UNBOUND: //similar to ? extends Object
                     case EXTENDS: {
                         Type bound = upperBound(s);
+                        // We should check the new upper bound against any of the
+                        // undetvar's lower bounds.
+                        for (Type t2 : undetvar.lobounds) {
+                            if (!isSubtype(t2, bound))
+                                return false;
+                        }
                         undetvar.hibounds = undetvar.hibounds.prepend(bound);
                         break;
                     }
                     case SUPER: {
                         Type bound = lowerBound(s);
+                        // We should check the new lower bound against any of the
+                        // undetvar's lower bounds.
+                        for (Type t2 : undetvar.hibounds) {
+                            if (!isSubtype(bound, t2))
+                                return false;
+                        }
                         undetvar.lobounds = undetvar.lobounds.prepend(bound);
                         break;
                     }
@@ -2091,8 +2117,6 @@
             }
         }
 
-        List<TypeSymbol> seenTypes = List.nil();
-
         /** members closure visitor methods **/
 
         public CompoundScope visitType(Type t, Boolean skipInterface) {
@@ -2101,33 +2125,21 @@
 
         @Override
         public CompoundScope visitClassType(ClassType t, Boolean skipInterface) {
-            if (seenTypes.contains(t.tsym)) {
-                //this is possible when an interface is implemented in multiple
-                //superclasses, or when a classs hierarchy is circular - in such
-                //cases we don't need to recurse (empty scope is returned)
-                return new CompoundScope(t.tsym);
-            }
-            try {
-                seenTypes = seenTypes.prepend(t.tsym);
-                ClassSymbol csym = (ClassSymbol)t.tsym;
-                Entry e = _map.get(csym);
-                if (e == null || !e.matches(skipInterface)) {
-                    CompoundScope membersClosure = new CompoundScope(csym);
-                    if (!skipInterface) {
-                        for (Type i : interfaces(t)) {
-                            membersClosure.addSubScope(visit(i, skipInterface));
-                        }
+            ClassSymbol csym = (ClassSymbol)t.tsym;
+            Entry e = _map.get(csym);
+            if (e == null || !e.matches(skipInterface)) {
+                CompoundScope membersClosure = new CompoundScope(csym);
+                if (!skipInterface) {
+                    for (Type i : interfaces(t)) {
+                        membersClosure.addSubScope(visit(i, skipInterface));
                     }
-                    membersClosure.addSubScope(visit(supertype(t), skipInterface));
-                    membersClosure.addSubScope(csym.members());
-                    e = new Entry(skipInterface, membersClosure);
-                    _map.put(csym, e);
                 }
-                return e.compoundScope;
-            }
-            finally {
-                seenTypes = seenTypes.tail;
+                membersClosure.addSubScope(visit(supertype(t), skipInterface));
+                membersClosure.addSubScope(csym.members());
+                e = new Entry(skipInterface, membersClosure);
+                _map.put(csym, e);
             }
+            return e.compoundScope;
         }
 
         @Override
@@ -3568,44 +3580,39 @@
 
         @Override
         public Type visitCapturedType(CapturedType t, Void s) {
-            Type w_bound = t.wildcard.type;
-            Type bound = w_bound.contains(t) ?
-                        erasure(w_bound) :
-                        visit(w_bound);
-            return rewriteAsWildcardType(visit(bound), t.wildcard.bound, t.wildcard.kind);
+            Type bound = visitWildcardType(t.wildcard, null);
+            return (bound.contains(t)) ?
+                    erasure(bound) :
+                    bound;
         }
 
         @Override
         public Type visitTypeVar(TypeVar t, Void s) {
             if (rewriteTypeVars) {
-                Type bound = t.bound.contains(t) ?
+                Type bound = high ?
+                    (t.bound.contains(t) ?
                         erasure(t.bound) :
-                        visit(t.bound);
-                return rewriteAsWildcardType(bound, t, EXTENDS);
-            } else {
-                return t;
+                        visit(t.bound)) :
+                    syms.botType;
+                return rewriteAsWildcardType(bound, t);
             }
+            else
+                return t;
         }
 
         @Override
         public Type visitWildcardType(WildcardType t, Void s) {
-            Type bound2 = visit(t.type);
-            return t.type == bound2 ? t : rewriteAsWildcardType(bound2, t.bound, t.kind);
+            Type bound = high ? t.getExtendsBound() :
+                                t.getSuperBound();
+            if (bound == null)
+            bound = high ? syms.objectType : syms.botType;
+            return rewriteAsWildcardType(visit(bound), t.bound);
         }
 
-        private Type rewriteAsWildcardType(Type bound, TypeVar formal, BoundKind bk) {
-            switch (bk) {
-               case EXTENDS: return high ?
-                       makeExtendsWildcard(B(bound), formal) :
-                       makeExtendsWildcard(syms.objectType, formal);
-               case SUPER: return high ?
-                       makeSuperWildcard(syms.botType, formal) :
-                       makeSuperWildcard(B(bound), formal);
-               case UNBOUND: return makeExtendsWildcard(syms.objectType, formal);
-               default:
-                   Assert.error("Invalid bound kind " + bk);
-                   return null;
-            }
+        private Type rewriteAsWildcardType(Type bound, TypeVar formal) {
+            return high ?
+                makeExtendsWildcard(B(bound), formal) :
+                makeSuperWildcard(B(bound), formal);
         }
 
         Type B(Type t) {
diff -u -r javac/comp/Annotate.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Annotate.java
--- javac/comp/Annotate.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Annotate.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,8 +31,6 @@
 import com.sun.tools.javac.tree.*;
 import com.sun.tools.javac.tree.JCTree.*;
 
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
-
 /** Enter annotations on symbols.  Annotations accumulate in a queue,
  *  which is processed at the top level of any set of recursive calls
  *  requesting it be processed.
@@ -150,7 +148,7 @@
             return new Attribute.Compound(a.type, List.<Pair<MethodSymbol,Attribute>>nil());
         }
         List<JCExpression> args = a.args;
-        if (args.length() == 1 && !args.head.hasTag(ASSIGN)) {
+        if (args.length() == 1 && args.head.getTag() != JCTree.ASSIGN) {
             // special case: elided "value=" assumed
             args.head = make.at(args.head.pos).
                 Assign(make.Ident(names.value), args.head);
@@ -159,12 +157,12 @@
             new ListBuffer<Pair<MethodSymbol,Attribute>>();
         for (List<JCExpression> tl = args; tl.nonEmpty(); tl = tl.tail) {
             JCExpression t = tl.head;
-            if (!t.hasTag(ASSIGN)) {
+            if (t.getTag() != JCTree.ASSIGN) {
                 log.error(t.pos(), "annotation.value.must.be.name.value");
                 continue;
             }
             JCAssign assign = (JCAssign)t;
-            if (!assign.lhs.hasTag(IDENT)) {
+            if (assign.lhs.getTag() != JCTree.IDENT) {
                 log.error(t.pos(), "annotation.value.must.be.name.value");
                 continue;
             }
@@ -224,14 +222,14 @@
                                        (((JCFieldAccess) tree).selected).type);
         }
         if ((expected.tsym.flags() & Flags.ANNOTATION) != 0) {
-            if (!tree.hasTag(ANNOTATION)) {
+            if (tree.getTag() != JCTree.ANNOTATION) {
                 log.error(tree.pos(), "annotation.value.must.be.annotation");
                 expected = syms.errorType;
             }
             return enterAnnotation((JCAnnotation)tree, expected, env);
         }
         if (expected.tag == TypeTags.ARRAY) { // should really be isArray()
-            if (!tree.hasTag(NEWARRAY)) {
+            if (tree.getTag() != JCTree.NEWARRAY) {
                 tree = make.at(tree.pos).
                     NewArray(null, List.<JCExpression>nil(), List.of(tree));
             }
diff -u -r javac/comp/Attr.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Attr.java
--- javac/comp/Attr.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Attr.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,7 +42,6 @@
 import com.sun.tools.javac.code.Symbol.*;
 import com.sun.tools.javac.tree.JCTree.*;
 import com.sun.tools.javac.code.Type.*;
-import com.sun.tools.javac.comp.Check.CheckContext;
 
 import com.sun.source.tree.IdentifierTree;
 import com.sun.source.tree.MemberSelectTree;
@@ -50,13 +49,8 @@
 import com.sun.source.util.SimpleTreeVisitor;
 
 import static com.sun.tools.javac.code.Flags.*;
-import static com.sun.tools.javac.code.Flags.ANNOTATION;
-import static com.sun.tools.javac.code.Flags.BLOCK;
 import static com.sun.tools.javac.code.Kinds.*;
-import static com.sun.tools.javac.code.Kinds.ERRONEOUS;
 import static com.sun.tools.javac.code.TypeTags.*;
-import static com.sun.tools.javac.code.TypeTags.WILDCARD;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
 
 /** This is the main context-dependent analysis phase in GJC. It
  *  encompasses name resolution, type checking and constant folding as
@@ -133,11 +127,6 @@
         findDiamonds = options.get("findDiamond") != null &&
                  source.allowDiamond();
         useBeforeDeclarationWarning = options.isSet("useBeforeDeclarationWarning");
-
-        statInfo = new ResultInfo(NIL, Type.noType);
-        varInfo = new ResultInfo(VAR, Type.noType);
-        unknownExprInfo = new ResultInfo(VAL, Type.noType);
-        unknownTypeInfo = new ResultInfo(TYP, Type.noType);
     }
 
     /** Switch: relax some constraints for retrofit mode.
@@ -205,15 +194,16 @@
      *  @param tree     The tree whose kind and type is checked
      *  @param owntype  The computed type of the tree
      *  @param ownkind  The computed kind of the tree
-     *  @param resultInfo  The expected result of the tree
+     *  @param pkind    The expected kind (or: protokind) of the tree
+     *  @param pt       The expected type (or: prototype) of the tree
      */
-    Type check(JCTree tree, Type owntype, int ownkind, ResultInfo resultInfo) {
-        if (owntype.tag != ERROR && resultInfo.pt.tag != METHOD && resultInfo.pt.tag != FORALL) {
-            if ((ownkind & ~resultInfo.pkind) == 0) {
-                owntype = resultInfo.check(tree, owntype);
+    Type check(JCTree tree, Type owntype, int ownkind, int pkind, Type pt) {
+        if (owntype.tag != ERROR && pt.tag != METHOD && pt.tag != FORALL) {
+            if ((ownkind & ~pkind) == 0) {
+                owntype = chk.checkType(tree.pos(), owntype, pt, errKey);
             } else {
                 log.error(tree.pos(), "unexpected.type",
-                          kindNames(resultInfo.pkind),
+                          kindNames(pkind),
                           kindName(ownkind));
                 owntype = types.createErrorType(owntype);
             }
@@ -255,7 +245,7 @@
             ((v.flags() & HASINIT) != 0
              ||
              !((base == null ||
-               (base.hasTag(IDENT) && TreeInfo.name(base) == names._this)) &&
+               (base.getTag() == JCTree.IDENT && TreeInfo.name(base) == names._this)) &&
                isAssignableAsBlankFinal(v, env)))) {
             if (v.isResourceVariable()) { //TWR resource
                 log.error(pos, "try.resource.may.not.be.assigned", v);
@@ -273,7 +263,7 @@
      *  @param tree    The candidate tree.
      */
     boolean isStaticReference(JCTree tree) {
-        if (tree.hasTag(SELECT)) {
+        if (tree.getTag() == JCTree.SELECT) {
             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
             if (lsym == null || lsym.kind != TYP) {
                 return false;
@@ -338,16 +328,7 @@
     public Type attribType(JCTree node, TypeSymbol sym) {
         Env<AttrContext> env = enter.typeEnvs.get(sym);
         Env<AttrContext> localEnv = env.dup(node, env.info.dup());
-        return attribTree(node, localEnv, unknownTypeInfo);
-    }
-
-    public Type attribImportQualifier(JCImport tree, Env<AttrContext> env) {
-        // Attribute qualifying package or class.
-        JCFieldAccess s = (JCFieldAccess)tree.qualid;
-        return attribTree(s.selected,
-                       env,
-                       new ResultInfo(tree.staticImport ? TYP : (TYP | PCK),
-                       Type.noType));
+        return attribTree(node, localEnv, Kinds.TYP, Type.noType);
     }
 
     public Env<AttrContext> attribExprToTree(JCTree expr, Env<AttrContext> env, JCTree tree) {
@@ -400,38 +381,6 @@
         }
     }
 
-    class ResultInfo {
-        int pkind;
-        Type pt;
-        CheckContext checkContext;
-
-        ResultInfo(int pkind, Type pt) {
-            this(pkind, pt, chk.basicHandler);
-        }
-
-        protected ResultInfo(int pkind, Type pt, CheckContext checkContext) {
-            this.pkind = pkind;
-            this.pt = pt;
-            this.checkContext = checkContext;
-        }
-
-        protected Type check(DiagnosticPosition pos, Type found) {
-            return chk.checkType(pos, found, pt, checkContext);
-        }
-    }
-
-    private final ResultInfo statInfo;
-    private final ResultInfo varInfo;
-    private final ResultInfo unknownExprInfo;
-    private final ResultInfo unknownTypeInfo;
-
-    Type pt() {
-        return resultInfo.pt;
-    }
-
-    int pkind() {
-        return resultInfo.pkind;
-    }
 
 /* ************************************************************************
  * Visitor methods
@@ -441,9 +390,17 @@
      */
     Env<AttrContext> env;
 
-    /** Visitor argument: the currently expected attribution result.
+    /** Visitor argument: the currently expected proto-kind.
+     */
+    int pkind;
+
+    /** Visitor argument: the currently expected proto-type.
      */
-    ResultInfo resultInfo;
+    Type pt;
+
+    /** Visitor argument: the error key to be generated when a type error occurs
+     */
+    String errKey;
 
     /** Visitor result: the computed type.
      */
@@ -454,14 +411,23 @@
      *
      *  @param tree    The tree to be visited.
      *  @param env     The environment visitor argument.
-     *  @param resultInfo   The result info visitor argument.
+     *  @param pkind   The protokind visitor argument.
+     *  @param pt      The prototype visitor argument.
      */
-    private Type attribTree(JCTree tree, Env<AttrContext> env, ResultInfo resultInfo) {
+    Type attribTree(JCTree tree, Env<AttrContext> env, int pkind, Type pt) {
+        return attribTree(tree, env, pkind, pt, "incompatible.types");
+    }
+
+    Type attribTree(JCTree tree, Env<AttrContext> env, int pkind, Type pt, String errKey) {
         Env<AttrContext> prevEnv = this.env;
-        ResultInfo prevResult = this.resultInfo;
+        int prevPkind = this.pkind;
+        Type prevPt = this.pt;
+        String prevErrKey = this.errKey;
         try {
             this.env = env;
-            this.resultInfo = resultInfo;
+            this.pkind = pkind;
+            this.pt = pt;
+            this.errKey = errKey;
             tree.accept(this);
             if (tree == breakTree)
                 throw new BreakAttr(env);
@@ -471,21 +437,27 @@
             return chk.completionError(tree.pos(), ex);
         } finally {
             this.env = prevEnv;
-            this.resultInfo = prevResult;
+            this.pkind = prevPkind;
+            this.pt = prevPt;
+            this.errKey = prevErrKey;
         }
     }
 
     /** Derived visitor method: attribute an expression tree.
      */
     public Type attribExpr(JCTree tree, Env<AttrContext> env, Type pt) {
-        return attribTree(tree, env, new ResultInfo(VAL, pt.tag != ERROR ? pt : Type.noType));
+        return attribTree(tree, env, VAL, pt.tag != ERROR ? pt : Type.noType);
+    }
+
+    public Type attribExpr(JCTree tree, Env<AttrContext> env, Type pt, String key) {
+        return attribTree(tree, env, VAL, pt.tag != ERROR ? pt : Type.noType, key);
     }
 
     /** Derived visitor method: attribute an expression tree with
      *  no constraints on the computed type.
      */
     Type attribExpr(JCTree tree, Env<AttrContext> env) {
-        return attribTree(tree, env, unknownExprInfo);
+        return attribTree(tree, env, VAL, Type.noType);
     }
 
     /** Derived visitor method: attribute a type tree.
@@ -498,14 +470,14 @@
     /** Derived visitor method: attribute a type tree.
      */
     Type attribType(JCTree tree, Env<AttrContext> env, Type pt) {
-        Type result = attribTree(tree, env, new ResultInfo(TYP, pt));
+        Type result = attribTree(tree, env, TYP, pt);
         return result;
     }
 
     /** Derived visitor method: attribute a statement or definition tree.
      */
     public Type attribStat(JCTree tree, Env<AttrContext> env) {
-        return attribTree(tree, env, statInfo);
+        return attribTree(tree, env, NIL, Type.noType);
     }
 
     /** Attribute a list of expressions, returning a list of types.
@@ -530,7 +502,7 @@
         ListBuffer<Type> argtypes = new ListBuffer<Type>();
         for (List<JCExpression> l = trees; l.nonEmpty(); l = l.tail)
             argtypes.append(chk.checkNonVoid(
-                l.head.pos(), types.upperBound(attribExpr(l.head, env, Infer.anyPoly))));
+                l.head.pos(), types.upperBound(attribTree(l.head, env, VAL, Infer.anyPoly))));
         return argtypes.toList();
     }
 
@@ -622,15 +594,7 @@
             lintEnv = lintEnv.next;
 
         // Having found the enclosing lint value, we can initialize the lint value for this class
-        // ... but ...
-        // There's a problem with evaluating annotations in the right order, such that
-        // env.info.enclVar.attributes_field might not yet have been evaluated, and so might be
-        // null. In that case, calling augment will throw an NPE. To avoid this, for now we
-        // revert to the jdk 6 behavior and ignore the (unevaluated) attributes.
-        if (env.info.enclVar.attributes_field == null)
-            env.info.lint = lintEnv.info.lint;
-        else
-            env.info.lint = lintEnv.info.lint.augment(env.info.enclVar.attributes_field, env.info.enclVar.flags());
+        env.info.lint = lintEnv.info.lint.augment(env.info.enclVar.attributes_field, env.info.enclVar.flags());
 
         Lint prevLint = chk.setLint(env.info.lint);
         JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);
@@ -721,7 +685,7 @@
             // disable implicit outer instance from being passed.
             // (This would be an illegal access to "this before super").
             if (env.info.isSelfCall &&
-                env.tree.hasTag(NEWCLASS) &&
+                env.tree.getTag() == JCTree.NEWCLASS &&
                 ((JCNewClass) env.tree).encl == null)
             {
                 c.flags_field |= NOOUTERTHIS;
@@ -891,7 +855,7 @@
             chk.checkDeprecatedAnnotation(tree.pos(), v);
 
             if (tree.init != null) {
-                if ((v.flags_field & FINAL) != 0 && !tree.init.hasTag(NEWCLASS)) {
+                if ((v.flags_field & FINAL) != 0 && tree.init.getTag() != JCTree.NEWCLASS) {
                     // In this case, `v' is final.  Ensure that it's initializer is
                     // evaluated.
                     v.getConstValue(); // ensure initializer is evaluated
@@ -999,8 +963,8 @@
     public void visitLabelled(JCLabeledStatement tree) {
         // Check that label is not used in an enclosing statement
         Env<AttrContext> env1 = env;
-        while (env1 != null && !env1.tree.hasTag(CLASSDEF)) {
-            if (env1.tree.hasTag(LABELLED) &&
+        while (env1 != null && env1.tree.getTag() != JCTree.CLASSDEF) {
+            if (env1.tree.getTag() == JCTree.LABELLED &&
                 ((JCLabeledStatement) env1.tree).label == tree.label) {
                 log.error(tree.pos(), "label.already.in.use",
                           tree.label);
@@ -1080,14 +1044,14 @@
         private static void addVars(List<JCStatement> stats, Scope switchScope) {
             for (;stats.nonEmpty(); stats = stats.tail) {
                 JCTree stat = stats.head;
-                if (stat.hasTag(VARDEF))
+                if (stat.getTag() == JCTree.VARDEF)
                     switchScope.enter(((JCVariableDecl) stat).sym);
             }
         }
     // where
     /** Return the selected enumeration constant symbol, or null. */
     private Symbol enumConstant(JCTree tree, Type enumType) {
-        if (!tree.hasTag(IDENT)) {
+        if (tree.getTag() != JCTree.IDENT) {
             log.error(tree.pos(), "enum.label.must.be.unqualified.enum");
             return syms.errSymbol;
         }
@@ -1122,16 +1086,9 @@
             localEnv;
         // Attribute resource declarations
         for (JCTree resource : tree.resources) {
-            CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
-                @Override
-                public void report(DiagnosticPosition pos, Type found, Type req, JCDiagnostic details) {
-                    chk.basicHandler.report(pos, found, req, diags.fragment("try.not.applicable.to.type", found));
-                }
-            };
-            ResultInfo twrResult = new ResultInfo(VAL, syms.autoCloseableType, twrContext);
-            if (resource.hasTag(VARDEF)) {
+            if (resource.getTag() == JCTree.VARDEF) {
                 attribStat(resource, tryEnv);
-                twrResult.check(resource, resource.type);
+                chk.checkType(resource, resource.type, syms.autoCloseableType, "try.not.applicable.to.type");
 
                 //check that resource type cannot throw InterruptedException
                 checkAutoCloseable(resource.pos(), localEnv, resource.type);
@@ -1139,7 +1096,7 @@
                 VarSymbol var = (VarSymbol)TreeInfo.symbolFor(resource);
                 var.setData(ElementKind.RESOURCE_VARIABLE);
             } else {
-                attribTree(resource, tryEnv, twrResult);
+                attribExpr(resource, tryEnv, syms.autoCloseableType, "try.not.applicable.to.type");
             }
         }
         // Attribute body
@@ -1176,8 +1133,7 @@
 
     void checkAutoCloseable(DiagnosticPosition pos, Env<AttrContext> env, Type resource) {
         if (!resource.isErroneous() &&
-            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&
-            !types.isSameType(resource, syms.autoCloseableType)) { // Don't emit warning for AutoCloseable itself
+                types.asSuper(resource, syms.autoCloseableType.tsym) != null) {
             Symbol close = syms.noSymbol;
             boolean prevDeferDiags = log.deferDiagnostics;
             Queue<JCDiagnostic> prevDeferredDiags = log.deferredDiagnostics;
@@ -1211,7 +1167,7 @@
         result = check(tree,
                        capture(condType(tree.pos(), tree.cond.type,
                                         tree.truepart.type, tree.falsepart.type)),
-                       VAL, resultInfo);
+                       VAL, pkind, pt);
     }
     //where
         /** Compute the type of a conditional expression, after
@@ -1348,7 +1304,7 @@
          *  @param env     The environment current at the jump statement.
          */
         private JCTree findJumpTarget(DiagnosticPosition pos,
-                                    JCTree.Tag tag,
+                                    int tag,
                                     Name label,
                                     Env<AttrContext> env) {
             // Search environments outwards from the point of jump.
@@ -1356,15 +1312,15 @@
             LOOP:
             while (env1 != null) {
                 switch (env1.tree.getTag()) {
-                case LABELLED:
+                case JCTree.LABELLED:
                     JCLabeledStatement labelled = (JCLabeledStatement)env1.tree;
                     if (label == labelled.label) {
                         // If jump is a continue, check that target is a loop.
-                        if (tag == CONTINUE) {
-                            if (!labelled.body.hasTag(DOLOOP) &&
-                                !labelled.body.hasTag(WHILELOOP) &&
-                                !labelled.body.hasTag(FORLOOP) &&
-                                !labelled.body.hasTag(FOREACHLOOP))
+                        if (tag == JCTree.CONTINUE) {
+                            if (labelled.body.getTag() != JCTree.DOLOOP &&
+                                labelled.body.getTag() != JCTree.WHILELOOP &&
+                                labelled.body.getTag() != JCTree.FORLOOP &&
+                                labelled.body.getTag() != JCTree.FOREACHLOOP)
                                 log.error(pos, "not.loop.label", label);
                             // Found labelled statement target, now go inwards
                             // to next non-labelled tree.
@@ -1374,17 +1330,17 @@
                         }
                     }
                     break;
-                case DOLOOP:
-                case WHILELOOP:
-                case FORLOOP:
-                case FOREACHLOOP:
+                case JCTree.DOLOOP:
+                case JCTree.WHILELOOP:
+                case JCTree.FORLOOP:
+                case JCTree.FOREACHLOOP:
                     if (label == null) return env1.tree;
                     break;
-                case SWITCH:
-                    if (label == null && tag == BREAK) return env1.tree;
+                case JCTree.SWITCH:
+                    if (label == null && tag == JCTree.BREAK) return env1.tree;
                     break;
-                case METHODDEF:
-                case CLASSDEF:
+                case JCTree.METHODDEF:
+                case JCTree.CLASSDEF:
                     break LOOP;
                 default:
                 }
@@ -1392,7 +1348,7 @@
             }
             if (label != null)
                 log.error(pos, "undef.label", label);
-            else if (tag == CONTINUE)
+            else if (tag == JCTree.CONTINUE)
                 log.error(pos, "cont.outside.loop");
             else
                 log.error(pos, "break.outside.switch.loop");
@@ -1488,7 +1444,7 @@
                     if (encl.tag == CLASS) {
                         // we are calling a nested class
 
-                        if (tree.meth.hasTag(SELECT)) {
+                        if (tree.meth.getTag() == JCTree.SELECT) {
                             JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
 
                             // We are seeing a prefixed call, of the form
@@ -1504,7 +1460,7 @@
                             rs.resolveImplicitThis(tree.meth.pos(),
                                                    localEnv, site, true);
                         }
-                    } else if (tree.meth.hasTag(SELECT)) {
+                    } else if (tree.meth.getTag() == JCTree.SELECT) {
                         log.error(tree.meth.pos(), "illegal.qual.not.icls",
                                   site.tsym);
                     }
@@ -1530,8 +1486,8 @@
                     // ...and check that it is legal in the current context.
                     // (this will also set the tree's type)
                     Type mpt = newMethTemplate(argtypes, typeargtypes);
-                    checkId(tree.meth, site, sym, localEnv, new ResultInfo(MTH, mpt),
-                            tree.varargsElement != null);
+                    checkId(tree.meth, site, sym, localEnv, MTH,
+                            mpt, tree.varargsElement != null);
                 }
                 // Otherwise, `site' is an error type and we do nothing
             }
@@ -1548,6 +1504,8 @@
             Type mpt = newMethTemplate(argtypes, typeargtypes);
             localEnv.info.varArgs = false;
             Type mtype = attribExpr(tree.meth, localEnv, mpt);
+            if (localEnv.info.varArgs)
+                Assert.check(mtype.isErroneous() || tree.varargsElement != null);
 
             // Compute the result type.
             Type restype = mtype.getReturnType();
@@ -1556,7 +1514,7 @@
 
             // as a special case, array.clone() has a result that is
             // the same as static type of the array being cloned
-            if (tree.meth.hasTag(SELECT) &&
+            if (tree.meth.getTag() == JCTree.SELECT &&
                 allowCovariantReturns &&
                 methName == names.clone &&
                 types.isArray(((JCFieldAccess) tree.meth).selected.type))
@@ -1565,7 +1523,7 @@
             // as a special case, x.getClass() has type Class<? extends |X|>
             if (allowGenerics &&
                 methName == names.getClass && tree.args.isEmpty()) {
-                Type qualifier = (tree.meth.hasTag(SELECT))
+                Type qualifier = (tree.meth.getTag() == JCTree.SELECT)
                     ? ((JCFieldAccess) tree.meth).selected.type
                     : env.enclClass.sym.type;
                 restype = new
@@ -1580,10 +1538,7 @@
 
             // Check that value of resulting type is admissible in the
             // current context.  Also, capture the return type
-            result = check(tree, capture(restype), VAL, resultInfo);
-
-            if (localEnv.info.varArgs)
-                Assert.check(result.isErroneous() || tree.varargsElement != null);
+            result = check(tree, capture(restype), VAL, pkind, pt);
         }
         chk.validate(tree.typeargs, localEnv);
     }
@@ -1597,7 +1552,7 @@
             JCMethodDecl enclMethod = env.enclMethod;
             if (enclMethod != null && enclMethod.name == names.init) {
                 JCBlock body = enclMethod.body;
-                if (body.stats.head.hasTag(EXEC) &&
+                if (body.stats.head.getTag() == JCTree.EXEC &&
                     ((JCExpressionStatement) body.stats.head).expr == tree)
                     return true;
             }
@@ -1628,7 +1583,7 @@
         // complete class name to be fully qualified
         JCExpression clazz = tree.clazz; // Class field following new
         JCExpression clazzid =          // Identifier in class field
-            (clazz.hasTag(TYPEAPPLY))
+            (clazz.getTag() == JCTree.TYPEAPPLY)
             ? ((JCTypeApply) clazz).clazz
             : clazz;
 
@@ -1647,7 +1602,7 @@
                                              attribExpr(tree.encl, env));
             clazzid1 = make.at(clazz.pos).Select(make.Type(encltype),
                                                  ((JCIdent) clazzid).name);
-            if (clazz.hasTag(TYPEAPPLY))
+            if (clazz.getTag() == JCTree.TYPEAPPLY)
                 clazz = make.at(tree.pos).
                     TypeApply(clazzid1,
                               ((JCTypeApply) clazz).arguments);
@@ -1658,6 +1613,7 @@
         // Attribute clazz expression and store
         // symbol + type back into the attributed tree.
         Type clazztype = attribType(clazz, env);
+        Pair<Scope,Scope> mapping = getSyntheticScopeMapping(clazztype);
         clazztype = chk.checkDiamond(tree, clazztype);
         chk.validate(clazz, localEnv);
         if (tree.encl != null) {
@@ -1684,7 +1640,7 @@
         List<Type> typeargtypes = attribTypes(tree.typeargs, localEnv);
 
         if (TreeInfo.isDiamond(tree) && !clazztype.isErroneous()) {
-            clazztype = attribDiamond(localEnv, tree, clazztype, argtypes, typeargtypes);
+            clazztype = attribDiamond(localEnv, tree, clazztype, mapping, argtypes, typeargtypes);
             clazz.type = clazztype;
         } else if (allowDiamondFinder &&
                 tree.def == null &&
@@ -1701,6 +1657,7 @@
                 inferred = attribDiamond(localEnv,
                         tree,
                         clazztype,
+                        mapping,
                         argtypes,
                         typeargtypes);
             }
@@ -1711,7 +1668,7 @@
             if (inferred != null &&
                     !inferred.isErroneous() &&
                     inferred.tag == CLASS &&
-                    types.isAssignable(inferred, pt().tag == NONE ? clazztype : pt(), Warner.noWarnings)) {
+                    types.isAssignable(inferred, pt.tag == NONE ? clazztype : pt, Warner.noWarnings)) {
                 String key = types.isSameType(clazztype, inferred) ?
                     "diamond.redundant.args" :
                     "diamond.redundant.args.1";
@@ -1724,7 +1681,7 @@
             // Enums may not be instantiated except implicitly
             if (allowEnums &&
                 (clazztype.tsym.flags_field&Flags.ENUM) != 0 &&
-                (!env.tree.hasTag(VARDEF) ||
+                (env.tree.getTag() != JCTree.VARDEF ||
                  (((JCVariableDecl) env.tree).mods.flags&Flags.ENUM) == 0 ||
                  ((JCVariableDecl) env.tree).init != tree))
                 log.error(tree.pos(), "enum.cant.be.instantiated");
@@ -1761,7 +1718,7 @@
                     tree.pos(), rsEnv, clazztype, argtypes, typeargtypes);
                 tree.constructorType = tree.constructor.type.isErroneous() ?
                     syms.errType :
-                    checkConstructor(clazztype,
+                    checkMethod(clazztype,
                         tree.constructor,
                         rsEnv,
                         tree.args,
@@ -1836,7 +1793,7 @@
                     tree.constructorType =  syms.errType;
                 }
                 else {
-                    tree.constructorType = checkConstructor(clazztype,
+                    tree.constructorType = checkMethod(clazztype,
                             tree.constructor,
                             localEnv,
                             tree.args,
@@ -1849,17 +1806,19 @@
             if (tree.constructor != null && tree.constructor.kind == MTH)
                 owntype = clazztype;
         }
-        result = check(tree, owntype, VAL, resultInfo);
+        result = check(tree, owntype, VAL, pkind, pt);
         chk.validate(tree.typeargs, localEnv);
     }
 
     Type attribDiamond(Env<AttrContext> env,
-                        final JCNewClass tree,
+                        JCNewClass tree,
                         Type clazztype,
+                        Pair<Scope, Scope> mapping,
                         List<Type> argtypes,
                         List<Type> typeargtypes) {
         if (clazztype.isErroneous() ||
-                clazztype.isInterface()) {
+                clazztype.isInterface() ||
+                mapping == erroneousMapping) {
             //if the type of the instance creation expression is erroneous,
             //or if it's an interface, or if something prevented us to form a valid
             //mapping, return the (possibly erroneous) type unchanged
@@ -1868,22 +1827,27 @@
 
         //dup attribution environment and augment the set of inference variables
         Env<AttrContext> localEnv = env.dup(tree);
-
-        ClassType site = new ClassType(clazztype.getEnclosingType(),
-                    clazztype.tsym.type.getTypeArguments(),
-                    clazztype.tsym);
+        localEnv.info.tvars = clazztype.tsym.type.getTypeArguments();
 
         //if the type of the instance creation expression is a class type
         //apply method resolution inference (JLS 15.12.2.7). The return type
         //of the resolved constructor will be a partially instantiated type
-        Symbol constructor = rs.resolveDiamond(tree.pos(),
+        ((ClassSymbol) clazztype.tsym).members_field = mapping.snd;
+        Symbol constructor;
+        try {
+            constructor = rs.resolveDiamond(tree.pos(),
                     localEnv,
-                    site,
+                    clazztype.tsym.type,
                     argtypes,
                     typeargtypes);
-
+        } finally {
+            ((ClassSymbol) clazztype.tsym).members_field = mapping.fst;
+        }
         if (constructor.kind == MTH) {
-            clazztype = checkMethod(site,
+            ClassType ct = new ClassType(clazztype.getEnclosingType(),
+                    clazztype.tsym.type.getTypeArguments(),
+                    clazztype.tsym);
+            clazztype = checkMethod(ct,
                     constructor,
                     localEnv,
                     tree.args,
@@ -1894,19 +1858,63 @@
             clazztype = syms.errType;
         }
 
-        if (clazztype.tag == FORALL && !resultInfo.pt.isErroneous()) {
+        if (clazztype.tag == FORALL && !pt.isErroneous()) {
+            //if the resolved constructor's return type has some uninferred
+            //type-variables, infer them using the expected type and declared
+            //bounds (JLS 15.12.2.8).
             try {
-                clazztype = resultInfo.checkContext.rawInstantiatePoly((ForAll)clazztype, pt(), Warner.noWarnings);
+                clazztype = infer.instantiateExpr((ForAll) clazztype,
+                        pt.tag == NONE ? syms.objectType : pt,
+                        Warner.noWarnings);
             } catch (Infer.InferenceException ex) {
                 //an error occurred while inferring uninstantiated type-variables
-                resultInfo.checkContext.report(tree.clazz.pos(), clazztype, resultInfo.pt,
-                        diags.fragment("cant.apply.diamond.1", diags.fragment("diamond", clazztype.tsym), ex.diagnostic));
-            }
+                log.error(tree.clazz.pos(),
+                        "cant.apply.diamond.1",
+                        diags.fragment("diamond", clazztype.tsym),
+                        ex.diagnostic);
+            }
+        }
+        return chk.checkClassType(tree.clazz.pos(),
+                clazztype,
+                true);
+    }
+
+    /** Creates a synthetic scope containing fake generic constructors.
+     *  Assuming that the original scope contains a constructor of the kind:
+     *  Foo(X x, Y y), where X,Y are class type-variables declared in Foo,
+     *  the synthetic scope is added a generic constructor of the kind:
+     *  <X,Y>Foo<X,Y>(X x, Y y). This is crucial in order to enable diamond
+     *  inference. The inferred return type of the synthetic constructor IS
+     *  the inferred type for the diamond operator.
+     */
+    private Pair<Scope, Scope> getSyntheticScopeMapping(Type ctype) {
+        if (ctype.tag != CLASS) {
+            return erroneousMapping;
+        }
+
+        Pair<Scope, Scope> mapping =
+                new Pair<Scope, Scope>(ctype.tsym.members(), new Scope(ctype.tsym));
+
+        //for each constructor in the original scope, create a synthetic constructor
+        //whose return type is the type of the class in which the constructor is
+        //declared, and insert it into the new scope.
+        for (Scope.Entry e = mapping.fst.lookup(names.init);
+                e.scope != null;
+                e = e.next()) {
+            Type synthRestype = new ClassType(ctype.getEnclosingType(),
+                        ctype.tsym.type.getTypeArguments(),
+                        ctype.tsym);
+            MethodSymbol synhConstr = new MethodSymbol(e.sym.flags(),
+                    names.init,
+                    types.createMethodTypeWithReturn(e.sym.type, synthRestype),
+                    e.sym.owner);
+            mapping.snd.enter(synhConstr);
         }
-
-        return chk.checkClassType(tree.clazz.pos(), clazztype, true);
+        return mapping;
     }
 
+    private final Pair<Scope,Scope> erroneousMapping = new Pair<Scope,Scope>(null, null);
+
     /** Make an attributed null check tree.
      */
     public JCExpression makeNullCheck(JCExpression arg) {
@@ -1914,7 +1922,7 @@
         Name name = TreeInfo.name(arg);
         if (name == names._this || name == names._super) return arg;
 
-        JCTree.Tag optag = NULLCHK;
+        int optag = JCTree.NULLCHK;
         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
         tree.operator = syms.nullcheck;
         tree.type = arg.type;
@@ -1935,14 +1943,14 @@
         } else {
             // we are seeing an untyped aggregate { ... }
             // this is allowed only if the prototype is an array
-            if (pt().tag == ARRAY) {
-                elemtype = types.elemtype(pt());
+            if (pt.tag == ARRAY) {
+                elemtype = types.elemtype(pt);
             } else {
-                if (pt().tag != ERROR) {
+                if (pt.tag != ERROR) {
                     log.error(tree.pos(), "illegal.initializer.for.type",
-                              pt());
+                              pt);
                 }
-                elemtype = types.createErrorType(pt());
+                elemtype = types.createErrorType(pt);
             }
         }
         if (tree.elems != null) {
@@ -1951,41 +1959,31 @@
         }
         if (!types.isReifiable(elemtype))
             log.error(tree.pos(), "generic.array.creation");
-        result = check(tree, owntype, VAL, resultInfo);
-    }
-
-    @Override
-    public void visitLambda(JCLambda that) {
-        throw new UnsupportedOperationException("Lambda expression not supported yet");
-    }
-
-    @Override
-    public void visitReference(JCMemberReference that) {
-        throw new UnsupportedOperationException("Member references not supported yet");
+        result = check(tree, owntype, VAL, pkind, pt);
     }
 
     public void visitParens(JCParens tree) {
-        Type owntype = attribTree(tree.expr, env, resultInfo);
-        result = check(tree, owntype, pkind(), resultInfo);
+        Type owntype = attribTree(tree.expr, env, pkind, pt);
+        result = check(tree, owntype, pkind, pkind, pt);
         Symbol sym = TreeInfo.symbol(tree);
         if (sym != null && (sym.kind&(TYP|PCK)) != 0)
             log.error(tree.pos(), "illegal.start.of.type");
     }
 
     public void visitAssign(JCAssign tree) {
-        Type owntype = attribTree(tree.lhs, env.dup(tree), varInfo);
+        Type owntype = attribTree(tree.lhs, env.dup(tree), VAR, Type.noType);
         Type capturedType = capture(owntype);
         attribExpr(tree.rhs, env, owntype);
-        result = check(tree, capturedType, VAL, resultInfo);
+        result = check(tree, capturedType, VAL, pkind, pt);
     }
 
     public void visitAssignop(JCAssignOp tree) {
         // Attribute arguments.
-        Type owntype = attribTree(tree.lhs, env, varInfo);
+        Type owntype = attribTree(tree.lhs, env, VAR, Type.noType);
         Type operand = attribExpr(tree.rhs, env);
         // Find operator.
         Symbol operator = tree.operator = rs.resolveBinaryOperator(
-            tree.pos(), tree.getTag().noAssignOp(), env,
+            tree.pos(), tree.getTag() - JCTree.ASGOffset, env,
             owntype, operand);
 
         if (operator.kind == MTH &&
@@ -1993,7 +1991,7 @@
                 !operand.isErroneous()) {
             chk.checkOperator(tree.pos(),
                               (OperatorSymbol)operator,
-                              tree.getTag().noAssignOp(),
+                              tree.getTag() - JCTree.ASGOffset,
                               owntype,
                               operand);
             chk.checkDivZero(tree.rhs.pos(), operator, operand);
@@ -2001,13 +1999,13 @@
                               operator.type.getReturnType(),
                               owntype);
         }
-        result = check(tree, owntype, VAL, resultInfo);
+        result = check(tree, owntype, VAL, pkind, pt);
     }
 
     public void visitUnary(JCUnary tree) {
         // Attribute arguments.
-        Type argtype = (tree.getTag().isIncOrDecUnaryOp())
-            ? attribTree(tree.arg, env, varInfo)
+        Type argtype = (JCTree.PREINC <= tree.getTag() && tree.getTag() <= JCTree.POSTDEC)
+            ? attribTree(tree.arg, env, VAR, Type.noType)
             : chk.checkNonVoid(tree.arg.pos(), attribExpr(tree.arg, env));
 
         // Find operator.
@@ -2017,7 +2015,7 @@
         Type owntype = types.createErrorType(tree.type);
         if (operator.kind == MTH &&
                 !argtype.isErroneous()) {
-            owntype = (tree.getTag().isIncOrDecUnaryOp())
+            owntype = (JCTree.PREINC <= tree.getTag() && tree.getTag() <= JCTree.POSTDEC)
                 ? tree.arg.type
                 : operator.type.getReturnType();
             int opc = ((OperatorSymbol)operator).opcode;
@@ -2039,7 +2037,7 @@
                 }
             }
         }
-        result = check(tree, owntype, VAL, resultInfo);
+        result = check(tree, owntype, VAL, pkind, pt);
     }
 
     public void visitBinary(JCBinary tree) {
@@ -2092,7 +2090,7 @@
 
             chk.checkDivZero(tree.rhs.pos(), operator, right);
         }
-        result = check(tree, owntype, VAL, resultInfo);
+        result = check(tree, owntype, VAL, pkind, pt);
     }
 
     public void visitTypeCast(JCTypeCast tree) {
@@ -2105,8 +2103,7 @@
         Type owntype = chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
         if (exprtype.constValue() != null)
             owntype = cfolder.coerce(exprtype, owntype);
-        result = check(tree, capture(owntype), VAL, resultInfo);
-        chk.checkRedundantCast(localEnv, tree);
+        result = check(tree, capture(owntype), VAL, pkind, pt);
     }
 
     public void visitTypeTest(JCInstanceOf tree) {
@@ -2116,7 +2113,7 @@
             tree.clazz.pos(), attribType(tree.clazz, env));
         chk.validate(tree.clazz, env, false);
         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
-        result = check(tree, syms.booleanType, VAL, resultInfo);
+        result = check(tree, syms.booleanType, VAL, pkind, pt);
     }
 
     public void visitIndexed(JCArrayAccess tree) {
@@ -2127,8 +2124,8 @@
             owntype = types.elemtype(atype);
         else if (atype.tag != ERROR)
             log.error(tree.pos(), "array.req.but.found", atype);
-        if ((pkind() & VAR) == 0) owntype = capture(owntype);
-        result = check(tree, owntype, VAR, resultInfo);
+        if ((pkind & VAR) == 0) owntype = capture(owntype);
+        result = check(tree, owntype, VAR, pkind, pt);
     }
 
     public void visitIdent(JCIdent tree) {
@@ -2136,16 +2133,16 @@
         boolean varArgs = false;
 
         // Find symbol
-        if (pt().tag == METHOD || pt().tag == FORALL) {
+        if (pt.tag == METHOD || pt.tag == FORALL) {
             // If we are looking for a method, the prototype `pt' will be a
             // method type with the type of the call's arguments as parameters.
             env.info.varArgs = false;
-            sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
+            sym = rs.resolveMethod(tree.pos(), env, tree.name, pt.getParameterTypes(), pt.getTypeArguments());
             varArgs = env.info.varArgs;
         } else if (tree.sym != null && tree.sym.kind != VAR) {
             sym = tree.sym;
         } else {
-            sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());
+            sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind);
         }
         tree.sym = sym;
 
@@ -2192,7 +2189,7 @@
 
             // If we are expecting a variable (as opposed to a value), check
             // that the variable is assignable in the current environment.
-            if (pkind() == VAR)
+            if (pkind == VAR)
                 checkAssignable(tree.pos(), v, null, env);
         }
 
@@ -2213,7 +2210,7 @@
             while (env1.outer != null && !rs.isAccessible(env, env1.enclClass.sym.type, sym))
                 env1 = env1.outer;
         }
-        result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo, varArgs);
+        result = checkId(tree, env1.enclClass.sym.type, sym, env, pkind, pt, varArgs);
     }
 
     public void visitSelect(JCFieldAccess tree) {
@@ -2224,14 +2221,14 @@
         {
             skind = TYP;
         } else {
-            if ((pkind() & PCK) != 0) skind = skind | PCK;
-            if ((pkind() & TYP) != 0) skind = skind | TYP | PCK;
-            if ((pkind() & (VAL | MTH)) != 0) skind = skind | VAL | TYP;
+            if ((pkind & PCK) != 0) skind = skind | PCK;
+            if ((pkind & TYP) != 0) skind = skind | TYP | PCK;
+            if ((pkind & (VAL | MTH)) != 0) skind = skind | VAL | TYP;
         }
 
         // Attribute the qualifier expression, and determine its symbol (if any).
-        Type site = attribTree(tree.selected, env, new ResultInfo(skind, Infer.anyPoly));
-        if ((pkind() & (PCK | TYP)) == 0)
+        Type site = attribTree(tree.selected, env, skind, Infer.anyPoly);
+        if ((pkind & (PCK | TYP)) == 0)
             site = capture(site); // Capture field access
 
         // don't allow T.class T[].class, etc
@@ -2266,10 +2263,10 @@
 
         // Determine the symbol represented by the selection.
         env.info.varArgs = false;
-        Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
-        if (sym.exists() && !isType(sym) && (pkind() & (PCK | TYP)) != 0) {
+        Symbol sym = selectSym(tree, sitesym, site, env, pt, pkind);
+        if (sym.exists() && !isType(sym) && (pkind & (PCK | TYP)) != 0) {
             site = capture(site);
-            sym = selectSym(tree, sitesym, site, env, resultInfo);
+            sym = selectSym(tree, sitesym, site, env, pt, pkind);
         }
         boolean varArgs = env.info.varArgs;
         tree.sym = sym;
@@ -2289,7 +2286,7 @@
 
             // If we are expecting a variable (as opposed to a value), check
             // that the variable is assignable in the current environment.
-            if (pkind() == VAR)
+            if (pkind == VAR)
                 checkAssignable(tree.pos(), v, tree.selected, env);
         }
 
@@ -2305,8 +2302,8 @@
 
         // Disallow selecting a type from an expression
         if (isType(sym) && (sitesym==null || (sitesym.kind&(TYP|PCK)) == 0)) {
-            tree.type = check(tree.selected, pt(),
-                              sitesym == null ? VAL : sitesym.kind, new ResultInfo(TYP|PCK, pt()));
+            tree.type = check(tree.selected, pt,
+                              sitesym == null ? VAL : sitesym.kind, TYP|PCK, pt);
         }
 
         if (isType(sitesym)) {
@@ -2346,7 +2343,7 @@
         }
 
         env.info.selectSuper = selectSuperPrev;
-        result = checkId(tree, site, sym, env, resultInfo, varArgs);
+        result = checkId(tree, site, sym, env, pkind, pt, varArgs);
         env.info.tvars = List.nil();
     }
     //where
@@ -2355,25 +2352,34 @@
          *  @param tree   The select tree.
          *  @param site   The type of the selected expression,
          *  @param env    The current environment.
-         *  @param resultInfo The current result.
+         *  @param pt     The current prototype.
+         *  @param pkind  The expected kind(s) of the Select expression.
          */
         private Symbol selectSym(JCFieldAccess tree,
+                                     Type site,
+                                     Env<AttrContext> env,
+                                     Type pt,
+                                     int pkind) {
+            return selectSym(tree, site.tsym, site, env, pt, pkind);
+        }
+        private Symbol selectSym(JCFieldAccess tree,
                                  Symbol location,
                                  Type site,
                                  Env<AttrContext> env,
-                                 ResultInfo resultInfo) {
+                                 Type pt,
+                                 int pkind) {
             DiagnosticPosition pos = tree.pos();
             Name name = tree.name;
             switch (site.tag) {
             case PACKAGE:
                 return rs.access(
-                    rs.findIdentInPackage(env, site.tsym, name, resultInfo.pkind),
+                    rs.findIdentInPackage(env, site.tsym, name, pkind),
                     pos, location, site, name, true);
             case ARRAY:
             case CLASS:
-                if (resultInfo.pt.tag == METHOD || resultInfo.pt.tag == FORALL) {
+                if (pt.tag == METHOD || pt.tag == FORALL) {
                     return rs.resolveQualifiedMethod(
-                        pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
+                        pos, env, location, site, name, pt.getParameterTypes(), pt.getTypeArguments());
                 } else if (name == names._this || name == names._super) {
                     return rs.resolveSelf(pos, env, site.tsym, name);
                 } else if (name == names._class) {
@@ -2388,8 +2394,8 @@
                         STATIC | PUBLIC | FINAL, names._class, t, site.tsym);
                 } else {
                     // We are seeing a plain identifier as selector.
-                    Symbol sym = rs.findIdentInType(env, site, name, resultInfo.pkind);
-                    if ((resultInfo.pkind & ERRONEOUS) == 0)
+                    Symbol sym = rs.findIdentInType(env, site, name, pkind);
+                    if ((pkind & ERRONEOUS) == 0)
                         sym = rs.access(sym, pos, location, site, name, true);
                     return sym;
                 }
@@ -2403,7 +2409,7 @@
                 // other words, we are seeing this illegal program:
                 // class B<T> extends A<T.foo> {}
                 Symbol sym = (site.getUpperBound() != null)
-                    ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
+                    ? selectSym(tree, location, capture(site.getUpperBound()), env, pt, pkind)
                     : null;
                 if (sym == null) {
                     log.error(pos, "type.var.cant.be.deref");
@@ -2457,15 +2463,17 @@
          *                    expression, otherwise the type of the current class.
          *  @param sym        The symbol representing the identifier.
          *  @param env        The current environment.
-         *  @param resultInfo    The expected result
+         *  @param pkind      The set of expected kinds.
+         *  @param pt         The expected type.
          */
         Type checkId(JCTree tree,
                      Type site,
                      Symbol sym,
                      Env<AttrContext> env,
-                     ResultInfo resultInfo,
+                     int pkind,
+                     Type pt,
                      boolean useVarargs) {
-            if (resultInfo.pt.isErroneous()) return types.createErrorType(site);
+            if (pt.isErroneous()) return types.createErrorType(site);
             Type owntype; // The computed type of this identifier occurrence.
             switch (sym.kind) {
             case TYP:
@@ -2510,7 +2518,7 @@
                 // which is being assigned to, issue an unchecked warning if
                 // its type changes under erasure.
                 if (allowGenerics &&
-                    resultInfo.pkind == VAR &&
+                    pkind == VAR &&
                     v.owner.kind == TYP &&
                     (v.flags() & STATIC) == 0 &&
                     (site.tag == CLASS || site.tag == TYPEVAR)) {
@@ -2545,14 +2553,14 @@
                 if (v.getConstValue() != null && isStaticReference(tree))
                     owntype = owntype.constType(v.getConstValue());
 
-                if (resultInfo.pkind == VAL) {
+                if (pkind == VAL) {
                     owntype = capture(owntype); // capture "names as expressions"
                 }
                 break;
             case MTH: {
                 JCMethodInvocation app = (JCMethodInvocation)env.tree;
                 owntype = checkMethod(site, sym, env, app.args,
-                                      resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments(),
+                                      pt.getParameterTypes(), pt.getTypeArguments(),
                                       env.info.varArgs);
                 break;
             }
@@ -2575,7 +2583,7 @@
 
             // Test (3): if symbol is a variable, check that its type and
             // kind are compatible with the prototype and protokind.
-            return check(tree, owntype, sym.kind, resultInfo);
+            return check(tree, owntype, sym.kind, pkind, pt);
         }
 
         /** Check that variable is initialized and evaluate the variable's
@@ -2605,7 +2613,7 @@
                 canOwnInitializer(env.info.scope.owner) &&
                 v.owner == env.info.scope.owner.enclClass() &&
                 ((v.flags() & STATIC) != 0) == Resolve.isStatic(env) &&
-                (!env.tree.hasTag(ASSIGN) ||
+                (env.tree.getTag() != JCTree.ASSIGN ||
                  TreeInfo.skipParens(((JCAssign) env.tree).lhs) != tree)) {
                 String suffix = (env.info.enclVar == v) ?
                                 "self.ref" : "forward.ref";
@@ -2688,7 +2696,7 @@
     Warner noteWarner = new Warner();
 
     /**
-     * Check that method arguments conform to its instantiation.
+     * Check that method arguments conform to its instantation.
      **/
     public Type checkMethod(Type site,
                             Symbol sym,
@@ -2725,44 +2733,112 @@
                                       true,
                                       useVarargs,
                                       noteWarner);
-
-        boolean unchecked = noteWarner.hasNonSilentLint(LintCategory.UNCHECKED);
+        boolean warned = noteWarner.hasNonSilentLint(LintCategory.UNCHECKED);
 
         // If this fails, something went wrong; we should not have
         // found the identifier in the first place.
         if (owntype == null) {
-            if (!pt().isErroneous())
+            if (!pt.isErroneous())
                 log.error(env.tree.pos(),
-                           "internal.error.cant.instantiate",
-                           sym, site,
-                          Type.toString(pt().getParameterTypes()));
+                          "internal.error.cant.instantiate",
+                          sym, site,
+                          Type.toString(pt.getParameterTypes()));
             owntype = types.createErrorType(site);
-            return types.createErrorType(site);
-        } else if (owntype.getReturnType().tag == FORALL && !unchecked) {
-            return owntype;
         } else {
-            return chk.checkMethod(owntype, sym, env, argtrees, argtypes, useVarargs, unchecked);
+            // System.out.println("call   : " + env.tree);
+            // System.out.println("method : " + owntype);
+            // System.out.println("actuals: " + argtypes);
+            List<Type> formals = owntype.getParameterTypes();
+            Type last = useVarargs ? formals.last() : null;
+            if (sym.name==names.init &&
+                sym.owner == syms.enumSym)
+                formals = formals.tail.tail;
+            List<JCExpression> args = argtrees;
+            while (formals.head != last) {
+                JCTree arg = args.head;
+                Warner warn = chk.convertWarner(arg.pos(), arg.type, formals.head);
+                assertConvertible(arg, arg.type, formals.head, warn);
+                warned |= warn.hasNonSilentLint(LintCategory.UNCHECKED);
+                args = args.tail;
+                formals = formals.tail;
+            }
+            if (useVarargs) {
+                Type varArg = types.elemtype(last);
+                while (args.tail != null) {
+                    JCTree arg = args.head;
+                    Warner warn = chk.convertWarner(arg.pos(), arg.type, varArg);
+                    assertConvertible(arg, arg.type, varArg, warn);
+                    warned |= warn.hasNonSilentLint(LintCategory.UNCHECKED);
+                    args = args.tail;
+                }
+            } else if ((sym.flags() & VARARGS) != 0 && allowVarargs) {
+                // non-varargs call to varargs method
+                Type varParam = owntype.getParameterTypes().last();
+                Type lastArg = argtypes.last();
+                if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &&
+                    !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
+                    log.warning(argtrees.last().pos(), "inexact.non-varargs.call",
+                                types.elemtype(varParam),
+                                varParam);
+            }
+
+            if (warned && sym.type.tag == FORALL) {
+                chk.warnUnchecked(env.tree.pos(),
+                                  "unchecked.meth.invocation.applied",
+                                  kindName(sym),
+                                  sym.name,
+                                  rs.methodArguments(sym.type.getParameterTypes()),
+                                  rs.methodArguments(argtypes),
+                                  kindName(sym.location()),
+                                  sym.location());
+                owntype = new MethodType(owntype.getParameterTypes(),
+                                         types.erasure(owntype.getReturnType()),
+                                         types.erasure(owntype.getThrownTypes()),
+                                         syms.methodClass);
+            }
+            if (useVarargs) {
+                JCTree tree = env.tree;
+                Type argtype = owntype.getParameterTypes().last();
+                if (owntype.getReturnType().tag != FORALL || warned) {
+                    chk.checkVararg(env.tree.pos(), owntype.getParameterTypes(), sym);
+                }
+                Type elemtype = types.elemtype(argtype);
+                switch (tree.getTag()) {
+                case JCTree.APPLY:
+                    ((JCMethodInvocation) tree).varargsElement = elemtype;
+                    break;
+                case JCTree.NEWCLASS:
+                    ((JCNewClass) tree).varargsElement = elemtype;
+                    break;
+                default:
+                    throw new AssertionError(""+tree);
+                }
+            }
         }
+        return owntype;
     }
 
-    /**
-     * Check that constructor arguments conform to its instantiation.
-     **/
-    public Type checkConstructor(Type site,
-                            Symbol sym,
-                            Env<AttrContext> env,
-                            final List<JCExpression> argtrees,
-                            List<Type> argtypes,
-                            List<Type> typeargtypes,
-                            boolean useVarargs) {
-        Type owntype = checkMethod(site, sym, env, argtrees, argtypes, typeargtypes, useVarargs);
-        chk.checkType(env.tree.pos(), owntype.getReturnType(), syms.voidType);
-        return owntype;
+    private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
+        if (types.isConvertible(actual, formal, warn))
+            return;
+
+        if (formal.isCompound()
+            && types.isSubtype(actual, types.supertype(formal))
+            && types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
+            return;
+
+        if (false) {
+            // TODO: make assertConvertible work
+            chk.typeError(tree.pos(), diags.fragment("incompatible.types"), actual, formal);
+            throw new AssertionError("Tree: " + tree
+                                     + " actual:" + actual
+                                     + " formal: " + formal);
+        }
     }
 
     public void visitLiteral(JCLiteral tree) {
         result = check(
-            tree, litType(tree.typetag).constType(tree.value), VAL, resultInfo);
+            tree, litType(tree.typetag).constType(tree.value), VAL, pkind, pt);
     }
     //where
     /** Return the type of a literal with given type tag.
@@ -2772,13 +2848,13 @@
     }
 
     public void visitTypeIdent(JCPrimitiveTypeTree tree) {
-        result = check(tree, syms.typeOfTag[tree.typetag], TYP, resultInfo);
+        result = check(tree, syms.typeOfTag[tree.typetag], TYP, pkind, pt);
     }
 
     public void visitTypeArray(JCArrayTypeTree tree) {
         Type etype = attribType(tree.elemtype, env);
         Type type = new ArrayType(etype, syms.arrayClass);
-        result = check(tree, type, TYP, resultInfo);
+        result = check(tree, type, TYP, pkind, pt);
     }
 
     /** Visitor method for parameterized types.
@@ -2796,10 +2872,8 @@
 
         if (clazztype.tag == CLASS) {
             List<Type> formals = clazztype.tsym.type.getTypeArguments();
-            if (actuals.isEmpty()) //diamond
-                actuals = formals;
 
-            if (actuals.length() == formals.length()) {
+            if (actuals.length() == formals.length() || actuals.length() == 0) {
                 List<Type> a = actuals;
                 List<Type> f = formals;
                 while (a.nonEmpty()) {
@@ -2812,9 +2886,9 @@
                 if (clazzOuter.tag == CLASS) {
                     Type site;
                     JCExpression clazz = TreeInfo.typeIn(tree.clazz);
-                    if (clazz.hasTag(IDENT)) {
+                    if (clazz.getTag() == JCTree.IDENT) {
                         site = env.enclClass.sym.type;
-                    } else if (clazz.hasTag(SELECT)) {
+                    } else if (clazz.getTag() == JCTree.SELECT) {
                         site = ((JCFieldAccess) clazz).selected.type;
                     } else throw new AssertionError(""+tree);
                     if (clazzOuter.tag == CLASS && site != clazzOuter) {
@@ -2836,7 +2910,7 @@
                 owntype = types.createErrorType(tree.type);
             }
         }
-        result = check(tree, owntype, TYP, resultInfo);
+        result = check(tree, owntype, TYP, pkind, pt);
     }
 
     public void visitTypeUnion(JCTypeUnion tree) {
@@ -2873,7 +2947,7 @@
                 all_multicatchTypes.append(ctype);
             }
         }
-        Type t = check(tree, types.lub(multicatchTypes.toList()), TYP, resultInfo);
+        Type t = check(tree, types.lub(multicatchTypes.toList()), TYP, pkind, pt);
         if (t.tag == CLASS) {
             List<Type> alternatives =
                 ((all_multicatchTypes == null) ? multicatchTypes : all_multicatchTypes).toList();
@@ -2959,18 +3033,18 @@
         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),
                                               tree.kind.kind,
                                               syms.boundClass),
-                       TYP, resultInfo);
+                       TYP, pkind, pt);
     }
 
     public void visitAnnotation(JCAnnotation tree) {
-        log.error(tree.pos(), "annotation.not.valid.for.type", pt());
+        log.error(tree.pos(), "annotation.not.valid.for.type", pt);
         result = tree.type = syms.errType;
     }
 
     public void visitErroneous(JCErroneous tree) {
         if (tree.errs != null)
             for (JCTree err : tree.errs)
-                attribTree(err, env, new ResultInfo(ERR, pt()));
+                attribTree(err, env, ERR, pt);
         result = tree.type = syms.errType;
     }
 
@@ -2984,7 +3058,7 @@
      * Attribute an env for either a top level tree or class declaration.
      */
     public void attrib(Env<AttrContext> env) {
-        if (env.tree.hasTag(TOPLEVEL))
+        if (env.tree.getTag() == JCTree.TOPLEVEL)
             attribTopLevel(env);
         else
             attribClass(env.tree.pos(), env.enclClass.sym);
@@ -3161,7 +3235,7 @@
                 ((c.flags() & STATIC) == 0 || c.name == names.empty) &&
                 (TreeInfo.flags(l.head) & (STATIC | INTERFACE)) != 0) {
                 Symbol sym = null;
-                if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
+                if (l.head.getTag() == JCTree.VARDEF) sym = ((JCVariableDecl) l.head).sym;
                 if (sym == null ||
                     sym.kind != VAR ||
                     ((VarSymbol) sym).getConstValue() == null)
@@ -3314,13 +3388,6 @@
         }
 
         @Override
-        public void visitAssignop(JCAssignOp that) {
-            if (that.operator == null)
-                that.operator = new OperatorSymbol(names.empty, syms.unknownType, -1, syms.noSymbol);
-            super.visitAssignop(that);
-        }
-
-        @Override
         public void visitBinary(JCBinary that) {
             if (that.operator == null)
                 that.operator = new OperatorSymbol(names.empty, syms.unknownType, -1, syms.noSymbol);
diff -u -r javac/comp/Check.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Check.java
--- javac/comp/Check.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Check.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,13 +42,10 @@
 import com.sun.tools.javac.code.Symbol.*;
 
 import static com.sun.tools.javac.code.Flags.*;
-import static com.sun.tools.javac.code.Flags.ANNOTATION;
-import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
 import static com.sun.tools.javac.code.Kinds.*;
 import static com.sun.tools.javac.code.TypeTags.*;
-import static com.sun.tools.javac.code.TypeTags.WILDCARD;
 
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /** Type checking helper class for the attribution phase.
  *
@@ -63,7 +60,6 @@
 
     private final Names names;
     private final Log log;
-    private final Resolve rs;
     private final Symtab syms;
     private final Enter enter;
     private final Infer infer;
@@ -96,7 +92,6 @@
 
         names = Names.instance(context);
         log = Log.instance(context);
-        rs = Resolve.instance(context);
         syms = Symtab.instance(context);
         enter = Enter.instance(context);
         infer = Infer.instance(context);
@@ -108,11 +103,10 @@
 
         Source source = Source.instance(context);
         allowGenerics = source.allowGenerics();
-        allowVarargs = source.allowVarargs();
         allowAnnotations = source.allowAnnotations();
         allowCovariantReturns = source.allowCovariantReturns();
         allowSimplifiedVarargs = source.allowSimplifiedVarargs();
-        complexInference = options.isSet("complexinference");
+        complexInference = options.isSet(COMPLEXINFERENCE);
         skipAnnotations = options.isSet("skipAnnotations");
         warnOnSyntheticConflicts = options.isSet("warnOnSyntheticConflicts");
         suppressAbortOnBadClassFile = options.isSet("suppressAbortOnBadClassFile");
@@ -140,10 +134,6 @@
      */
     boolean allowGenerics;
 
-    /** Switch: varargs enabled?
-     */
-    boolean allowVarargs;
-
     /** Switch: annotations enabled?
      */
     boolean allowAnnotations;
@@ -269,6 +259,23 @@
         else return syms.errType;
     }
 
+    /** Report a type error.
+     *  @param pos        Position to be used for error reporting.
+     *  @param problem    A string describing the error.
+     *  @param found      The type that was found.
+     *  @param req        The type that was required.
+     */
+    Type typeError(DiagnosticPosition pos, Object problem, Type found, Type req) {
+        log.error(pos, "prob.found.req",
+                  problem, found, req);
+        return types.createErrorType(found);
+    }
+
+    Type typeError(DiagnosticPosition pos, String problem, Type found, Type req, Object explanation) {
+        log.error(pos, "prob.found.req.1", problem, found, req, explanation);
+        return types.createErrorType(found);
+    }
+
     /** Report an error that wrong type tag was found.
      *  @param pos        Position to be used for error reporting.
      *  @param required   An internationalized string describing the type tag
@@ -299,16 +306,7 @@
      */
     void duplicateError(DiagnosticPosition pos, Symbol sym) {
         if (!sym.type.isErroneous()) {
-            Symbol location = sym.location();
-            if (location.kind == MTH &&
-                    ((MethodSymbol)location).isStaticOrInstanceInit()) {
-                log.error(pos, "already.defined.in.clinit", kindName(sym), sym,
-                        kindName(sym.location()), kindName(sym.location().enclClass()),
-                        sym.location().enclClass());
-            } else {
-                log.error(pos, "already.defined", kindName(sym), sym,
-                        kindName(sym.location()), sym.location());
-            }
+            log.error(pos, "already.defined", sym, sym.location());
         }
     }
 
@@ -413,86 +411,6 @@
  * Type Checking
  **************************************************************************/
 
-    /**
-     * A check context is an object that can be used to perform compatibility
-     * checks - depending on the check context, meaning of 'compatibility' might
-     * vary significantly.
-     */
-    interface CheckContext {
-        /**
-         * Is type 'found' compatible with type 'req' in given context
-         */
-        boolean compatible(Type found, Type req, Warner warn);
-        /**
-         * Instantiate a ForAll type against a given target type 'req' in given context
-         */
-        Type rawInstantiatePoly(ForAll found, Type req, Warner warn);
-        /**
-         * Report a check error
-         */
-        void report(DiagnosticPosition pos, Type found, Type req, JCDiagnostic details);
-        /**
-         * Obtain a warner for this check context
-         */
-        public Warner checkWarner(DiagnosticPosition pos, Type found, Type req);
-    }
-
-    /**
-     * This class represent a check context that is nested within another check
-     * context - useful to check sub-expressions. The default behavior simply
-     * redirects all method calls to the enclosing check context leveraging
-     * the forwarding pattern.
-     */
-    static class NestedCheckContext implements CheckContext {
-        CheckContext enclosingContext;
-
-        NestedCheckContext(CheckContext enclosingContext) {
-            this.enclosingContext = enclosingContext;
-        }
-
-        public boolean compatible(Type found, Type req, Warner warn) {
-            return enclosingContext.compatible(found, req, warn);
-        }
-
-        public Type rawInstantiatePoly(ForAll found, Type req, Warner warn) {
-            return enclosingContext.rawInstantiatePoly(found, req, warn);
-        }
-
-        public void report(DiagnosticPosition pos, Type found, Type req, JCDiagnostic details) {
-            enclosingContext.report(pos, found, req, details);
-        }
-
-        public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
-            return enclosingContext.checkWarner(pos, found, req);
-        }
-    }
-
-    /**
-     * Check context to be used when evaluating assignment/return statements
-     */
-    CheckContext basicHandler = new CheckContext() {
-        public void report(DiagnosticPosition pos, Type found, Type req, JCDiagnostic details) {
-            if (details == null) {
-                log.error(pos, "prob.found.req", found, req);
-            } else {
-                log.error(pos, "prob.found.req.1", details);
-            }
-        }
-        public boolean compatible(Type found, Type req, Warner warn) {
-            return types.isAssignable(found, req, warn);
-        }
-
-        public Type rawInstantiatePoly(ForAll found, Type req, Warner warn) {
-            if (req.tag == NONE)
-                req = found.qtype.tag <= VOID ? found.qtype : syms.objectType;
-            return infer.instantiateExpr(found, req, warn);
-        }
-
-        public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
-            return convertWarner(pos, found, req);
-        }
-    };
-
     /** Check that a given type is assignable to a given proto-type.
      *  If it is, return the type, otherwise return errType.
      *  @param pos        Position to be used for error reporting.
@@ -500,54 +418,64 @@
      *  @param req        The type that was required.
      */
     Type checkType(DiagnosticPosition pos, Type found, Type req) {
-        return checkType(pos, found, req, basicHandler);
+        return checkType(pos, found, req, "incompatible.types");
     }
 
-    Type checkType(final DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
+    Type checkType(DiagnosticPosition pos, Type found, Type req, String errKey) {
         if (req.tag == ERROR)
             return req;
-        if (found.tag == FORALL) {
-            ForAll fa = (ForAll)found;
-            Type owntype = instantiatePoly(pos, checkContext, fa, req, checkContext.checkWarner(pos, found, req));
-            return checkType(pos, owntype, req, checkContext);
-        }
+        if (found.tag == FORALL)
+            return instantiatePoly(pos, (ForAll)found, req, convertWarner(pos, found, req));
         if (req.tag == NONE)
             return found;
-        if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
+        if (types.isAssignable(found, req, convertWarner(pos, found, req)))
             return found;
-        } else {
-            if (found.tag <= DOUBLE && req.tag <= DOUBLE) {
-                checkContext.report(pos, found, req, diags.fragment("possible.loss.of.precision"));
-                return types.createErrorType(found);
-            }
-            checkContext.report(pos, found, req, null);
+        if (found.tag <= DOUBLE && req.tag <= DOUBLE)
+            return typeError(pos, diags.fragment("possible.loss.of.precision"), found, req);
+        if (found.isSuperBound()) {
+            log.error(pos, "assignment.from.super-bound", found);
+            return types.createErrorType(found);
+        }
+        if (req.isExtendsBound()) {
+            log.error(pos, "assignment.to.extends-bound", req);
             return types.createErrorType(found);
         }
+        return typeError(pos, diags.fragment(errKey), found, req);
     }
 
     /** Instantiate polymorphic type to some prototype, unless
      *  prototype is `anyPoly' in which case polymorphic type
      *  is returned unchanged.
      */
-    Type instantiatePoly(DiagnosticPosition pos, CheckContext checkContext, ForAll t, Type pt, Warner warn) throws Infer.NoInstanceException {
-        try {
-            return checkContext.rawInstantiatePoly(t, pt, warn);
-        } catch (final Infer.NoInstanceException ex) {
-            JCDiagnostic d = ex.getDiagnostic();
-            if (d != null) {
+    Type instantiatePoly(DiagnosticPosition pos, ForAll t, Type pt, Warner warn) throws Infer.NoInstanceException {
+        if (pt == Infer.anyPoly && complexInference) {
+            return t;
+        } else if (pt == Infer.anyPoly || pt.tag == NONE) {
+            Type newpt = t.qtype.tag <= VOID ? t.qtype : syms.objectType;
+            return instantiatePoly(pos, t, newpt, warn);
+        } else if (pt.tag == ERROR) {
+            return pt;
+        } else {
+            try {
+                return infer.instantiateExpr(t, pt, warn);
+            } catch (Infer.NoInstanceException ex) {
                 if (ex.isAmbiguous) {
-                    d = diags.fragment("undetermined.type", t, d);
-                }
-            }
-            checkContext.report(pos, t, pt, d);
-            return types.createErrorType(pt);
-        } catch (Infer.InvalidInstanceException ex) {
-            JCDiagnostic d = ex.getDiagnostic();
-            if (d != null) {
-                d = diags.fragment("invalid.inferred.types", t.tvars, d);
+                    JCDiagnostic d = ex.getDiagnostic();
+                    log.error(pos,
+                              "undetermined.type" + (d!=null ? ".1" : ""),
+                              t, d);
+                    return types.createErrorType(pt);
+                } else {
+                    JCDiagnostic d = ex.getDiagnostic();
+                    return typeError(pos,
+                                     diags.fragment("incompatible.types" + (d!=null ? ".1" : ""), d),
+                                     t, pt);
+                }
+            } catch (Infer.InvalidInstanceException ex) {
+                JCDiagnostic d = ex.getDiagnostic();
+                log.error(pos, "invalid.inferred.types", t.tvars, d);
+                return types.createErrorType(pt);
             }
-            checkContext.report(pos, t, pt, d);
-            return types.createErrorType(pt);
         }
     }
 
@@ -558,48 +486,17 @@
      *  @param req        The target type of the cast.
      */
     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
-        return checkCastable(pos, found, req, basicHandler);
-    }
-    Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
         if (found.tag == FORALL) {
-            instantiatePoly(pos, basicHandler, (ForAll) found, req, castWarner(pos, found, req));
+            instantiatePoly(pos, (ForAll) found, req, castWarner(pos, found, req));
             return req;
         } else if (types.isCastable(found, req, castWarner(pos, found, req))) {
             return req;
         } else {
-            checkContext.report(pos, found, req, diags.fragment("inconvertible.types", found, req));
-            return types.createErrorType(found);
+            return typeError(pos,
+                             diags.fragment("inconvertible.types"),
+                             found, req);
         }
     }
-
-    /** Check for redundant casts (i.e. where source type is a subtype of target type)
-     * The problem should only be reported for non-292 cast
-     */
-    public void checkRedundantCast(Env<AttrContext> env, JCTypeCast tree) {
-        if (!tree.type.isErroneous() &&
-            (env.info.lint == null || env.info.lint.isEnabled(Lint.LintCategory.CAST))
-            && types.isSameType(tree.expr.type, tree.clazz.type)
-            && !is292targetTypeCast(tree)) {
-            log.warning(Lint.LintCategory.CAST,
-                    tree.pos(), "redundant.cast", tree.expr.type);
-        }
-    }
-    //where
-            private boolean is292targetTypeCast(JCTypeCast tree) {
-                boolean is292targetTypeCast = false;
-                JCExpression expr = TreeInfo.skipParens(tree.expr);
-                if (expr.hasTag(APPLY)) {
-                    JCMethodInvocation apply = (JCMethodInvocation)expr;
-                    Symbol sym = TreeInfo.symbol(apply.meth);
-                    is292targetTypeCast = sym != null &&
-                        sym.kind == MTH &&
-                        (sym.flags() & HYPOTHETICAL) != 0;
-                }
-                return is292targetTypeCast;
-            }
-
-
-
 //where
         /** Is type a type variable, or a (possibly multi-dimensional) array of
          *  type variables?
@@ -616,16 +513,16 @@
      *  @param a             The type that should be bounded by bs.
      *  @param bs            The bound.
      */
-    private boolean checkExtends(Type a, Type bound) {
+    private boolean checkExtends(Type a, TypeVar bs) {
          if (a.isUnbound()) {
              return true;
          } else if (a.tag != WILDCARD) {
              a = types.upperBound(a);
-             return types.isSubtype(a, bound);
+             return types.isSubtype(a, bs.bound);
          } else if (a.isExtendsBound()) {
-             return types.isCastable(bound, types.upperBound(a), Warner.noWarnings);
+             return types.isCastable(bs.getUpperBound(), types.upperBound(a), Warner.noWarnings);
          } else if (a.isSuperBound()) {
-             return !types.notSoftSubtype(types.lowerBound(a), bound);
+             return !types.notSoftSubtype(types.lowerBound(a), bs.getUpperBound());
          }
          return true;
      }
@@ -834,95 +731,22 @@
                     (s.flags() & (STATIC | FINAL)) != 0);
         }
 
-    Type checkMethod(Type owntype,
-                            Symbol sym,
-                            Env<AttrContext> env,
-                            final List<JCExpression> argtrees,
-                            List<Type> argtypes,
-                            boolean useVarargs,
-                            boolean unchecked) {
-        // System.out.println("call   : " + env.tree);
-        // System.out.println("method : " + owntype);
-        // System.out.println("actuals: " + argtypes);
-        List<Type> formals = owntype.getParameterTypes();
-        Type last = useVarargs ? formals.last() : null;
-        if (sym.name==names.init &&
-                sym.owner == syms.enumSym)
-                formals = formals.tail.tail;
-        List<JCExpression> args = argtrees;
-        while (formals.head != last) {
-            JCTree arg = args.head;
-            Warner warn = convertWarner(arg.pos(), arg.type, formals.head);
-            assertConvertible(arg, arg.type, formals.head, warn);
-            args = args.tail;
-            formals = formals.tail;
-        }
-        if (useVarargs) {
-            Type varArg = types.elemtype(last);
-            while (args.tail != null) {
-                JCTree arg = args.head;
-                Warner warn = convertWarner(arg.pos(), arg.type, varArg);
-                assertConvertible(arg, arg.type, varArg, warn);
-                args = args.tail;
-            }
-        } else if ((sym.flags() & VARARGS) != 0 && allowVarargs) {
-            // non-varargs call to varargs method
-            Type varParam = owntype.getParameterTypes().last();
-            Type lastArg = argtypes.last();
-            if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &&
-                    !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
-                log.warning(argtrees.last().pos(), "inexact.non-varargs.call",
-                        types.elemtype(varParam), varParam);
-        }
-        if (unchecked) {
-            warnUnchecked(env.tree.pos(),
-                    "unchecked.meth.invocation.applied",
-                    kindName(sym),
-                    sym.name,
-                    rs.methodArguments(sym.type.getParameterTypes()),
-                    rs.methodArguments(argtypes),
-                    kindName(sym.location()),
-                    sym.location());
-           owntype = new MethodType(owntype.getParameterTypes(),
-                   types.erasure(owntype.getReturnType()),
-                   types.erasure(owntype.getThrownTypes()),
-                   syms.methodClass);
-        }
-        if (useVarargs) {
-            JCTree tree = env.tree;
-            Type argtype = owntype.getParameterTypes().last();
-            if (!types.isReifiable(argtype) &&
-                    (!allowSimplifiedVarargs ||
-                    sym.attribute(syms.trustMeType.tsym) == null ||
-                    !isTrustMeAllowedOnMethod(sym))) {
-                warnUnchecked(env.tree.pos(),
-                                  "unchecked.generic.array.creation",
-                                  argtype);
-            }
-            Type elemtype = types.elemtype(argtype);
-            switch (tree.getTag()) {
-                case APPLY:
-                    ((JCMethodInvocation) tree).varargsElement = elemtype;
-                    break;
-                case NEWCLASS:
-                    ((JCNewClass) tree).varargsElement = elemtype;
-                    break;
-                default:
-                    throw new AssertionError(""+tree);
-            }
-         }
-         return owntype;
-    }
-    //where
-        private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
-            if (types.isConvertible(actual, formal, warn))
-                return;
-
-            if (formal.isCompound()
-                && types.isSubtype(actual, types.supertype(formal))
-                && types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
-                return;
+    /**
+     * Check that vararg method call is sound
+     * @param pos Position to be used for error reporting.
+     * @param argtypes Actual arguments supplied to vararg method.
+     */
+    void checkVararg(DiagnosticPosition pos, List<Type> argtypes, Symbol msym) {
+        Type argtype = argtypes.last();
+        if (!types.isReifiable(argtype) &&
+                (!allowSimplifiedVarargs ||
+                msym.attribute(syms.trustMeType.tsym) == null ||
+                !isTrustMeAllowedOnMethod(msym))) {
+            warnUnchecked(pos,
+                              "unchecked.generic.array.creation",
+                              argtype);
         }
+    }
 
     /**
      * Check that type 't' is a valid instantiation of a generic class
@@ -940,16 +764,18 @@
             List<Type> actuals = type.allparams();
             List<Type> args = type.getTypeArguments();
             List<Type> forms = type.tsym.type.getTypeArguments();
-            ListBuffer<Type> bounds_buf = new ListBuffer<Type>();
+            ListBuffer<Type> tvars_buf = new ListBuffer<Type>();
 
             // For matching pairs of actual argument types `a' and
             // formal type parameters with declared bound `b' ...
             while (args.nonEmpty() && forms.nonEmpty()) {
                 // exact type arguments needs to know their
                 // bounds (for upper and lower bound
-                // calculations).  So we create new bounds where
-                // type-parameters are replaced with actuals argument types.
-                bounds_buf.append(types.subst(forms.head.getUpperBound(), formals, actuals));
+                // calculations).  So we create new TypeVars with
+                // bounds substed with actuals.
+                tvars_buf.append(types.substBound(((TypeVar)forms.head),
+                                                  formals,
+                                                  actuals));
                 args = args.tail;
                 forms = forms.tail;
             }
@@ -966,30 +792,32 @@
             }
 
             args = type.getTypeArguments();
-            List<Type> bounds = bounds_buf.toList();
+            List<Type> tvars = tvars_buf.toList();
 
-            while (args.nonEmpty() && bounds.nonEmpty()) {
-                Type actual = args.head;
+            while (args.nonEmpty() && tvars.nonEmpty()) {
+                Type actual = types.subst(args.head,
+                    type.tsym.type.getTypeArguments(),
+                    tvars_buf.toList());
                 if (!isTypeArgErroneous(actual) &&
-                        !bounds.head.isErroneous() &&
-                        !checkExtends(actual, bounds.head)) {
+                        !tvars.head.getUpperBound().isErroneous() &&
+                        !checkExtends(actual, (TypeVar)tvars.head)) {
                     return args.head;
                 }
                 args = args.tail;
-                bounds = bounds.tail;
+                tvars = tvars.tail;
             }
 
             args = type.getTypeArguments();
-            bounds = bounds_buf.toList();
+            tvars = tvars_buf.toList();
 
             for (Type arg : types.capture(type).getTypeArguments()) {
                 if (arg.tag == TYPEVAR &&
                         arg.getUpperBound().isErroneous() &&
-                        !bounds.head.isErroneous() &&
+                        !tvars.head.getUpperBound().isErroneous() &&
                         !isTypeArgErroneous(args.head)) {
                     return args.head;
                 }
-                bounds = bounds.tail;
+                tvars = tvars.tail;
                 args = args.tail;
             }
 
@@ -1150,7 +978,7 @@
      *  <i>not</i> final.
      */
     private long implicitEnumFinalFlag(JCTree tree) {
-        if (!tree.hasTag(CLASSDEF)) return 0;
+        if (tree.getTag() != JCTree.CLASSDEF) return 0;
         class SpecialTreeVisitor extends JCTree.Visitor {
             boolean specialized;
             SpecialTreeVisitor() {
@@ -1262,7 +1090,7 @@
                 // not parameterized at all.
                 if (tree.type.getEnclosingType().isRaw())
                     log.error(tree.pos(), "improperly.formed.type.inner.raw.param");
-                if (tree.clazz.hasTag(SELECT))
+                if (tree.clazz.getTag() == JCTree.SELECT)
                     visitSelectInternal((JCFieldAccess)tree.clazz);
             }
         }
@@ -1332,17 +1160,12 @@
             if (lint.isEnabled(LintCategory.RAW) &&
                 tree.type.tag == CLASS &&
                 !TreeInfo.isDiamond(tree) &&
-                !withinAnonConstr(env) &&
+                !env.enclClass.name.isEmpty() &&  //anonymous or intersection
                 tree.type.isRaw()) {
                 log.warning(LintCategory.RAW,
                         tree.pos(), "raw.class.use", tree.type, tree.type.tsym.type);
             }
         }
-
-        boolean withinAnonConstr(Env<AttrContext> env) {
-            return env.enclClass.name.isEmpty() &&
-                    env.enclMethod != null && env.enclMethod.name == names.init;
-        }
     }
 
 /* *************************************************************************
@@ -2274,26 +2097,25 @@
      */
     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
          ClashFilter cf = new ClashFilter(site);
-        //for each method m1 that is overridden (directly or indirectly)
-        //by method 'sym' in 'site'...
-        for (Symbol m1 : types.membersClosure(site, false).getElementsByName(sym.name, cf)) {
-            if (!sym.overrides(m1, site.tsym, types, false)) continue;
-             //...check each method m2 that is a member of 'site'
-             for (Symbol m2 : types.membersClosure(site, false).getElementsByName(sym.name, cf)) {
-                if (m2 == m1) continue;
+         //for each method m1 that is a member of 'site'...
+         for (Symbol s1 : types.membersClosure(site, false).getElementsByName(sym.name, cf)) {
+            //...find another method m2 that is overridden (directly or indirectly)
+            //by method 'sym' in 'site'
+            for (Symbol s2 : types.membersClosure(site, false).getElementsByName(sym.name, cf)) {
+                if (s1 == s2 || !sym.overrides(s2, site.tsym, types, false)) continue;
                 //if (i) the signature of 'sym' is not a subsignature of m1 (seen as
                 //a member of 'site') and (ii) m1 has the same erasure as m2, issue an error
-                if (!types.isSubSignature(sym.type, types.memberType(site, m2), false) &&
-                        types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
+                if (!types.isSubSignature(sym.type, types.memberType(site, s1), false) &&
+                        types.hasSameArgs(s1.erasure(types), s2.erasure(types))) {
                     sym.flags_field |= CLASH;
-                    String key = m1 == sym ?
+                    String key = s2 == sym ?
                             "name.clash.same.erasure.no.override" :
                             "name.clash.same.erasure.no.override.1";
                     log.error(pos,
                             key,
                             sym, sym.location(),
-                            m2, m2.location(),
-                            m1, m1.location());
+                            s1, s1.location(),
+                            s2, s2.location());
                     return;
                 }
             }
@@ -2577,7 +2399,7 @@
 
         // count them off as they're annotated
         for (JCTree arg : a.args) {
-            if (!arg.hasTag(ASSIGN)) continue; // recovery
+            if (arg.getTag() != JCTree.ASSIGN) continue; // recovery
             JCAssign assign = (JCAssign) arg;
             Symbol m = TreeInfo.symbol(assign.lhs);
             if (m == null || m.type.isErroneous()) continue;
@@ -2606,12 +2428,12 @@
             a.args.tail == null)
             return;
 
-        if (!a.args.head.hasTag(ASSIGN)) return; // error recovery
+        if (a.args.head.getTag() != JCTree.ASSIGN) return; // error recovery
         JCAssign assign = (JCAssign) a.args.head;
         Symbol m = TreeInfo.symbol(assign.lhs);
         if (m.name != names.value) return;
         JCTree rhs = assign.rhs;
-        if (!rhs.hasTag(NEWARRAY)) return;
+        if (rhs.getTag() != JCTree.NEWARRAY) return;
         JCNewArray na = (JCNewArray) rhs;
         Set<Symbol> targets = new HashSet<Symbol>();
         for (JCTree elem : na.elems) {
@@ -2642,7 +2464,7 @@
                     warnDeprecated(pos, s);
                 }
             });
-        }
+        };
     }
 
     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
@@ -2652,7 +2474,7 @@
                     if (enableSunApiLintControl)
                       warnSunApi(pos, "sun.proprietary", s);
                     else
-                      log.mandatoryWarning(pos, "sun.proprietary", s);
+                      log.strictWarning(pos, "sun.proprietary", s);
                 }
             });
         }
@@ -2670,7 +2492,7 @@
         try {
             tree.sym.flags_field |= LOCKED;
             for (JCTree def : tree.defs) {
-                if (!def.hasTag(METHODDEF)) continue;
+                if (def.getTag() != JCTree.METHODDEF) continue;
                 JCMethodDecl meth = (JCMethodDecl)def;
                 checkAnnotationResType(meth.pos(), meth.restype.type);
             }
@@ -2778,7 +2600,7 @@
      */
     int checkOperator(DiagnosticPosition pos,
                        OperatorSymbol operator,
-                       JCTree.Tag tag,
+                       int tag,
                        Type left,
                        Type right) {
         if (operator.opcode == ByteCodes.error) {
@@ -2814,8 +2636,7 @@
      * Check for empty statements after if
      */
     void checkEmptyIf(JCIf tree) {
-        if (tree.thenpart.hasTag(SKIP) && tree.elsepart == null &&
-                lint.isEnabled(LintCategory.EMPTY))
+        if (tree.thenpart.getTag() == JCTree.SKIP && tree.elsepart == null && lint.isEnabled(LintCategory.EMPTY))
             log.warning(LintCategory.EMPTY, tree.thenpart.pos(), "empty.if");
     }
 
@@ -2919,7 +2740,7 @@
     }
         // where
         private boolean isCanonical(JCTree tree) {
-            while (tree.hasTag(SELECT)) {
+            while (tree.getTag() == JCTree.SELECT) {
                 JCFieldAccess s = (JCFieldAccess) tree;
                 if (s.sym.owner != TreeInfo.symbol(s.selected))
                     return false;
diff -u -r javac/comp/Enter.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Enter.java
--- javac/comp/Enter.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Enter.java	2011-06-27 15:21:47.000000000 -0500
@@ -34,7 +34,7 @@
 import com.sun.tools.javac.code.Symbol.*;
 import com.sun.tools.javac.code.Type.*;
 import com.sun.tools.javac.jvm.*;
-import com.sun.tools.javac.main.Option.PkgInfo;
+import com.sun.tools.javac.main.RecognizedOptions.PkgInfo;
 import com.sun.tools.javac.tree.*;
 import com.sun.tools.javac.tree.JCTree.*;
 import com.sun.tools.javac.util.*;
@@ -228,7 +228,7 @@
      *  only, and members go into the class member scope.
      */
     Scope enterScope(Env<AttrContext> env) {
-        return (env.tree.hasTag(JCTree.Tag.CLASSDEF))
+        return (env.tree.getTag() == JCTree.CLASSDEF)
             ? ((JCClassDecl) env.tree).sym.members_field
             : env.info.scope;
     }
diff -u -r javac/comp/Env.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Env.java
--- javac/comp/Env.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Env.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -116,9 +116,9 @@
 
     /** Return closest enclosing environment which points to a tree with given tag.
      */
-    public Env<A> enclosing(JCTree.Tag tag) {
+    public Env<A> enclosing(int tag) {
         Env<A> env1 = this;
-        while (env1 != null && !env1.tree.hasTag(tag)) env1 = env1.next;
+        while (env1 != null && env1.tree.getTag() != tag) env1 = env1.next;
         return env1;
     }
 
diff -u -r javac/comp/Flow.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Flow.java
--- javac/comp/Flow.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Flow.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,8 @@
 package com.sun.tools.javac.comp;
 
 import java.util.HashMap;
+import java.util.Map;
+import java.util.LinkedHashMap;
 
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.tree.*;
@@ -38,10 +40,8 @@
 import com.sun.tools.javac.tree.JCTree.*;
 
 import static com.sun.tools.javac.code.Flags.*;
-import static com.sun.tools.javac.code.Flags.BLOCK;
 import static com.sun.tools.javac.code.Kinds.*;
 import static com.sun.tools.javac.code.TypeTags.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
 
 /** This pass implements dataflow analysis for Java programs.
  *  Liveness analysis checks that every statement is reachable.
@@ -177,7 +177,7 @@
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
  */
-public class Flow {
+public class Flow extends TreeScanner {
     protected static final Context.Key<Flow> flowKey =
         new Context.Key<Flow>();
 
@@ -200,11 +200,6 @@
         return instance;
     }
 
-    public void analyzeTree(Env<AttrContext> env, TreeMaker make) {
-        new FlowAnalyzer().analyzeTree(env, make);
-        new AssignAnalyzer().analyzeTree(env, make);
-    }
-
     protected Flow(Context context) {
         context.put(flowKey, this);
         names = Names.instance(context);
@@ -219,1572 +214,1268 @@
         allowImprovedCatchAnalysis = source.allowImprovedCatchAnalysis();
     }
 
-    /**
-     * Base visitor class for all visitors implementing dataflow analysis logic.
-     * This class define the shared logic for handling jumps (break/continue statements).
-     */
-    static abstract class BaseAnalyzer<P extends BaseAnalyzer.PendingExit> extends TreeScanner {
-
-        enum JumpKind {
-            BREAK(JCTree.Tag.BREAK) {
-                @Override
-                JCTree getTarget(JCTree tree) {
-                    return ((JCBreak)tree).target;
-                }
-            },
-            CONTINUE(JCTree.Tag.CONTINUE) {
-                @Override
-                JCTree getTarget(JCTree tree) {
-                    return ((JCContinue)tree).target;
-                }
-            };
-
-            JCTree.Tag treeTag;
-
-            private JumpKind(Tag treeTag) {
-                this.treeTag = treeTag;
-            }
-
-            abstract JCTree getTarget(JCTree tree);
-        }
-
-        /** The currently pending exits that go from current inner blocks
-         *  to an enclosing block, in source order.
-         */
-        ListBuffer<P> pendingExits;
-
-        /** A pending exit.  These are the statements return, break, and
-         *  continue.  In addition, exception-throwing expressions or
-         *  statements are put here when not known to be caught.  This
-         *  will typically result in an error unless it is within a
-         *  try-finally whose finally block cannot complete normally.
-         */
-        abstract static class PendingExit {
-            JCTree tree;
-
-            PendingExit(JCTree tree) {
-                this.tree = tree;
-            }
-
-            abstract void resolveJump();
-        }
-
-        abstract void markDead();
+    /** A flag that indicates whether the last statement could
+     *  complete normally.
+     */
+    private boolean alive;
 
-        /** Record an outward transfer of control. */
-        void recordExit(JCTree tree, P pe) {
-            pendingExits.append(pe);
-            markDead();
-        }
+    /** The set of definitely assigned variables.
+     */
+    Bits inits;
 
-        /** Resolve all jumps of this statement. */
-        private boolean resolveJump(JCTree tree,
-                        ListBuffer<P> oldPendingExits,
-                        JumpKind jk) {
-            boolean resolved = false;
-            List<P> exits = pendingExits.toList();
-            pendingExits = oldPendingExits;
-            for (; exits.nonEmpty(); exits = exits.tail) {
-                P exit = exits.head;
-                if (exit.tree.hasTag(jk.treeTag) &&
-                        jk.getTarget(exit.tree) == tree) {
-                    exit.resolveJump();
-                    resolved = true;
-                } else {
-                    pendingExits.append(exit);
-                }
-            }
-            return resolved;
-        }
+    /** The set of definitely unassigned variables.
+     */
+    Bits uninits;
 
-        /** Resolve all breaks of this statement. */
-        boolean resolveContinues(JCTree tree) {
-            return resolveJump(tree, new ListBuffer<P>(), JumpKind.CONTINUE);
-        }
+    HashMap<Symbol, List<Type>> preciseRethrowTypes;
 
-        /** Resolve all continues of this statement. */
-        boolean resolveBreaks(JCTree tree, ListBuffer<P> oldPendingExits) {
-            return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
-        }
-    }
-
-    /**
-     * This pass implements the first two steps of the dataflow analysis:
-     * (i) liveness analysis checks that every statement is reachable and (ii)
-     *  exception analysis to ensure that every checked exception that is
-     *  thrown is declared or caught.
+    /** The set of variables that are definitely unassigned everywhere
+     *  in current try block. This variable is maintained lazily; it is
+     *  updated only when something gets removed from uninits,
+     *  typically by being assigned in reachable code.  To obtain the
+     *  correct set of variables which are definitely unassigned
+     *  anywhere in current try block, intersect uninitsTry and
+     *  uninits.
      */
-    class FlowAnalyzer extends BaseAnalyzer<FlowAnalyzer.FlowPendingExit> {
+    Bits uninitsTry;
 
-        /** A flag that indicates whether the last statement could
-         *  complete normally.
-         */
-        private boolean alive;
-
-        HashMap<Symbol, List<Type>> preciseRethrowTypes;
+    /** When analyzing a condition, inits and uninits are null.
+     *  Instead we have:
+     */
+    Bits initsWhenTrue;
+    Bits initsWhenFalse;
+    Bits uninitsWhenTrue;
+    Bits uninitsWhenFalse;
 
-        /** The current class being defined.
-         */
-        JCClassDecl classDef;
+    /** A mapping from addresses to variable symbols.
+     */
+    VarSymbol[] vars;
 
-        /** The list of possibly thrown declarable exceptions.
-         */
-        List<Type> thrown;
+    /** The current class being defined.
+     */
+    JCClassDecl classDef;
 
-        /** The list of exceptions that are either caught or declared to be
-         *  thrown.
-         */
-        List<Type> caught;
+    /** The first variable sequence number in this class definition.
+     */
+    int firstadr;
 
-        class FlowPendingExit extends BaseAnalyzer.PendingExit {
+    /** The next available variable sequence number.
+     */
+    int nextadr;
 
-            Type thrown;
+    /** The list of possibly thrown declarable exceptions.
+     */
+    List<Type> thrown;
 
-            FlowPendingExit(JCTree tree, Type thrown) {
-                super(tree);
-                this.thrown = thrown;
-            }
+    /** The list of exceptions that are either caught or declared to be
+     *  thrown.
+     */
+    List<Type> caught;
 
-            void resolveJump() { /*do nothing*/ }
-        }
+    /** The list of unreferenced automatic resources.
+     */
+    Scope unrefdResources;
 
-        @Override
-        void markDead() {
-            alive = false;
-        }
+    /** Set when processing a loop body the second time for DU analysis. */
+    boolean loopPassTwo = false;
 
-        /*-------------------- Exceptions ----------------------*/
+    /*-------------------- Environments ----------------------*/
 
-        /** Complain that pending exceptions are not caught.
-         */
-        void errorUncaught() {
-            for (FlowPendingExit exit = pendingExits.next();
-                 exit != null;
-                 exit = pendingExits.next()) {
-                if (classDef != null &&
-                    classDef.pos == exit.tree.pos) {
-                    log.error(exit.tree.pos(),
-                            "unreported.exception.default.constructor",
-                            exit.thrown);
-                } else if (exit.tree.hasTag(VARDEF) &&
-                        ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
-                    log.error(exit.tree.pos(),
-                            "unreported.exception.implicit.close",
-                            exit.thrown,
-                            ((JCVariableDecl)exit.tree).sym.name);
-                } else {
-                    log.error(exit.tree.pos(),
-                            "unreported.exception.need.to.catch.or.throw",
-                            exit.thrown);
-                }
-            }
+    /** A pending exit.  These are the statements return, break, and
+     *  continue.  In addition, exception-throwing expressions or
+     *  statements are put here when not known to be caught.  This
+     *  will typically result in an error unless it is within a
+     *  try-finally whose finally block cannot complete normally.
+     */
+    static class PendingExit {
+        JCTree tree;
+        Bits inits;
+        Bits uninits;
+        Type thrown;
+        PendingExit(JCTree tree, Bits inits, Bits uninits) {
+            this.tree = tree;
+            this.inits = inits.dup();
+            this.uninits = uninits.dup();
+        }
+        PendingExit(JCTree tree, Type thrown) {
+            this.tree = tree;
+            this.thrown = thrown;
         }
+    }
 
-        /** Record that exception is potentially thrown and check that it
-         *  is caught.
-         */
-        void markThrown(JCTree tree, Type exc) {
-            if (!chk.isUnchecked(tree.pos(), exc)) {
-                if (!chk.isHandled(exc, caught))
-                    pendingExits.append(new FlowPendingExit(tree, exc));
-                    thrown = chk.incl(exc, thrown);
-            }
-        }
+    /** The currently pending exits that go from current inner blocks
+     *  to an enclosing block, in source order.
+     */
+    ListBuffer<PendingExit> pendingExits;
 
-    /*************************************************************************
-     * Visitor methods for statements and definitions
-     *************************************************************************/
-
-        /** Analyze a definition.
-         */
-        void scanDef(JCTree tree) {
-            scanStat(tree);
-            if (tree != null && tree.hasTag(JCTree.Tag.BLOCK) && !alive) {
-                log.error(tree.pos(),
-                          "initializer.must.be.able.to.complete.normally");
-            }
-        }
+    /*-------------------- Exceptions ----------------------*/
 
-        /** Analyze a statement. Check that statement is reachable.
-         */
-        void scanStat(JCTree tree) {
-            if (!alive && tree != null) {
-                log.error(tree.pos(), "unreachable.stmt");
-                if (!tree.hasTag(SKIP)) alive = true;
+    /** Complain that pending exceptions are not caught.
+     */
+    void errorUncaught() {
+        for (PendingExit exit = pendingExits.next();
+             exit != null;
+             exit = pendingExits.next()) {
+            if (classDef != null &&
+                classDef.pos == exit.tree.pos) {
+                log.error(exit.tree.pos(),
+                        "unreported.exception.default.constructor",
+                        exit.thrown);
+            } else if (exit.tree.getTag() == JCTree.VARDEF &&
+                    ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
+                log.error(exit.tree.pos(),
+                        "unreported.exception.implicit.close",
+                        exit.thrown,
+                        ((JCVariableDecl)exit.tree).sym.name);
+            } else {
+                log.error(exit.tree.pos(),
+                        "unreported.exception.need.to.catch.or.throw",
+                        exit.thrown);
             }
-            scan(tree);
         }
+    }
 
-        /** Analyze list of statements.
-         */
-        void scanStats(List<? extends JCStatement> trees) {
-            if (trees != null)
-                for (List<? extends JCStatement> l = trees; l.nonEmpty(); l = l.tail)
-                    scanStat(l.head);
-        }
-
-        /* ------------ Visitor methods for various sorts of trees -------------*/
-
-        public void visitClassDef(JCClassDecl tree) {
-            if (tree.sym == null) return;
-
-            JCClassDecl classDefPrev = classDef;
-            List<Type> thrownPrev = thrown;
-            List<Type> caughtPrev = caught;
-            boolean alivePrev = alive;
-            ListBuffer<FlowPendingExit> pendingExitsPrev = pendingExits;
-            Lint lintPrev = lint;
-
-            pendingExits = new ListBuffer<FlowPendingExit>();
-            if (tree.name != names.empty) {
-                caught = List.nil();
-            }
-            classDef = tree;
-            thrown = List.nil();
-            lint = lint.augment(tree.sym.attributes_field);
-
-            try {
-                // process all the static initializers
-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                    if (!l.head.hasTag(METHODDEF) &&
-                        (TreeInfo.flags(l.head) & STATIC) != 0) {
-                        scanDef(l.head);
-                        errorUncaught();
-                    }
-                }
-
-                // add intersection of all thrown clauses of initial constructors
-                // to set of caught exceptions, unless class is anonymous.
-                if (tree.name != names.empty) {
-                    boolean firstConstructor = true;
-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                        if (TreeInfo.isInitialConstructor(l.head)) {
-                            List<Type> mthrown =
-                                ((JCMethodDecl) l.head).sym.type.getThrownTypes();
-                            if (firstConstructor) {
-                                caught = mthrown;
-                                firstConstructor = false;
-                            } else {
-                                caught = chk.intersect(mthrown, caught);
-                            }
-                        }
-                    }
-                }
-
-                // process all the instance initializers
-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                    if (!l.head.hasTag(METHODDEF) &&
-                        (TreeInfo.flags(l.head) & STATIC) == 0) {
-                        scanDef(l.head);
-                        errorUncaught();
-                    }
-                }
-
-                // in an anonymous class, add the set of thrown exceptions to
-                // the throws clause of the synthetic constructor and propagate
-                // outwards.
-                // Changing the throws clause on the fly is okay here because
-                // the anonymous constructor can't be invoked anywhere else,
-                // and its type hasn't been cached.
-                if (tree.name == names.empty) {
-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                        if (TreeInfo.isInitialConstructor(l.head)) {
-                            JCMethodDecl mdef = (JCMethodDecl)l.head;
-                            mdef.thrown = make.Types(thrown);
-                            mdef.sym.type = types.createMethodTypeWithThrown(mdef.sym.type, thrown);
-                        }
-                    }
-                    thrownPrev = chk.union(thrown, thrownPrev);
-                }
-
-                // process all the methods
-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                    if (l.head.hasTag(METHODDEF)) {
-                        scan(l.head);
-                        errorUncaught();
-                    }
-                }
-
-                thrown = thrownPrev;
-            } finally {
-                pendingExits = pendingExitsPrev;
-                alive = alivePrev;
-                caught = caughtPrev;
-                classDef = classDefPrev;
-                lint = lintPrev;
-            }
+    /** Record that exception is potentially thrown and check that it
+     *  is caught.
+     */
+    void markThrown(JCTree tree, Type exc) {
+        if (!chk.isUnchecked(tree.pos(), exc)) {
+            if (!chk.isHandled(exc, caught))
+                pendingExits.append(new PendingExit(tree, exc));
+                thrown = chk.incl(exc, thrown);
         }
+    }
 
-        public void visitMethodDef(JCMethodDecl tree) {
-            if (tree.body == null) return;
-
-            List<Type> caughtPrev = caught;
-            List<Type> mthrown = tree.sym.type.getThrownTypes();
-            Lint lintPrev = lint;
-
-            lint = lint.augment(tree.sym.attributes_field);
-
-            Assert.check(pendingExits.isEmpty());
+    /*-------------- Processing variables ----------------------*/
 
-            try {
-                for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {
-                    JCVariableDecl def = l.head;
-                    scan(def);
-                }
-                if (TreeInfo.isInitialConstructor(tree))
-                    caught = chk.union(caught, mthrown);
-                else if ((tree.sym.flags() & (BLOCK | STATIC)) != BLOCK)
-                    caught = mthrown;
-                // else we are in an instance initializer block;
-                // leave caught unchanged.
-
-                alive = true;
-                scanStat(tree.body);
+    /** Do we need to track init/uninit state of this symbol?
+     *  I.e. is symbol either a local or a blank final variable?
+     */
+    boolean trackable(VarSymbol sym) {
+        return
+            (sym.owner.kind == MTH ||
+             ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == FINAL &&
+              classDef.sym.isEnclosedBy((ClassSymbol)sym.owner)));
+    }
 
-                if (alive && tree.sym.type.getReturnType().tag != VOID)
-                    log.error(TreeInfo.diagEndPos(tree.body), "missing.ret.stmt");
+    /** Initialize new trackable variable by setting its address field
+     *  to the next available sequence number and entering it under that
+     *  index into the vars array.
+     */
+    void newVar(VarSymbol sym) {
+        if (nextadr == vars.length) {
+            VarSymbol[] newvars = new VarSymbol[nextadr * 2];
+            System.arraycopy(vars, 0, newvars, 0, nextadr);
+            vars = newvars;
+        }
+        sym.adr = nextadr;
+        vars[nextadr] = sym;
+        inits.excl(nextadr);
+        uninits.incl(nextadr);
+        nextadr++;
+    }
 
-                List<FlowPendingExit> exits = pendingExits.toList();
-                pendingExits = new ListBuffer<FlowPendingExit>();
-                while (exits.nonEmpty()) {
-                    FlowPendingExit exit = exits.head;
-                    exits = exits.tail;
-                    if (exit.thrown == null) {
-                        Assert.check(exit.tree.hasTag(RETURN));
-                    } else {
-                        // uncaught throws will be reported later
-                        pendingExits.append(exit);
+    /** Record an initialization of a trackable variable.
+     */
+    void letInit(DiagnosticPosition pos, VarSymbol sym) {
+        if (sym.adr >= firstadr && trackable(sym)) {
+            if ((sym.flags() & FINAL) != 0) {
+                if ((sym.flags() & PARAMETER) != 0) {
+                    if ((sym.flags() & UNION) != 0) { //multi-catch parameter
+                        log.error(pos, "multicatch.parameter.may.not.be.assigned",
+                                  sym);
                     }
-                }
-            } finally {
-                caught = caughtPrev;
-                lint = lintPrev;
-            }
-        }
-
-        public void visitVarDef(JCVariableDecl tree) {
-            if (tree.init != null) {
-                Lint lintPrev = lint;
-                lint = lint.augment(tree.sym.attributes_field);
-                try{
-                    scan(tree.init);
-                } finally {
-                    lint = lintPrev;
+                    else {
+                        log.error(pos, "final.parameter.may.not.be.assigned",
+                              sym);
+                    }
+                } else if (!uninits.isMember(sym.adr)) {
+                    log.error(pos,
+                              loopPassTwo
+                              ? "var.might.be.assigned.in.loop"
+                              : "var.might.already.be.assigned",
+                              sym);
+                } else if (!inits.isMember(sym.adr)) {
+                    // reachable assignment
+                    uninits.excl(sym.adr);
+                    uninitsTry.excl(sym.adr);
+                } else {
+                    //log.rawWarning(pos, "unreachable assignment");//DEBUG
+                    uninits.excl(sym.adr);
                 }
             }
+            inits.incl(sym.adr);
+        } else if ((sym.flags() & FINAL) != 0) {
+            log.error(pos, "var.might.already.be.assigned", sym);
         }
+    }
 
-        public void visitBlock(JCBlock tree) {
-            scanStats(tree.stats);
-        }
-
-        public void visitDoLoop(JCDoWhileLoop tree) {
-            ListBuffer<FlowPendingExit> prevPendingExits = pendingExits;
-            pendingExits = new ListBuffer<FlowPendingExit>();
-            scanStat(tree.body);
-            alive |= resolveContinues(tree);
-            scan(tree.cond);
-            alive = alive && !tree.cond.type.isTrue();
-            alive |= resolveBreaks(tree, prevPendingExits);
-        }
-
-        public void visitWhileLoop(JCWhileLoop tree) {
-            ListBuffer<FlowPendingExit> prevPendingExits = pendingExits;
-            pendingExits = new ListBuffer<FlowPendingExit>();
-            scan(tree.cond);
-            alive = !tree.cond.type.isFalse();
-            scanStat(tree.body);
-            alive |= resolveContinues(tree);
-            alive = resolveBreaks(tree, prevPendingExits) ||
-                !tree.cond.type.isTrue();
-        }
-
-        public void visitForLoop(JCForLoop tree) {
-            ListBuffer<FlowPendingExit> prevPendingExits = pendingExits;
-            scanStats(tree.init);
-            pendingExits = new ListBuffer<FlowPendingExit>();
-            if (tree.cond != null) {
-                scan(tree.cond);
-                alive = !tree.cond.type.isFalse();
-            } else {
-                alive = true;
+    /** If tree is either a simple name or of the form this.name or
+     *  C.this.name, and tree represents a trackable variable,
+     *  record an initialization of the variable.
+     */
+    void letInit(JCTree tree) {
+        tree = TreeInfo.skipParens(tree);
+        if (tree.getTag() == JCTree.IDENT || tree.getTag() == JCTree.SELECT) {
+            Symbol sym = TreeInfo.symbol(tree);
+            if (sym.kind == VAR) {
+                letInit(tree.pos(), (VarSymbol)sym);
             }
-            scanStat(tree.body);
-            alive |= resolveContinues(tree);
-            scan(tree.step);
-            alive = resolveBreaks(tree, prevPendingExits) ||
-                tree.cond != null && !tree.cond.type.isTrue();
-        }
-
-        public void visitForeachLoop(JCEnhancedForLoop tree) {
-            visitVarDef(tree.var);
-            ListBuffer<FlowPendingExit> prevPendingExits = pendingExits;
-            scan(tree.expr);
-            pendingExits = new ListBuffer<FlowPendingExit>();
-            scanStat(tree.body);
-            alive |= resolveContinues(tree);
-            resolveBreaks(tree, prevPendingExits);
-            alive = true;
-        }
-
-        public void visitLabelled(JCLabeledStatement tree) {
-            ListBuffer<FlowPendingExit> prevPendingExits = pendingExits;
-            pendingExits = new ListBuffer<FlowPendingExit>();
-            scanStat(tree.body);
-            alive |= resolveBreaks(tree, prevPendingExits);
         }
+    }
 
-        public void visitSwitch(JCSwitch tree) {
-            ListBuffer<FlowPendingExit> prevPendingExits = pendingExits;
-            pendingExits = new ListBuffer<FlowPendingExit>();
-            scan(tree.selector);
-            boolean hasDefault = false;
-            for (List<JCCase> l = tree.cases; l.nonEmpty(); l = l.tail) {
-                alive = true;
-                JCCase c = l.head;
-                if (c.pat == null)
-                    hasDefault = true;
-                else
-                    scan(c.pat);
-                scanStats(c.stats);
-                // Warn about fall-through if lint switch fallthrough enabled.
-                if (alive &&
-                    lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &&
-                    c.stats.nonEmpty() && l.tail.nonEmpty())
-                    log.warning(Lint.LintCategory.FALLTHROUGH,
-                                l.tail.head.pos(),
-                                "possible.fall-through.into.case");
-            }
-            if (!hasDefault) {
-                alive = true;
-            }
-            alive |= resolveBreaks(tree, prevPendingExits);
+    /** Check that trackable variable is initialized.
+     */
+    void checkInit(DiagnosticPosition pos, VarSymbol sym) {
+        if ((sym.adr >= firstadr || sym.owner.kind != TYP) &&
+            trackable(sym) &&
+            !inits.isMember(sym.adr)) {
+            log.error(pos, "var.might.not.have.been.initialized",
+                      sym);
+            inits.incl(sym.adr);
         }
+    }
 
-        public void visitTry(JCTry tree) {
-            List<Type> caughtPrev = caught;
-            List<Type> thrownPrev = thrown;
-            thrown = List.nil();
-            for (List<JCCatch> l = tree.catchers; l.nonEmpty(); l = l.tail) {
-                List<JCExpression> subClauses = TreeInfo.isMultiCatch(l.head) ?
-                        ((JCTypeUnion)l.head.param.vartype).alternatives :
-                        List.of(l.head.param.vartype);
-                for (JCExpression ct : subClauses) {
-                    caught = chk.incl(ct.type, caught);
-                }
-            }
+    /*-------------------- Handling jumps ----------------------*/
 
-            ListBuffer<FlowPendingExit> prevPendingExits = pendingExits;
-            pendingExits = new ListBuffer<FlowPendingExit>();
-            for (JCTree resource : tree.resources) {
-                if (resource instanceof JCVariableDecl) {
-                    JCVariableDecl vdecl = (JCVariableDecl) resource;
-                    visitVarDef(vdecl);
-                } else if (resource instanceof JCExpression) {
-                    scan((JCExpression) resource);
-                } else {
-                    throw new AssertionError(tree);  // parser error
-                }
-            }
-            for (JCTree resource : tree.resources) {
-                List<Type> closeableSupertypes = resource.type.isCompound() ?
-                    types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
-                    List.of(resource.type);
-                for (Type sup : closeableSupertypes) {
-                    if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {
-                        Symbol closeMethod = rs.resolveQualifiedMethod(tree,
-                                attrEnv,
-                                sup,
-                                names.close,
-                                List.<Type>nil(),
-                                List.<Type>nil());
-                        if (closeMethod.kind == MTH) {
-                            for (Type t : ((MethodSymbol)closeMethod).getThrownTypes()) {
-                                markThrown(resource, t);
-                            }
-                        }
-                    }
-                }
-            }
-            scanStat(tree.body);
-            List<Type> thrownInTry = allowImprovedCatchAnalysis ?
-                chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType)) :
-                thrown;
-            thrown = thrownPrev;
-            caught = caughtPrev;
-            boolean aliveEnd = alive;
+    /** Record an outward transfer of control. */
+    void recordExit(JCTree tree) {
+        pendingExits.append(new PendingExit(tree, inits, uninits));
+        markDead();
+    }
 
-            List<Type> caughtInTry = List.nil();
-            for (List<JCCatch> l = tree.catchers; l.nonEmpty(); l = l.tail) {
-                alive = true;
-                JCVariableDecl param = l.head.param;
-                List<JCExpression> subClauses = TreeInfo.isMultiCatch(l.head) ?
-                        ((JCTypeUnion)l.head.param.vartype).alternatives :
-                        List.of(l.head.param.vartype);
-                List<Type> ctypes = List.nil();
-                List<Type> rethrownTypes = chk.diff(thrownInTry, caughtInTry);
-                for (JCExpression ct : subClauses) {
-                    Type exc = ct.type;
-                    if (exc != syms.unknownType) {
-                        ctypes = ctypes.append(exc);
-                        if (types.isSameType(exc, syms.objectType))
-                            continue;
-                        checkCaughtType(l.head.pos(), exc, thrownInTry, caughtInTry);
-                        caughtInTry = chk.incl(exc, caughtInTry);
-                    }
-                }
-                scan(param);
-                preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
-                scanStat(l.head.body);
-                preciseRethrowTypes.remove(param.sym);
-                aliveEnd |= alive;
-            }
-            if (tree.finalizer != null) {
-                List<Type> savedThrown = thrown;
-                thrown = List.nil();
-                ListBuffer<FlowPendingExit> exits = pendingExits;
-                pendingExits = prevPendingExits;
-                alive = true;
-                scanStat(tree.finalizer);
-                if (!alive) {
-                    // discard exits and exceptions from try and finally
-                    thrown = chk.union(thrown, thrownPrev);
-                    if (lint.isEnabled(Lint.LintCategory.FINALLY)) {
-                        log.warning(Lint.LintCategory.FINALLY,
-                                TreeInfo.diagEndPos(tree.finalizer),
-                                "finally.cannot.complete");
-                    }
-                } else {
-                    thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
-                    thrown = chk.union(thrown, savedThrown);
-                    // FIX: this doesn't preserve source order of exits in catch
-                    // versus finally!
-                    while (exits.nonEmpty()) {
-                        pendingExits.append(exits.next());
-                    }
-                    alive = aliveEnd;
-                }
-                tree.finallyCanCompleteNormally = alive;
+    /** Resolve all breaks of this statement. */
+    boolean resolveBreaks(JCTree tree,
+                          ListBuffer<PendingExit> oldPendingExits) {
+        boolean result = false;
+        List<PendingExit> exits = pendingExits.toList();
+        pendingExits = oldPendingExits;
+        for (; exits.nonEmpty(); exits = exits.tail) {
+            PendingExit exit = exits.head;
+            if (exit.tree.getTag() == JCTree.BREAK &&
+                ((JCBreak) exit.tree).target == tree) {
+                inits.andSet(exit.inits);
+                uninits.andSet(exit.uninits);
+                result = true;
             } else {
-                thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
-                alive = aliveEnd;
-                ListBuffer<FlowPendingExit> exits = pendingExits;
-                pendingExits = prevPendingExits;
-                while (exits.nonEmpty()) pendingExits.append(exits.next());
+                pendingExits.append(exit);
             }
         }
+        return result;
+    }
 
-        @Override
-        public void visitIf(JCIf tree) {
-            scan(tree.cond);
-            scanStat(tree.thenpart);
-            if (tree.elsepart != null) {
-                boolean aliveAfterThen = alive;
-                alive = true;
-                scanStat(tree.elsepart);
-                alive = alive | aliveAfterThen;
+    /** Resolve all continues of this statement. */
+    boolean resolveContinues(JCTree tree) {
+        boolean result = false;
+        List<PendingExit> exits = pendingExits.toList();
+        pendingExits = new ListBuffer<PendingExit>();
+        for (; exits.nonEmpty(); exits = exits.tail) {
+            PendingExit exit = exits.head;
+            if (exit.tree.getTag() == JCTree.CONTINUE &&
+                ((JCContinue) exit.tree).target == tree) {
+                inits.andSet(exit.inits);
+                uninits.andSet(exit.uninits);
+                result = true;
             } else {
-                alive = true;
-            }
-        }
-
-        void checkCaughtType(DiagnosticPosition pos, Type exc, List<Type> thrownInTry, List<Type> caughtInTry) {
-            if (chk.subset(exc, caughtInTry)) {
-                log.error(pos, "except.already.caught", exc);
-            } else if (!chk.isUnchecked(pos, exc) &&
-                    !isExceptionOrThrowable(exc) &&
-                    !chk.intersects(exc, thrownInTry)) {
-                log.error(pos, "except.never.thrown.in.try", exc);
-            } else if (allowImprovedCatchAnalysis) {
-                List<Type> catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
-                // 'catchableThrownTypes' cannnot possibly be empty - if 'exc' was an
-                // unchecked exception, the result list would not be empty, as the augmented
-                // thrown set includes { RuntimeException, Error }; if 'exc' was a checked
-                // exception, that would have been covered in the branch above
-                if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &&
-                        !isExceptionOrThrowable(exc)) {
-                    String key = catchableThrownTypes.length() == 1 ?
-                            "unreachable.catch" :
-                            "unreachable.catch.1";
-                    log.warning(pos, key, catchableThrownTypes);
-                }
+                pendingExits.append(exit);
             }
         }
-        //where
-            private boolean isExceptionOrThrowable(Type exc) {
-                return exc.tsym == syms.throwableType.tsym ||
-                    exc.tsym == syms.exceptionType.tsym;
-            }
-
-        public void visitBreak(JCBreak tree) {
-            recordExit(tree, new FlowPendingExit(tree, null));
-        }
+        return result;
+    }
 
-        public void visitContinue(JCContinue tree) {
-            recordExit(tree, new FlowPendingExit(tree, null));
-        }
+    /** Record that statement is unreachable.
+     */
+    void markDead() {
+        inits.inclRange(firstadr, nextadr);
+        uninits.inclRange(firstadr, nextadr);
+        alive = false;
+    }
 
-        public void visitReturn(JCReturn tree) {
-            scan(tree.expr);
-            // if not initial constructor, should markDead instead of recordExit
-            recordExit(tree, new FlowPendingExit(tree, null));
-        }
+    /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
+     */
+    void split(boolean setToNull) {
+        initsWhenFalse = inits.dup();
+        uninitsWhenFalse = uninits.dup();
+        initsWhenTrue = inits;
+        uninitsWhenTrue = uninits;
+        if (setToNull)
+            inits = uninits = null;
+    }
 
-        public void visitThrow(JCThrow tree) {
-            scan(tree.expr);
-            Symbol sym = TreeInfo.symbol(tree.expr);
-            if (sym != null &&
-                sym.kind == VAR &&
-                (sym.flags() & (FINAL | EFFECTIVELY_FINAL)) != 0 &&
-                preciseRethrowTypes.get(sym) != null &&
-                allowImprovedRethrowAnalysis) {
-                for (Type t : preciseRethrowTypes.get(sym)) {
-                    markThrown(tree, t);
-                }
-            }
-            else {
-                markThrown(tree, tree.expr.type);
-            }
-            markDead();
-        }
+    /** Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
+     */
+    void merge() {
+        inits = initsWhenFalse.andSet(initsWhenTrue);
+        uninits = uninitsWhenFalse.andSet(uninitsWhenTrue);
+    }
 
-        public void visitApply(JCMethodInvocation tree) {
-            scan(tree.meth);
-            scan(tree.args);
-            for (List<Type> l = tree.meth.type.getThrownTypes(); l.nonEmpty(); l = l.tail)
-                markThrown(tree, l.head);
-        }
-
-        public void visitNewClass(JCNewClass tree) {
-            scan(tree.encl);
-            scan(tree.args);
-           // scan(tree.def);
-            for (List<Type> l = tree.constructorType.getThrownTypes();
-                 l.nonEmpty();
-                 l = l.tail) {
-                markThrown(tree, l.head);
-            }
-            List<Type> caughtPrev = caught;
-            try {
-                // If the new class expression defines an anonymous class,
-                // analysis of the anonymous constructor may encounter thrown
-                // types which are unsubstituted type variables.
-                // However, since the constructor's actual thrown types have
-                // already been marked as thrown, it is safe to simply include
-                // each of the constructor's formal thrown types in the set of
-                // 'caught/declared to be thrown' types, for the duration of
-                // the class def analysis.
-                if (tree.def != null)
-                    for (List<Type> l = tree.constructor.type.getThrownTypes();
-                         l.nonEmpty();
-                         l = l.tail) {
-                        caught = chk.incl(l.head, caught);
-                    }
-                scan(tree.def);
-            }
-            finally {
-                caught = caughtPrev;
-            }
-        }
+/* ************************************************************************
+ * Visitor methods for statements and definitions
+ *************************************************************************/
 
-        public void visitTopLevel(JCCompilationUnit tree) {
-            // Do nothing for TopLevel since each class is visited individually
+    /** Analyze a definition.
+     */
+    void scanDef(JCTree tree) {
+        scanStat(tree);
+        if (tree != null && tree.getTag() == JCTree.BLOCK && !alive) {
+            log.error(tree.pos(),
+                      "initializer.must.be.able.to.complete.normally");
         }
+    }
 
-    /**************************************************************************
-     * main method
-     *************************************************************************/
-
-        /** Perform definite assignment/unassignment analysis on a tree.
-         */
-        public void analyzeTree(Env<AttrContext> env, TreeMaker make) {
-            try {
-                attrEnv = env;
-                JCTree tree = env.tree;
-                Flow.this.make = make;
-                pendingExits = new ListBuffer<FlowPendingExit>();
-                preciseRethrowTypes = new HashMap<Symbol, List<Type>>();
-                alive = true;
-                this.thrown = this.caught = null;
-                this.classDef = null;
-                scan(tree);
-            } finally {
-                pendingExits = null;
-                Flow.this.make = null;
-                this.thrown = this.caught = null;
-                this.classDef = null;
-            }
+    /** Analyze a statement. Check that statement is reachable.
+     */
+    void scanStat(JCTree tree) {
+        if (!alive && tree != null) {
+            log.error(tree.pos(), "unreachable.stmt");
+            if (tree.getTag() != JCTree.SKIP) alive = true;
         }
+        scan(tree);
     }
 
-    /**
-     * This pass implements (i) definite assignment analysis, which ensures that
-     * each variable is assigned when used and (ii) definite unassignment analysis,
-     * which ensures that no final variable is assigned more than once. This visitor
-     * depends on the results of the liveliness analyzer.
+    /** Analyze list of statements.
      */
-    class AssignAnalyzer extends BaseAnalyzer<AssignAnalyzer.AssignPendingExit> {
-
-        /** The set of definitely assigned variables.
-         */
-        Bits inits;
-
-        /** The set of definitely unassigned variables.
-         */
-        Bits uninits;
-
-        /** The set of variables that are definitely unassigned everywhere
-         *  in current try block. This variable is maintained lazily; it is
-         *  updated only when something gets removed from uninits,
-         *  typically by being assigned in reachable code.  To obtain the
-         *  correct set of variables which are definitely unassigned
-         *  anywhere in current try block, intersect uninitsTry and
-         *  uninits.
-         */
-        Bits uninitsTry;
-
-        /** When analyzing a condition, inits and uninits are null.
-         *  Instead we have:
-         */
-        Bits initsWhenTrue;
-        Bits initsWhenFalse;
-        Bits uninitsWhenTrue;
-        Bits uninitsWhenFalse;
-
-        /** A mapping from addresses to variable symbols.
-         */
-        VarSymbol[] vars;
-
-        /** The current class being defined.
-         */
-        JCClassDecl classDef;
-
-        /** The first variable sequence number in this class definition.
-         */
-        int firstadr;
-
-        /** The next available variable sequence number.
-         */
-        int nextadr;
-
-        /** The list of unreferenced automatic resources.
-         */
-        Scope unrefdResources;
-
-        /** Set when processing a loop body the second time for DU analysis. */
-        boolean loopPassTwo = false;
-
-        class AssignPendingExit extends BaseAnalyzer.PendingExit {
-
-            Bits exit_inits;
-            Bits exit_uninits;
-
-            AssignPendingExit(JCTree tree, Bits inits, Bits uninits) {
-                super(tree);
-                this.exit_inits = inits.dup();
-                this.exit_uninits = uninits.dup();
-            }
-
-            void resolveJump() {
-                inits.andSet(exit_inits);
-                uninits.andSet(exit_uninits);
-            }
-        }
-
-        @Override
-        void markDead() {
-            inits.inclRange(firstadr, nextadr);
-            uninits.inclRange(firstadr, nextadr);
-        }
-
-        /*-------------- Processing variables ----------------------*/
-
-        /** Do we need to track init/uninit state of this symbol?
-         *  I.e. is symbol either a local or a blank final variable?
-         */
-        boolean trackable(VarSymbol sym) {
-            return
-                (sym.owner.kind == MTH ||
-                 ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == FINAL &&
-                  classDef.sym.isEnclosedBy((ClassSymbol)sym.owner)));
-        }
-
-        /** Initialize new trackable variable by setting its address field
-         *  to the next available sequence number and entering it under that
-         *  index into the vars array.
-         */
-        void newVar(VarSymbol sym) {
-            if (nextadr == vars.length) {
-                VarSymbol[] newvars = new VarSymbol[nextadr * 2];
-                System.arraycopy(vars, 0, newvars, 0, nextadr);
-                vars = newvars;
-            }
-            sym.adr = nextadr;
-            vars[nextadr] = sym;
-            inits.excl(nextadr);
-            uninits.incl(nextadr);
-            nextadr++;
-        }
-
-        /** Record an initialization of a trackable variable.
-         */
-        void letInit(DiagnosticPosition pos, VarSymbol sym) {
-            if (sym.adr >= firstadr && trackable(sym)) {
-                if ((sym.flags() & FINAL) != 0) {
-                    if ((sym.flags() & PARAMETER) != 0) {
-                        if ((sym.flags() & UNION) != 0) { //multi-catch parameter
-                            log.error(pos, "multicatch.parameter.may.not.be.assigned",
-                                      sym);
-                        }
-                        else {
-                            log.error(pos, "final.parameter.may.not.be.assigned",
-                                  sym);
-                        }
-                    } else if (!uninits.isMember(sym.adr)) {
-                        log.error(pos,
-                                  loopPassTwo
-                                  ? "var.might.be.assigned.in.loop"
-                                  : "var.might.already.be.assigned",
-                                  sym);
-                    } else if (!inits.isMember(sym.adr)) {
-                        // reachable assignment
-                        uninits.excl(sym.adr);
-                        uninitsTry.excl(sym.adr);
-                    } else {
-                        //log.rawWarning(pos, "unreachable assignment");//DEBUG
-                        uninits.excl(sym.adr);
-                    }
-                }
-                inits.incl(sym.adr);
-            } else if ((sym.flags() & FINAL) != 0) {
-                log.error(pos, "var.might.already.be.assigned", sym);
-            }
-        }
+    void scanStats(List<? extends JCStatement> trees) {
+        if (trees != null)
+            for (List<? extends JCStatement> l = trees; l.nonEmpty(); l = l.tail)
+                scanStat(l.head);
+    }
 
-        /** If tree is either a simple name or of the form this.name or
-         *  C.this.name, and tree represents a trackable variable,
-         *  record an initialization of the variable.
-         */
-        void letInit(JCTree tree) {
-            tree = TreeInfo.skipParens(tree);
-            if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
-                Symbol sym = TreeInfo.symbol(tree);
-                if (sym.kind == VAR) {
-                    letInit(tree.pos(), (VarSymbol)sym);
-                }
-            }
+    /** Analyze an expression. Make sure to set (un)inits rather than
+     *  (un)initsWhenTrue(WhenFalse) on exit.
+     */
+    void scanExpr(JCTree tree) {
+        if (tree != null) {
+            scan(tree);
+            if (inits == null) merge();
         }
+    }
 
-        /** Check that trackable variable is initialized.
-         */
-        void checkInit(DiagnosticPosition pos, VarSymbol sym) {
-            if ((sym.adr >= firstadr || sym.owner.kind != TYP) &&
-                trackable(sym) &&
-                !inits.isMember(sym.adr)) {
-                log.error(pos, "var.might.not.have.been.initialized",
-                          sym);
-                inits.incl(sym.adr);
-            }
-        }
+    /** Analyze a list of expressions.
+     */
+    void scanExprs(List<? extends JCExpression> trees) {
+        if (trees != null)
+            for (List<? extends JCExpression> l = trees; l.nonEmpty(); l = l.tail)
+                scanExpr(l.head);
+    }
 
-        /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
-         */
-        void split(boolean setToNull) {
+    /** Analyze a condition. Make sure to set (un)initsWhenTrue(WhenFalse)
+     *  rather than (un)inits on exit.
+     */
+    void scanCond(JCTree tree) {
+        if (tree.type.isFalse()) {
+            if (inits == null) merge();
+            initsWhenTrue = inits.dup();
+            initsWhenTrue.inclRange(firstadr, nextadr);
+            uninitsWhenTrue = uninits.dup();
+            uninitsWhenTrue.inclRange(firstadr, nextadr);
+            initsWhenFalse = inits;
+            uninitsWhenFalse = uninits;
+        } else if (tree.type.isTrue()) {
+            if (inits == null) merge();
             initsWhenFalse = inits.dup();
+            initsWhenFalse.inclRange(firstadr, nextadr);
             uninitsWhenFalse = uninits.dup();
+            uninitsWhenFalse.inclRange(firstadr, nextadr);
             initsWhenTrue = inits;
             uninitsWhenTrue = uninits;
-            if (setToNull)
-                inits = uninits = null;
+        } else {
+            scan(tree);
+            if (inits != null)
+                split(tree.type != syms.unknownType);
         }
+        if (tree.type != syms.unknownType)
+            inits = uninits = null;
+    }
 
-        /** Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
-         */
-        void merge() {
-            inits = initsWhenFalse.andSet(initsWhenTrue);
-            uninits = uninitsWhenFalse.andSet(uninitsWhenTrue);
-        }
-
-    /* ************************************************************************
-     * Visitor methods for statements and definitions
-     *************************************************************************/
-
-        /** Analyze an expression. Make sure to set (un)inits rather than
-         *  (un)initsWhenTrue(WhenFalse) on exit.
-         */
-        void scanExpr(JCTree tree) {
-            if (tree != null) {
-                scan(tree);
-                if (inits == null) merge();
-            }
-        }
+    /* ------------ Visitor methods for various sorts of trees -------------*/
 
-        /** Analyze a list of expressions.
-         */
-        void scanExprs(List<? extends JCExpression> trees) {
-            if (trees != null)
-                for (List<? extends JCExpression> l = trees; l.nonEmpty(); l = l.tail)
-                    scanExpr(l.head);
-        }
-
-        /** Analyze a condition. Make sure to set (un)initsWhenTrue(WhenFalse)
-         *  rather than (un)inits on exit.
-         */
-        void scanCond(JCTree tree) {
-            if (tree.type.isFalse()) {
-                if (inits == null) merge();
-                initsWhenTrue = inits.dup();
-                initsWhenTrue.inclRange(firstadr, nextadr);
-                uninitsWhenTrue = uninits.dup();
-                uninitsWhenTrue.inclRange(firstadr, nextadr);
-                initsWhenFalse = inits;
-                uninitsWhenFalse = uninits;
-            } else if (tree.type.isTrue()) {
-                if (inits == null) merge();
-                initsWhenFalse = inits.dup();
-                initsWhenFalse.inclRange(firstadr, nextadr);
-                uninitsWhenFalse = uninits.dup();
-                uninitsWhenFalse.inclRange(firstadr, nextadr);
-                initsWhenTrue = inits;
-                uninitsWhenTrue = uninits;
-            } else {
-                scan(tree);
-                if (inits != null)
-                    split(tree.type != syms.unknownType);
-            }
-            if (tree.type != syms.unknownType)
-                inits = uninits = null;
-        }
+    public void visitClassDef(JCClassDecl tree) {
+        if (tree.sym == null) return;
 
-        /* ------------ Visitor methods for various sorts of trees -------------*/
+        JCClassDecl classDefPrev = classDef;
+        List<Type> thrownPrev = thrown;
+        List<Type> caughtPrev = caught;
+        boolean alivePrev = alive;
+        int firstadrPrev = firstadr;
+        int nextadrPrev = nextadr;
+        ListBuffer<PendingExit> pendingExitsPrev = pendingExits;
+        Lint lintPrev = lint;
 
-        public void visitClassDef(JCClassDecl tree) {
-            if (tree.sym == null) return;
+        pendingExits = new ListBuffer<PendingExit>();
+        if (tree.name != names.empty) {
+            caught = List.nil();
+            firstadr = nextadr;
+        }
+        classDef = tree;
+        thrown = List.nil();
+        lint = lint.augment(tree.sym.attributes_field);
 
-            JCClassDecl classDefPrev = classDef;
-            int firstadrPrev = firstadr;
-            int nextadrPrev = nextadr;
-            ListBuffer<AssignPendingExit> pendingExitsPrev = pendingExits;
-            Lint lintPrev = lint;
+        try {
+            // define all the static fields
+            for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
+                if (l.head.getTag() == JCTree.VARDEF) {
+                    JCVariableDecl def = (JCVariableDecl)l.head;
+                    if ((def.mods.flags & STATIC) != 0) {
+                        VarSymbol sym = def.sym;
+                        if (trackable(sym))
+                            newVar(sym);
+                    }
+                }
+            }
 
-            pendingExits = new ListBuffer<AssignPendingExit>();
-            if (tree.name != names.empty) {
-                firstadr = nextadr;
+            // process all the static initializers
+            for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
+                if (l.head.getTag() != JCTree.METHODDEF &&
+                    (TreeInfo.flags(l.head) & STATIC) != 0) {
+                    scanDef(l.head);
+                    errorUncaught();
+                }
             }
-            classDef = tree;
-            lint = lint.augment(tree.sym.attributes_field);
 
-            try {
-                // define all the static fields
+            // add intersection of all thrown clauses of initial constructors
+            // to set of caught exceptions, unless class is anonymous.
+            if (tree.name != names.empty) {
+                boolean firstConstructor = true;
                 for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                    if (l.head.hasTag(VARDEF)) {
-                        JCVariableDecl def = (JCVariableDecl)l.head;
-                        if ((def.mods.flags & STATIC) != 0) {
-                            VarSymbol sym = def.sym;
-                            if (trackable(sym))
-                                newVar(sym);
+                    if (TreeInfo.isInitialConstructor(l.head)) {
+                        List<Type> mthrown =
+                            ((JCMethodDecl) l.head).sym.type.getThrownTypes();
+                        if (firstConstructor) {
+                            caught = mthrown;
+                            firstConstructor = false;
+                        } else {
+                            caught = chk.intersect(mthrown, caught);
                         }
                     }
                 }
+            }
 
-                // process all the static initializers
-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                    if (!l.head.hasTag(METHODDEF) &&
-                        (TreeInfo.flags(l.head) & STATIC) != 0) {
-                        scan(l.head);
+            // define all the instance fields
+            for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
+                if (l.head.getTag() == JCTree.VARDEF) {
+                    JCVariableDecl def = (JCVariableDecl)l.head;
+                    if ((def.mods.flags & STATIC) == 0) {
+                        VarSymbol sym = def.sym;
+                        if (trackable(sym))
+                            newVar(sym);
                     }
                 }
+            }
 
-                // define all the instance fields
-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                    if (l.head.hasTag(VARDEF)) {
-                        JCVariableDecl def = (JCVariableDecl)l.head;
-                        if ((def.mods.flags & STATIC) == 0) {
-                            VarSymbol sym = def.sym;
-                            if (trackable(sym))
-                                newVar(sym);
-                        }
-                    }
+            // process all the instance initializers
+            for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
+                if (l.head.getTag() != JCTree.METHODDEF &&
+                    (TreeInfo.flags(l.head) & STATIC) == 0) {
+                    scanDef(l.head);
+                    errorUncaught();
                 }
+            }
 
-                // process all the instance initializers
+            // in an anonymous class, add the set of thrown exceptions to
+            // the throws clause of the synthetic constructor and propagate
+            // outwards.
+            // Changing the throws clause on the fly is okay here because
+            // the anonymous constructor can't be invoked anywhere else,
+            // and its type hasn't been cached.
+            if (tree.name == names.empty) {
                 for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                    if (!l.head.hasTag(METHODDEF) &&
-                        (TreeInfo.flags(l.head) & STATIC) == 0) {
-                        scan(l.head);
+                    if (TreeInfo.isInitialConstructor(l.head)) {
+                        JCMethodDecl mdef = (JCMethodDecl)l.head;
+                        mdef.thrown = make.Types(thrown);
+                        mdef.sym.type = types.createMethodTypeWithThrown(mdef.sym.type, thrown);
                     }
                 }
+                thrownPrev = chk.union(thrown, thrownPrev);
+            }
 
-                // process all the methods
-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
-                    if (l.head.hasTag(METHODDEF)) {
-                        scan(l.head);
-                    }
+            // process all the methods
+            for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
+                if (l.head.getTag() == JCTree.METHODDEF) {
+                    scan(l.head);
+                    errorUncaught();
                 }
-            } finally {
-                pendingExits = pendingExitsPrev;
-                nextadr = nextadrPrev;
-                firstadr = firstadrPrev;
-                classDef = classDefPrev;
-                lint = lintPrev;
             }
+
+            thrown = thrownPrev;
+        } finally {
+            pendingExits = pendingExitsPrev;
+            alive = alivePrev;
+            nextadr = nextadrPrev;
+            firstadr = firstadrPrev;
+            caught = caughtPrev;
+            classDef = classDefPrev;
+            lint = lintPrev;
         }
+    }
 
-        public void visitMethodDef(JCMethodDecl tree) {
-            if (tree.body == null) return;
+    public void visitMethodDef(JCMethodDecl tree) {
+        if (tree.body == null) return;
 
-            Bits initsPrev = inits.dup();
-            Bits uninitsPrev = uninits.dup();
-            int nextadrPrev = nextadr;
-            int firstadrPrev = firstadr;
-            Lint lintPrev = lint;
+        List<Type> caughtPrev = caught;
+        List<Type> mthrown = tree.sym.type.getThrownTypes();
+        Bits initsPrev = inits.dup();
+        Bits uninitsPrev = uninits.dup();
+        int nextadrPrev = nextadr;
+        int firstadrPrev = firstadr;
+        Lint lintPrev = lint;
+
+        lint = lint.augment(tree.sym.attributes_field);
+
+        Assert.check(pendingExits.isEmpty());
+
+        try {
+            boolean isInitialConstructor =
+                TreeInfo.isInitialConstructor(tree);
 
-            lint = lint.augment(tree.sym.attributes_field);
+            if (!isInitialConstructor)
+                firstadr = nextadr;
+            for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {
+                JCVariableDecl def = l.head;
+                scan(def);
+                inits.incl(def.sym.adr);
+                uninits.excl(def.sym.adr);
+            }
+            if (isInitialConstructor)
+                caught = chk.union(caught, mthrown);
+            else if ((tree.sym.flags() & (BLOCK | STATIC)) != BLOCK)
+                caught = mthrown;
+            // else we are in an instance initializer block;
+            // leave caught unchanged.
 
-            Assert.check(pendingExits.isEmpty());
+            alive = true;
+            scanStat(tree.body);
 
-            try {
-                boolean isInitialConstructor =
-                    TreeInfo.isInitialConstructor(tree);
-
-                if (!isInitialConstructor)
-                    firstadr = nextadr;
-                for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {
-                    JCVariableDecl def = l.head;
-                    scan(def);
-                    inits.incl(def.sym.adr);
-                    uninits.excl(def.sym.adr);
-                }
-                // else we are in an instance initializer block;
-                // leave caught unchanged.
-                scan(tree.body);
-
-                if (isInitialConstructor) {
-                    for (int i = firstadr; i < nextadr; i++)
-                        if (vars[i].owner == classDef.sym)
-                            checkInit(TreeInfo.diagEndPos(tree.body), vars[i]);
-                }
-                List<AssignPendingExit> exits = pendingExits.toList();
-                pendingExits = new ListBuffer<AssignPendingExit>();
-                while (exits.nonEmpty()) {
-                    AssignPendingExit exit = exits.head;
-                    exits = exits.tail;
-                    Assert.check(exit.tree.hasTag(RETURN), exit.tree);
+            if (alive && tree.sym.type.getReturnType().tag != VOID)
+                log.error(TreeInfo.diagEndPos(tree.body), "missing.ret.stmt");
+
+            if (isInitialConstructor) {
+                for (int i = firstadr; i < nextadr; i++)
+                    if (vars[i].owner == classDef.sym)
+                        checkInit(TreeInfo.diagEndPos(tree.body), vars[i]);
+            }
+            List<PendingExit> exits = pendingExits.toList();
+            pendingExits = new ListBuffer<PendingExit>();
+            while (exits.nonEmpty()) {
+                PendingExit exit = exits.head;
+                exits = exits.tail;
+                if (exit.thrown == null) {
+                    Assert.check(exit.tree.getTag() == JCTree.RETURN);
                     if (isInitialConstructor) {
-                        inits = exit.exit_inits;
+                        inits = exit.inits;
                         for (int i = firstadr; i < nextadr; i++)
                             checkInit(exit.tree.pos(), vars[i]);
                     }
+                } else {
+                    // uncaught throws will be reported later
+                    pendingExits.append(exit);
                 }
-            } finally {
-                inits = initsPrev;
-                uninits = uninitsPrev;
-                nextadr = nextadrPrev;
-                firstadr = firstadrPrev;
-                lint = lintPrev;
             }
+        } finally {
+            inits = initsPrev;
+            uninits = uninitsPrev;
+            nextadr = nextadrPrev;
+            firstadr = firstadrPrev;
+            caught = caughtPrev;
+            lint = lintPrev;
         }
+    }
 
-        public void visitVarDef(JCVariableDecl tree) {
-            boolean track = trackable(tree.sym);
-            if (track && tree.sym.owner.kind == MTH) newVar(tree.sym);
-            if (tree.init != null) {
-                Lint lintPrev = lint;
-                lint = lint.augment(tree.sym.attributes_field);
-                try{
-                    scanExpr(tree.init);
-                    if (track) letInit(tree.pos(), tree.sym);
-                } finally {
-                    lint = lintPrev;
-                }
+    public void visitVarDef(JCVariableDecl tree) {
+        boolean track = trackable(tree.sym);
+        if (track && tree.sym.owner.kind == MTH) newVar(tree.sym);
+        if (tree.init != null) {
+            Lint lintPrev = lint;
+            lint = lint.augment(tree.sym.attributes_field);
+            try{
+                scanExpr(tree.init);
+                if (track) letInit(tree.pos(), tree.sym);
+            } finally {
+                lint = lintPrev;
             }
         }
+    }
 
-        public void visitBlock(JCBlock tree) {
-            int nextadrPrev = nextadr;
-            scan(tree.stats);
-            nextadr = nextadrPrev;
-        }
+    public void visitBlock(JCBlock tree) {
+        int nextadrPrev = nextadr;
+        scanStats(tree.stats);
+        nextadr = nextadrPrev;
+    }
 
-        public void visitDoLoop(JCDoWhileLoop tree) {
-            ListBuffer<AssignPendingExit> prevPendingExits = pendingExits;
-            boolean prevLoopPassTwo = loopPassTwo;
-            pendingExits = new ListBuffer<AssignPendingExit>();
-            int prevErrors = log.nerrors;
-            do {
-                Bits uninitsEntry = uninits.dup();
-                uninitsEntry.excludeFrom(nextadr);
-            scan(tree.body);
-            resolveContinues(tree);
-                scanCond(tree.cond);
-                if (log.nerrors !=  prevErrors ||
-                    loopPassTwo ||
-                    uninitsEntry.dup().diffSet(uninitsWhenTrue).nextBit(firstadr)==-1)
-                    break;
-                inits = initsWhenTrue;
-                uninits = uninitsEntry.andSet(uninitsWhenTrue);
-                loopPassTwo = true;
-            } while (true);
-            loopPassTwo = prevLoopPassTwo;
-            inits = initsWhenFalse;
-            uninits = uninitsWhenFalse;
-            resolveBreaks(tree, prevPendingExits);
-        }
+    public void visitDoLoop(JCDoWhileLoop tree) {
+        ListBuffer<PendingExit> prevPendingExits = pendingExits;
+        boolean prevLoopPassTwo = loopPassTwo;
+        pendingExits = new ListBuffer<PendingExit>();
+        int prevErrors = log.nerrors;
+        do {
+            Bits uninitsEntry = uninits.dup();
+            uninitsEntry.excludeFrom(nextadr);
+            scanStat(tree.body);
+            alive |= resolveContinues(tree);
+            scanCond(tree.cond);
+            if (log.nerrors !=  prevErrors ||
+                loopPassTwo ||
+                uninitsEntry.dup().diffSet(uninitsWhenTrue).nextBit(firstadr)==-1)
+                break;
+            inits = initsWhenTrue;
+            uninits = uninitsEntry.andSet(uninitsWhenTrue);
+            loopPassTwo = true;
+            alive = true;
+        } while (true);
+        loopPassTwo = prevLoopPassTwo;
+        inits = initsWhenFalse;
+        uninits = uninitsWhenFalse;
+        alive = alive && !tree.cond.type.isTrue();
+        alive |= resolveBreaks(tree, prevPendingExits);
+    }
 
-        public void visitWhileLoop(JCWhileLoop tree) {
-            ListBuffer<AssignPendingExit> prevPendingExits = pendingExits;
-            boolean prevLoopPassTwo = loopPassTwo;
-            Bits initsCond;
-            Bits uninitsCond;
-            pendingExits = new ListBuffer<AssignPendingExit>();
-            int prevErrors = log.nerrors;
-            do {
-                Bits uninitsEntry = uninits.dup();
-                uninitsEntry.excludeFrom(nextadr);
+    public void visitWhileLoop(JCWhileLoop tree) {
+        ListBuffer<PendingExit> prevPendingExits = pendingExits;
+        boolean prevLoopPassTwo = loopPassTwo;
+        Bits initsCond;
+        Bits uninitsCond;
+        pendingExits = new ListBuffer<PendingExit>();
+        int prevErrors = log.nerrors;
+        do {
+            Bits uninitsEntry = uninits.dup();
+            uninitsEntry.excludeFrom(nextadr);
+            scanCond(tree.cond);
+            initsCond = initsWhenFalse;
+            uninitsCond = uninitsWhenFalse;
+            inits = initsWhenTrue;
+            uninits = uninitsWhenTrue;
+            alive = !tree.cond.type.isFalse();
+            scanStat(tree.body);
+            alive |= resolveContinues(tree);
+            if (log.nerrors != prevErrors ||
+                loopPassTwo ||
+                uninitsEntry.dup().diffSet(uninits).nextBit(firstadr) == -1)
+                break;
+            uninits = uninitsEntry.andSet(uninits);
+            loopPassTwo = true;
+            alive = true;
+        } while (true);
+        loopPassTwo = prevLoopPassTwo;
+        inits = initsCond;
+        uninits = uninitsCond;
+        alive = resolveBreaks(tree, prevPendingExits) ||
+            !tree.cond.type.isTrue();
+    }
+
+    public void visitForLoop(JCForLoop tree) {
+        ListBuffer<PendingExit> prevPendingExits = pendingExits;
+        boolean prevLoopPassTwo = loopPassTwo;
+        int nextadrPrev = nextadr;
+        scanStats(tree.init);
+        Bits initsCond;
+        Bits uninitsCond;
+        pendingExits = new ListBuffer<PendingExit>();
+        int prevErrors = log.nerrors;
+        do {
+            Bits uninitsEntry = uninits.dup();
+            uninitsEntry.excludeFrom(nextadr);
+            if (tree.cond != null) {
                 scanCond(tree.cond);
                 initsCond = initsWhenFalse;
                 uninitsCond = uninitsWhenFalse;
                 inits = initsWhenTrue;
                 uninits = uninitsWhenTrue;
-                scan(tree.body);
-                resolveContinues(tree);
-                if (log.nerrors != prevErrors ||
-                    loopPassTwo ||
-                    uninitsEntry.dup().diffSet(uninits).nextBit(firstadr) == -1)
-                    break;
-                uninits = uninitsEntry.andSet(uninits);
-                loopPassTwo = true;
-            } while (true);
-            loopPassTwo = prevLoopPassTwo;
-            inits = initsCond;
-            uninits = uninitsCond;
-            resolveBreaks(tree, prevPendingExits);
-        }
-
-        public void visitForLoop(JCForLoop tree) {
-            ListBuffer<AssignPendingExit> prevPendingExits = pendingExits;
-            boolean prevLoopPassTwo = loopPassTwo;
-            int nextadrPrev = nextadr;
-            scan(tree.init);
-            Bits initsCond;
-            Bits uninitsCond;
-            pendingExits = new ListBuffer<AssignPendingExit>();
-            int prevErrors = log.nerrors;
-            do {
-                Bits uninitsEntry = uninits.dup();
-                uninitsEntry.excludeFrom(nextadr);
-                if (tree.cond != null) {
-                    scanCond(tree.cond);
-                    initsCond = initsWhenFalse;
-                    uninitsCond = uninitsWhenFalse;
-                    inits = initsWhenTrue;
-                    uninits = uninitsWhenTrue;
-                } else {
-                    initsCond = inits.dup();
-                    initsCond.inclRange(firstadr, nextadr);
-                    uninitsCond = uninits.dup();
-                    uninitsCond.inclRange(firstadr, nextadr);
-                }
-                scan(tree.body);
-                resolveContinues(tree);
-                scan(tree.step);
-                if (log.nerrors != prevErrors ||
-                    loopPassTwo ||
-                    uninitsEntry.dup().diffSet(uninits).nextBit(firstadr) == -1)
-                    break;
-                uninits = uninitsEntry.andSet(uninits);
-                loopPassTwo = true;
-            } while (true);
-            loopPassTwo = prevLoopPassTwo;
-            inits = initsCond;
-            uninits = uninitsCond;
-            resolveBreaks(tree, prevPendingExits);
-            nextadr = nextadrPrev;
-        }
+                alive = !tree.cond.type.isFalse();
+            } else {
+                initsCond = inits.dup();
+                initsCond.inclRange(firstadr, nextadr);
+                uninitsCond = uninits.dup();
+                uninitsCond.inclRange(firstadr, nextadr);
+                alive = true;
+            }
+            scanStat(tree.body);
+            alive |= resolveContinues(tree);
+            scan(tree.step);
+            if (log.nerrors != prevErrors ||
+                loopPassTwo ||
+                uninitsEntry.dup().diffSet(uninits).nextBit(firstadr) == -1)
+                break;
+            uninits = uninitsEntry.andSet(uninits);
+            loopPassTwo = true;
+            alive = true;
+        } while (true);
+        loopPassTwo = prevLoopPassTwo;
+        inits = initsCond;
+        uninits = uninitsCond;
+        alive = resolveBreaks(tree, prevPendingExits) ||
+            tree.cond != null && !tree.cond.type.isTrue();
+        nextadr = nextadrPrev;
+    }
 
-        public void visitForeachLoop(JCEnhancedForLoop tree) {
-            visitVarDef(tree.var);
+    public void visitForeachLoop(JCEnhancedForLoop tree) {
+        visitVarDef(tree.var);
 
-            ListBuffer<AssignPendingExit> prevPendingExits = pendingExits;
-            boolean prevLoopPassTwo = loopPassTwo;
-            int nextadrPrev = nextadr;
-            scan(tree.expr);
-            Bits initsStart = inits.dup();
-            Bits uninitsStart = uninits.dup();
-
-            letInit(tree.pos(), tree.var.sym);
-            pendingExits = new ListBuffer<AssignPendingExit>();
-            int prevErrors = log.nerrors;
-            do {
-                Bits uninitsEntry = uninits.dup();
-                uninitsEntry.excludeFrom(nextadr);
-                scan(tree.body);
-                resolveContinues(tree);
-                if (log.nerrors != prevErrors ||
-                    loopPassTwo ||
-                    uninitsEntry.dup().diffSet(uninits).nextBit(firstadr) == -1)
-                    break;
-                uninits = uninitsEntry.andSet(uninits);
-                loopPassTwo = true;
-            } while (true);
-            loopPassTwo = prevLoopPassTwo;
-            inits = initsStart;
-            uninits = uninitsStart.andSet(uninits);
-            resolveBreaks(tree, prevPendingExits);
-            nextadr = nextadrPrev;
-        }
+        ListBuffer<PendingExit> prevPendingExits = pendingExits;
+        boolean prevLoopPassTwo = loopPassTwo;
+        int nextadrPrev = nextadr;
+        scan(tree.expr);
+        Bits initsStart = inits.dup();
+        Bits uninitsStart = uninits.dup();
+
+        letInit(tree.pos(), tree.var.sym);
+        pendingExits = new ListBuffer<PendingExit>();
+        int prevErrors = log.nerrors;
+        do {
+            Bits uninitsEntry = uninits.dup();
+            uninitsEntry.excludeFrom(nextadr);
+            scanStat(tree.body);
+            alive |= resolveContinues(tree);
+            if (log.nerrors != prevErrors ||
+                loopPassTwo ||
+                uninitsEntry.dup().diffSet(uninits).nextBit(firstadr) == -1)
+                break;
+            uninits = uninitsEntry.andSet(uninits);
+            loopPassTwo = true;
+            alive = true;
+        } while (true);
+        loopPassTwo = prevLoopPassTwo;
+        inits = initsStart;
+        uninits = uninitsStart.andSet(uninits);
+        resolveBreaks(tree, prevPendingExits);
+        alive = true;
+        nextadr = nextadrPrev;
+    }
 
-        public void visitLabelled(JCLabeledStatement tree) {
-            ListBuffer<AssignPendingExit> prevPendingExits = pendingExits;
-            pendingExits = new ListBuffer<AssignPendingExit>();
-            scan(tree.body);
-            resolveBreaks(tree, prevPendingExits);
-        }
-
-        public void visitSwitch(JCSwitch tree) {
-            ListBuffer<AssignPendingExit> prevPendingExits = pendingExits;
-            pendingExits = new ListBuffer<AssignPendingExit>();
-            int nextadrPrev = nextadr;
-            scanExpr(tree.selector);
-            Bits initsSwitch = inits;
-            Bits uninitsSwitch = uninits.dup();
-            boolean hasDefault = false;
-            for (List<JCCase> l = tree.cases; l.nonEmpty(); l = l.tail) {
-                inits = initsSwitch.dup();
-                uninits = uninits.andSet(uninitsSwitch);
-                JCCase c = l.head;
-                if (c.pat == null)
-                    hasDefault = true;
-                else
-                    scanExpr(c.pat);
-                scan(c.stats);
-                addVars(c.stats, initsSwitch, uninitsSwitch);
-                // Warn about fall-through if lint switch fallthrough enabled.
-            }
-            if (!hasDefault) {
-                inits.andSet(initsSwitch);
-            }
-            resolveBreaks(tree, prevPendingExits);
-            nextadr = nextadrPrev;
+    public void visitLabelled(JCLabeledStatement tree) {
+        ListBuffer<PendingExit> prevPendingExits = pendingExits;
+        pendingExits = new ListBuffer<PendingExit>();
+        scanStat(tree.body);
+        alive |= resolveBreaks(tree, prevPendingExits);
+    }
+
+    public void visitSwitch(JCSwitch tree) {
+        ListBuffer<PendingExit> prevPendingExits = pendingExits;
+        pendingExits = new ListBuffer<PendingExit>();
+        int nextadrPrev = nextadr;
+        scanExpr(tree.selector);
+        Bits initsSwitch = inits;
+        Bits uninitsSwitch = uninits.dup();
+        boolean hasDefault = false;
+        for (List<JCCase> l = tree.cases; l.nonEmpty(); l = l.tail) {
+            alive = true;
+            inits = initsSwitch.dup();
+            uninits = uninits.andSet(uninitsSwitch);
+            JCCase c = l.head;
+            if (c.pat == null)
+                hasDefault = true;
+            else
+                scanExpr(c.pat);
+            scanStats(c.stats);
+            addVars(c.stats, initsSwitch, uninitsSwitch);
+            // Warn about fall-through if lint switch fallthrough enabled.
+            if (!loopPassTwo &&
+                alive &&
+                lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &&
+                c.stats.nonEmpty() && l.tail.nonEmpty())
+                log.warning(Lint.LintCategory.FALLTHROUGH,
+                            l.tail.head.pos(),
+                            "possible.fall-through.into.case");
         }
-        // where
-            /** Add any variables defined in stats to inits and uninits. */
-            private void addVars(List<JCStatement> stats, Bits inits,
-                                        Bits uninits) {
-                for (;stats.nonEmpty(); stats = stats.tail) {
-                    JCTree stat = stats.head;
-                    if (stat.hasTag(VARDEF)) {
-                        int adr = ((JCVariableDecl) stat).sym.adr;
-                        inits.excl(adr);
-                        uninits.incl(adr);
-                    }
+        if (!hasDefault) {
+            inits.andSet(initsSwitch);
+            alive = true;
+        }
+        alive |= resolveBreaks(tree, prevPendingExits);
+        nextadr = nextadrPrev;
+    }
+    // where
+        /** Add any variables defined in stats to inits and uninits. */
+        private static void addVars(List<JCStatement> stats, Bits inits,
+                                    Bits uninits) {
+            for (;stats.nonEmpty(); stats = stats.tail) {
+                JCTree stat = stats.head;
+                if (stat.getTag() == JCTree.VARDEF) {
+                    int adr = ((JCVariableDecl) stat).sym.adr;
+                    inits.excl(adr);
+                    uninits.incl(adr);
                 }
             }
+        }
 
-        public void visitTry(JCTry tree) {
-            ListBuffer<JCVariableDecl> resourceVarDecls = ListBuffer.lb();
-            Bits uninitsTryPrev = uninitsTry;
-            ListBuffer<AssignPendingExit> prevPendingExits = pendingExits;
-            pendingExits = new ListBuffer<AssignPendingExit>();
-            Bits initsTry = inits.dup();
-            uninitsTry = uninits.dup();
-            for (JCTree resource : tree.resources) {
-                if (resource instanceof JCVariableDecl) {
-                    JCVariableDecl vdecl = (JCVariableDecl) resource;
-                    visitVarDef(vdecl);
-                    unrefdResources.enter(vdecl.sym);
-                    resourceVarDecls.append(vdecl);
-                } else if (resource instanceof JCExpression) {
-                    scanExpr((JCExpression) resource);
-                } else {
-                    throw new AssertionError(tree);  // parser error
-                }
+    public void visitTry(JCTry tree) {
+        List<Type> caughtPrev = caught;
+        List<Type> thrownPrev = thrown;
+        thrown = List.nil();
+        for (List<JCCatch> l = tree.catchers; l.nonEmpty(); l = l.tail) {
+            List<JCExpression> subClauses = TreeInfo.isMultiCatch(l.head) ?
+                    ((JCTypeUnion)l.head.param.vartype).alternatives :
+                    List.of(l.head.param.vartype);
+            for (JCExpression ct : subClauses) {
+                caught = chk.incl(ct.type, caught);
+            }
+        }
+        ListBuffer<JCVariableDecl> resourceVarDecls = ListBuffer.lb();
+        Bits uninitsTryPrev = uninitsTry;
+        ListBuffer<PendingExit> prevPendingExits = pendingExits;
+        pendingExits = new ListBuffer<PendingExit>();
+        Bits initsTry = inits.dup();
+        uninitsTry = uninits.dup();
+        for (JCTree resource : tree.resources) {
+            if (resource instanceof JCVariableDecl) {
+                JCVariableDecl vdecl = (JCVariableDecl) resource;
+                visitVarDef(vdecl);
+                unrefdResources.enter(vdecl.sym);
+                resourceVarDecls.append(vdecl);
+            } else if (resource instanceof JCExpression) {
+                scanExpr((JCExpression) resource);
+            } else {
+                throw new AssertionError(tree);  // parser error
             }
-            scan(tree.body);
-            uninitsTry.andSet(uninits);
-            Bits initsEnd = inits;
-            Bits uninitsEnd = uninits;
-            int nextadrCatch = nextadr;
-
-            if (!resourceVarDecls.isEmpty() &&
-                    lint.isEnabled(Lint.LintCategory.TRY)) {
-                for (JCVariableDecl resVar : resourceVarDecls) {
-                    if (unrefdResources.includes(resVar.sym)) {
-                        log.warning(Lint.LintCategory.TRY, resVar.pos(),
-                                    "try.resource.not.referenced", resVar.sym);
-                        unrefdResources.remove(resVar.sym);
+        }
+        for (JCTree resource : tree.resources) {
+            List<Type> closeableSupertypes = resource.type.isCompound() ?
+                types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
+                List.of(resource.type);
+            for (Type sup : closeableSupertypes) {
+                if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {
+                    Symbol closeMethod = rs.resolveQualifiedMethod(tree,
+                            attrEnv,
+                            sup,
+                            names.close,
+                            List.<Type>nil(),
+                            List.<Type>nil());
+                    if (closeMethod.kind == MTH) {
+                        for (Type t : ((MethodSymbol)closeMethod).getThrownTypes()) {
+                            markThrown(resource, t);
+                        }
                     }
                 }
             }
-
-            for (List<JCCatch> l = tree.catchers; l.nonEmpty(); l = l.tail) {
-                JCVariableDecl param = l.head.param;
-                inits = initsTry.dup();
-                uninits = uninitsTry.dup();
-                scan(param);
-                inits.incl(param.sym.adr);
-                uninits.excl(param.sym.adr);
-                scan(l.head.body);
-                initsEnd.andSet(inits);
-                uninitsEnd.andSet(uninits);
-                nextadr = nextadrCatch;
-            }
-            if (tree.finalizer != null) {
-                inits = initsTry.dup();
-                uninits = uninitsTry.dup();
-                ListBuffer<AssignPendingExit> exits = pendingExits;
-                pendingExits = prevPendingExits;
-                scan(tree.finalizer);
-                if (!tree.finallyCanCompleteNormally) {
-                    // discard exits and exceptions from try and finally
-                } else {
-                    uninits.andSet(uninitsEnd);
-                    // FIX: this doesn't preserve source order of exits in catch
-                    // versus finally!
-                    while (exits.nonEmpty()) {
-                        AssignPendingExit exit = exits.next();
-                        if (exit.exit_inits != null) {
-                            exit.exit_inits.orSet(inits);
-                            exit.exit_uninits.andSet(uninits);
-                        }
-                        pendingExits.append(exit);
-                    }
-                    inits.orSet(initsEnd);
+        }
+        scanStat(tree.body);
+        List<Type> thrownInTry = allowImprovedCatchAnalysis ?
+            chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType)) :
+            thrown;
+        thrown = thrownPrev;
+        caught = caughtPrev;
+        boolean aliveEnd = alive;
+        uninitsTry.andSet(uninits);
+        Bits initsEnd = inits;
+        Bits uninitsEnd = uninits;
+        int nextadrCatch = nextadr;
+
+        if (!resourceVarDecls.isEmpty() &&
+                lint.isEnabled(Lint.LintCategory.TRY)) {
+            for (JCVariableDecl resVar : resourceVarDecls) {
+                if (unrefdResources.includes(resVar.sym)) {
+                    log.warning(Lint.LintCategory.TRY, resVar.pos(),
+                                "try.resource.not.referenced", resVar.sym);
+                    unrefdResources.remove(resVar.sym);
                 }
-            } else {
-                inits = initsEnd;
-                uninits = uninitsEnd;
-                ListBuffer<AssignPendingExit> exits = pendingExits;
-                pendingExits = prevPendingExits;
-                while (exits.nonEmpty()) pendingExits.append(exits.next());
             }
-            uninitsTry.andSet(uninitsTryPrev).andSet(uninits);
         }
 
-        public void visitConditional(JCConditional tree) {
-            scanCond(tree.cond);
-            Bits initsBeforeElse = initsWhenFalse;
-            Bits uninitsBeforeElse = uninitsWhenFalse;
-            inits = initsWhenTrue;
-            uninits = uninitsWhenTrue;
-            if (tree.truepart.type.tag == BOOLEAN &&
-                tree.falsepart.type.tag == BOOLEAN) {
-                // if b and c are boolean valued, then
-                // v is (un)assigned after a?b:c when true iff
-                //    v is (un)assigned after b when true and
-                //    v is (un)assigned after c when true
-                scanCond(tree.truepart);
-                Bits initsAfterThenWhenTrue = initsWhenTrue.dup();
-                Bits initsAfterThenWhenFalse = initsWhenFalse.dup();
-                Bits uninitsAfterThenWhenTrue = uninitsWhenTrue.dup();
-                Bits uninitsAfterThenWhenFalse = uninitsWhenFalse.dup();
-                inits = initsBeforeElse;
-                uninits = uninitsBeforeElse;
-                scanCond(tree.falsepart);
-                initsWhenTrue.andSet(initsAfterThenWhenTrue);
-                initsWhenFalse.andSet(initsAfterThenWhenFalse);
-                uninitsWhenTrue.andSet(uninitsAfterThenWhenTrue);
-                uninitsWhenFalse.andSet(uninitsAfterThenWhenFalse);
+        List<Type> caughtInTry = List.nil();
+        for (List<JCCatch> l = tree.catchers; l.nonEmpty(); l = l.tail) {
+            alive = true;
+            JCVariableDecl param = l.head.param;
+            List<JCExpression> subClauses = TreeInfo.isMultiCatch(l.head) ?
+                    ((JCTypeUnion)l.head.param.vartype).alternatives :
+                    List.of(l.head.param.vartype);
+            List<Type> ctypes = List.nil();
+            List<Type> rethrownTypes = chk.diff(thrownInTry, caughtInTry);
+            for (JCExpression ct : subClauses) {
+                Type exc = ct.type;
+                if (exc != syms.unknownType) {
+                    ctypes = ctypes.append(exc);
+                    if (types.isSameType(exc, syms.objectType))
+                        continue;
+                    checkCaughtType(l.head.pos(), exc, thrownInTry, caughtInTry);
+                    caughtInTry = chk.incl(exc, caughtInTry);
+                }
+            }
+            inits = initsTry.dup();
+            uninits = uninitsTry.dup();
+            scan(param);
+            inits.incl(param.sym.adr);
+            uninits.excl(param.sym.adr);
+            preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
+            scanStat(l.head.body);
+            initsEnd.andSet(inits);
+            uninitsEnd.andSet(uninits);
+            nextadr = nextadrCatch;
+            preciseRethrowTypes.remove(param.sym);
+            aliveEnd |= alive;
+        }
+        if (tree.finalizer != null) {
+            List<Type> savedThrown = thrown;
+            thrown = List.nil();
+            inits = initsTry.dup();
+            uninits = uninitsTry.dup();
+            ListBuffer<PendingExit> exits = pendingExits;
+            pendingExits = prevPendingExits;
+            alive = true;
+            scanStat(tree.finalizer);
+            if (!alive) {
+                // discard exits and exceptions from try and finally
+                thrown = chk.union(thrown, thrownPrev);
+                if (!loopPassTwo &&
+                    lint.isEnabled(Lint.LintCategory.FINALLY)) {
+                    log.warning(Lint.LintCategory.FINALLY,
+                            TreeInfo.diagEndPos(tree.finalizer),
+                            "finally.cannot.complete");
+                }
             } else {
-                scanExpr(tree.truepart);
-                Bits initsAfterThen = inits.dup();
-                Bits uninitsAfterThen = uninits.dup();
-                inits = initsBeforeElse;
-                uninits = uninitsBeforeElse;
-                scanExpr(tree.falsepart);
-                inits.andSet(initsAfterThen);
-                uninits.andSet(uninitsAfterThen);
+                thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
+                thrown = chk.union(thrown, savedThrown);
+                uninits.andSet(uninitsEnd);
+                // FIX: this doesn't preserve source order of exits in catch
+                // versus finally!
+                while (exits.nonEmpty()) {
+                    PendingExit exit = exits.next();
+                    if (exit.inits != null) {
+                        exit.inits.orSet(inits);
+                        exit.uninits.andSet(uninits);
+                    }
+                    pendingExits.append(exit);
+                }
+                inits.orSet(initsEnd);
+                alive = aliveEnd;
             }
+        } else {
+            thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
+            inits = initsEnd;
+            uninits = uninitsEnd;
+            alive = aliveEnd;
+            ListBuffer<PendingExit> exits = pendingExits;
+            pendingExits = prevPendingExits;
+            while (exits.nonEmpty()) pendingExits.append(exits.next());
         }
+        uninitsTry.andSet(uninitsTryPrev).andSet(uninits);
+    }
 
-        public void visitIf(JCIf tree) {
-            scanCond(tree.cond);
-            Bits initsBeforeElse = initsWhenFalse;
-            Bits uninitsBeforeElse = uninitsWhenFalse;
-            inits = initsWhenTrue;
-            uninits = uninitsWhenTrue;
-            scan(tree.thenpart);
-            if (tree.elsepart != null) {
-                Bits initsAfterThen = inits.dup();
-                Bits uninitsAfterThen = uninits.dup();
-                inits = initsBeforeElse;
-                uninits = uninitsBeforeElse;
-                scan(tree.elsepart);
-                inits.andSet(initsAfterThen);
-                uninits.andSet(uninitsAfterThen);
-            } else {
-                inits.andSet(initsBeforeElse);
-                uninits.andSet(uninitsBeforeElse);
+    void checkCaughtType(DiagnosticPosition pos, Type exc, List<Type> thrownInTry, List<Type> caughtInTry) {
+        if (chk.subset(exc, caughtInTry)) {
+            log.error(pos, "except.already.caught", exc);
+        } else if (!chk.isUnchecked(pos, exc) &&
+                !isExceptionOrThrowable(exc) &&
+                !chk.intersects(exc, thrownInTry)) {
+            log.error(pos, "except.never.thrown.in.try", exc);
+        } else if (allowImprovedCatchAnalysis) {
+            List<Type> catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
+            // 'catchableThrownTypes' cannnot possibly be empty - if 'exc' was an
+            // unchecked exception, the result list would not be empty, as the augmented
+            // thrown set includes { RuntimeException, Error }; if 'exc' was a checked
+            // exception, that would have been covered in the branch above
+            if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &&
+                    !isExceptionOrThrowable(exc)) {
+                String key = catchableThrownTypes.length() == 1 ?
+                        "unreachable.catch" :
+                        "unreachable.catch.1";
+                log.warning(pos, key, catchableThrownTypes);
             }
         }
-
-        public void visitBreak(JCBreak tree) {
-            recordExit(tree, new AssignPendingExit(tree, inits, uninits));
+    }
+    //where
+        private boolean isExceptionOrThrowable(Type exc) {
+            return exc.tsym == syms.throwableType.tsym ||
+                exc.tsym == syms.exceptionType.tsym;
         }
 
-        public void visitContinue(JCContinue tree) {
-            recordExit(tree, new AssignPendingExit(tree, inits, uninits));
-        }
 
-        public void visitReturn(JCReturn tree) {
-            scanExpr(tree.expr);
-            // if not initial constructor, should markDead instead of recordExit
-            recordExit(tree, new AssignPendingExit(tree, inits, uninits));
+    public void visitConditional(JCConditional tree) {
+        scanCond(tree.cond);
+        Bits initsBeforeElse = initsWhenFalse;
+        Bits uninitsBeforeElse = uninitsWhenFalse;
+        inits = initsWhenTrue;
+        uninits = uninitsWhenTrue;
+        if (tree.truepart.type.tag == BOOLEAN &&
+            tree.falsepart.type.tag == BOOLEAN) {
+            // if b and c are boolean valued, then
+            // v is (un)assigned after a?b:c when true iff
+            //    v is (un)assigned after b when true and
+            //    v is (un)assigned after c when true
+            scanCond(tree.truepart);
+            Bits initsAfterThenWhenTrue = initsWhenTrue.dup();
+            Bits initsAfterThenWhenFalse = initsWhenFalse.dup();
+            Bits uninitsAfterThenWhenTrue = uninitsWhenTrue.dup();
+            Bits uninitsAfterThenWhenFalse = uninitsWhenFalse.dup();
+            inits = initsBeforeElse;
+            uninits = uninitsBeforeElse;
+            scanCond(tree.falsepart);
+            initsWhenTrue.andSet(initsAfterThenWhenTrue);
+            initsWhenFalse.andSet(initsAfterThenWhenFalse);
+            uninitsWhenTrue.andSet(uninitsAfterThenWhenTrue);
+            uninitsWhenFalse.andSet(uninitsAfterThenWhenFalse);
+        } else {
+            scanExpr(tree.truepart);
+            Bits initsAfterThen = inits.dup();
+            Bits uninitsAfterThen = uninits.dup();
+            inits = initsBeforeElse;
+            uninits = uninitsBeforeElse;
+            scanExpr(tree.falsepart);
+            inits.andSet(initsAfterThen);
+            uninits.andSet(uninitsAfterThen);
         }
+    }
 
-        public void visitThrow(JCThrow tree) {
-            scanExpr(tree.expr);
-            markDead();
+    public void visitIf(JCIf tree) {
+        scanCond(tree.cond);
+        Bits initsBeforeElse = initsWhenFalse;
+        Bits uninitsBeforeElse = uninitsWhenFalse;
+        inits = initsWhenTrue;
+        uninits = uninitsWhenTrue;
+        scanStat(tree.thenpart);
+        if (tree.elsepart != null) {
+            boolean aliveAfterThen = alive;
+            alive = true;
+            Bits initsAfterThen = inits.dup();
+            Bits uninitsAfterThen = uninits.dup();
+            inits = initsBeforeElse;
+            uninits = uninitsBeforeElse;
+            scanStat(tree.elsepart);
+            inits.andSet(initsAfterThen);
+            uninits.andSet(uninitsAfterThen);
+            alive = alive | aliveAfterThen;
+        } else {
+            inits.andSet(initsBeforeElse);
+            uninits.andSet(uninitsBeforeElse);
+            alive = true;
         }
+    }
+
+
 
-        public void visitApply(JCMethodInvocation tree) {
-            scanExpr(tree.meth);
-            scanExprs(tree.args);
+    public void visitBreak(JCBreak tree) {
+        recordExit(tree);
+    }
+
+    public void visitContinue(JCContinue tree) {
+        recordExit(tree);
+    }
+
+    public void visitReturn(JCReturn tree) {
+        scanExpr(tree.expr);
+        // if not initial constructor, should markDead instead of recordExit
+        recordExit(tree);
+    }
+
+    public void visitThrow(JCThrow tree) {
+        scanExpr(tree.expr);
+        Symbol sym = TreeInfo.symbol(tree.expr);
+        if (sym != null &&
+            sym.kind == VAR &&
+            (sym.flags() & (FINAL | EFFECTIVELY_FINAL)) != 0 &&
+            preciseRethrowTypes.get(sym) != null &&
+            allowImprovedRethrowAnalysis) {
+            for (Type t : preciseRethrowTypes.get(sym)) {
+                markThrown(tree, t);
+            }
         }
+        else {
+            markThrown(tree, tree.expr.type);
+        }
+        markDead();
+    }
+
+    public void visitApply(JCMethodInvocation tree) {
+        scanExpr(tree.meth);
+        scanExprs(tree.args);
+        for (List<Type> l = tree.meth.type.getThrownTypes(); l.nonEmpty(); l = l.tail)
+            markThrown(tree, l.head);
+    }
 
-        public void visitNewClass(JCNewClass tree) {
-            scanExpr(tree.encl);
-            scanExprs(tree.args);
+    public void visitNewClass(JCNewClass tree) {
+        scanExpr(tree.encl);
+        scanExprs(tree.args);
+       // scan(tree.def);
+        for (List<Type> l = tree.constructorType.getThrownTypes();
+             l.nonEmpty();
+             l = l.tail) {
+            markThrown(tree, l.head);
+        }
+        List<Type> caughtPrev = caught;
+        try {
+            // If the new class expression defines an anonymous class,
+            // analysis of the anonymous constructor may encounter thrown
+            // types which are unsubstituted type variables.
+            // However, since the constructor's actual thrown types have
+            // already been marked as thrown, it is safe to simply include
+            // each of the constructor's formal thrown types in the set of
+            // 'caught/declared to be thrown' types, for the duration of
+            // the class def analysis.
+            if (tree.def != null)
+                for (List<Type> l = tree.constructor.type.getThrownTypes();
+                     l.nonEmpty();
+                     l = l.tail) {
+                    caught = chk.incl(l.head, caught);
+                }
             scan(tree.def);
         }
-
-        public void visitNewArray(JCNewArray tree) {
-            scanExprs(tree.dims);
-            scanExprs(tree.elems);
+        finally {
+            caught = caughtPrev;
         }
+    }
 
-        public void visitAssert(JCAssert tree) {
-            Bits initsExit = inits.dup();
-            Bits uninitsExit = uninits.dup();
-            scanCond(tree.cond);
-            uninitsExit.andSet(uninitsWhenTrue);
-            if (tree.detail != null) {
-                inits = initsWhenFalse;
-                uninits = uninitsWhenFalse;
-                scanExpr(tree.detail);
-            }
-            inits = initsExit;
-            uninits = uninitsExit;
+    public void visitNewArray(JCNewArray tree) {
+        scanExprs(tree.dims);
+        scanExprs(tree.elems);
+    }
+
+    public void visitAssert(JCAssert tree) {
+        Bits initsExit = inits.dup();
+        Bits uninitsExit = uninits.dup();
+        scanCond(tree.cond);
+        uninitsExit.andSet(uninitsWhenTrue);
+        if (tree.detail != null) {
+            inits = initsWhenFalse;
+            uninits = uninitsWhenFalse;
+            scanExpr(tree.detail);
         }
+        inits = initsExit;
+        uninits = uninitsExit;
+    }
 
-        public void visitAssign(JCAssign tree) {
-            JCTree lhs = TreeInfo.skipParens(tree.lhs);
-            if (!(lhs instanceof JCIdent)) scanExpr(lhs);
-            scanExpr(tree.rhs);
-            letInit(lhs);
+    public void visitAssign(JCAssign tree) {
+        JCTree lhs = TreeInfo.skipParens(tree.lhs);
+        if (!(lhs instanceof JCIdent)) scanExpr(lhs);
+        scanExpr(tree.rhs);
+        letInit(lhs);
+    }
+
+    public void visitAssignop(JCAssignOp tree) {
+        scanExpr(tree.lhs);
+        scanExpr(tree.rhs);
+        letInit(tree.lhs);
+    }
+
+    public void visitUnary(JCUnary tree) {
+        switch (tree.getTag()) {
+        case JCTree.NOT:
+            scanCond(tree.arg);
+            Bits t = initsWhenFalse;
+            initsWhenFalse = initsWhenTrue;
+            initsWhenTrue = t;
+            t = uninitsWhenFalse;
+            uninitsWhenFalse = uninitsWhenTrue;
+            uninitsWhenTrue = t;
+            break;
+        case JCTree.PREINC: case JCTree.POSTINC:
+        case JCTree.PREDEC: case JCTree.POSTDEC:
+            scanExpr(tree.arg);
+            letInit(tree.arg);
+            break;
+        default:
+            scanExpr(tree.arg);
         }
+    }
 
-        public void visitAssignop(JCAssignOp tree) {
+    public void visitBinary(JCBinary tree) {
+        switch (tree.getTag()) {
+        case JCTree.AND:
+            scanCond(tree.lhs);
+            Bits initsWhenFalseLeft = initsWhenFalse;
+            Bits uninitsWhenFalseLeft = uninitsWhenFalse;
+            inits = initsWhenTrue;
+            uninits = uninitsWhenTrue;
+            scanCond(tree.rhs);
+            initsWhenFalse.andSet(initsWhenFalseLeft);
+            uninitsWhenFalse.andSet(uninitsWhenFalseLeft);
+            break;
+        case JCTree.OR:
+            scanCond(tree.lhs);
+            Bits initsWhenTrueLeft = initsWhenTrue;
+            Bits uninitsWhenTrueLeft = uninitsWhenTrue;
+            inits = initsWhenFalse;
+            uninits = uninitsWhenFalse;
+            scanCond(tree.rhs);
+            initsWhenTrue.andSet(initsWhenTrueLeft);
+            uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
+            break;
+        default:
             scanExpr(tree.lhs);
             scanExpr(tree.rhs);
-            letInit(tree.lhs);
         }
+    }
 
-        public void visitUnary(JCUnary tree) {
-            switch (tree.getTag()) {
-            case NOT:
-                scanCond(tree.arg);
-                Bits t = initsWhenFalse;
-                initsWhenFalse = initsWhenTrue;
-                initsWhenTrue = t;
-                t = uninitsWhenFalse;
-                uninitsWhenFalse = uninitsWhenTrue;
-                uninitsWhenTrue = t;
-                break;
-            case PREINC: case POSTINC:
-            case PREDEC: case POSTDEC:
-                scanExpr(tree.arg);
-                letInit(tree.arg);
-                break;
-            default:
-                scanExpr(tree.arg);
-            }
+    public void visitIdent(JCIdent tree) {
+        if (tree.sym.kind == VAR) {
+            checkInit(tree.pos(), (VarSymbol)tree.sym);
+            referenced(tree.sym);
         }
+    }
 
-        public void visitBinary(JCBinary tree) {
-            switch (tree.getTag()) {
-            case AND:
-                scanCond(tree.lhs);
-                Bits initsWhenFalseLeft = initsWhenFalse;
-                Bits uninitsWhenFalseLeft = uninitsWhenFalse;
-                inits = initsWhenTrue;
-                uninits = uninitsWhenTrue;
-                scanCond(tree.rhs);
-                initsWhenFalse.andSet(initsWhenFalseLeft);
-                uninitsWhenFalse.andSet(uninitsWhenFalseLeft);
-                break;
-            case OR:
-                scanCond(tree.lhs);
-                Bits initsWhenTrueLeft = initsWhenTrue;
-                Bits uninitsWhenTrueLeft = uninitsWhenTrue;
-                inits = initsWhenFalse;
-                uninits = uninitsWhenFalse;
-                scanCond(tree.rhs);
-                initsWhenTrue.andSet(initsWhenTrueLeft);
-                uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
-                break;
-            default:
-                scanExpr(tree.lhs);
-                scanExpr(tree.rhs);
-            }
-        }
+    void referenced(Symbol sym) {
+        unrefdResources.remove(sym);
+    }
 
-        public void visitIdent(JCIdent tree) {
-            if (tree.sym.kind == VAR) {
-                checkInit(tree.pos(), (VarSymbol)tree.sym);
-                referenced(tree.sym);
+    public void visitTypeCast(JCTypeCast tree) {
+        super.visitTypeCast(tree);
+        if (!tree.type.isErroneous()
+            && lint.isEnabled(Lint.LintCategory.CAST)
+            && types.isSameType(tree.expr.type, tree.clazz.type)
+            && !is292targetTypeCast(tree)) {
+            log.warning(Lint.LintCategory.CAST,
+                    tree.pos(), "redundant.cast", tree.expr.type);
+        }
+    }
+    //where
+        private boolean is292targetTypeCast(JCTypeCast tree) {
+            boolean is292targetTypeCast = false;
+            JCExpression expr = TreeInfo.skipParens(tree.expr);
+            if (expr.getTag() == JCTree.APPLY) {
+                JCMethodInvocation apply = (JCMethodInvocation)expr;
+                Symbol sym = TreeInfo.symbol(apply.meth);
+                is292targetTypeCast = sym != null &&
+                    sym.kind == MTH &&
+                    (sym.flags() & POLYMORPHIC_SIGNATURE) != 0;
             }
+            return is292targetTypeCast;
         }
 
-        void referenced(Symbol sym) {
-            unrefdResources.remove(sym);
-        }
-
-        public void visitTopLevel(JCCompilationUnit tree) {
-            // Do nothing for TopLevel since each class is visited individually
-        }
-
-    /**************************************************************************
-     * main method
-     *************************************************************************/
-
-        /** Perform definite assignment/unassignment analysis on a tree.
-         */
-        public void analyzeTree(Env<AttrContext> env, TreeMaker make) {
-            try {
-                attrEnv = env;
-                JCTree tree = env.tree;
-                Flow.this.make = make;
-                inits = new Bits();
-                uninits = new Bits();
-                uninitsTry = new Bits();
-                initsWhenTrue = initsWhenFalse =
-                    uninitsWhenTrue = uninitsWhenFalse = null;
-                if (vars == null)
-                    vars = new VarSymbol[32];
-                else
-                    for (int i=0; i<vars.length; i++)
-                        vars[i] = null;
-                firstadr = 0;
-                nextadr = 0;
-                pendingExits = new ListBuffer<AssignPendingExit>();
-                this.classDef = null;
-                unrefdResources = new Scope(env.enclClass.sym);
-                scan(tree);
-            } finally {
-                // note that recursive invocations of this method fail hard
-                inits = uninits = uninitsTry = null;
-                initsWhenTrue = initsWhenFalse =
-                    uninitsWhenTrue = uninitsWhenFalse = null;
-                if (vars != null) for (int i=0; i<vars.length; i++)
+    public void visitTopLevel(JCCompilationUnit tree) {
+        // Do nothing for TopLevel since each class is visited individually
+    }
+
+/**************************************************************************
+ * main method
+ *************************************************************************/
+
+    /** Perform definite assignment/unassignment analysis on a tree.
+     */
+    public void analyzeTree(Env<AttrContext> env, TreeMaker make) {
+        try {
+            attrEnv = env;
+            JCTree tree = env.tree;
+            this.make = make;
+            inits = new Bits();
+            uninits = new Bits();
+            uninitsTry = new Bits();
+            initsWhenTrue = initsWhenFalse =
+                uninitsWhenTrue = uninitsWhenFalse = null;
+            if (vars == null)
+                vars = new VarSymbol[32];
+            else
+                for (int i=0; i<vars.length; i++)
                     vars[i] = null;
-                firstadr = 0;
-                nextadr = 0;
-                pendingExits = null;
-                Flow.this.make = null;
-                this.classDef = null;
-                unrefdResources = null;
-            }
+            firstadr = 0;
+            nextadr = 0;
+            pendingExits = new ListBuffer<PendingExit>();
+            preciseRethrowTypes = new HashMap<Symbol, List<Type>>();
+            alive = true;
+            this.thrown = this.caught = null;
+            this.classDef = null;
+            unrefdResources = new Scope(env.enclClass.sym);
+            scan(tree);
+        } finally {
+            // note that recursive invocations of this method fail hard
+            inits = uninits = uninitsTry = null;
+            initsWhenTrue = initsWhenFalse =
+                uninitsWhenTrue = uninitsWhenFalse = null;
+            if (vars != null) for (int i=0; i<vars.length; i++)
+                vars[i] = null;
+            firstadr = 0;
+            nextadr = 0;
+            pendingExits = null;
+            this.make = null;
+            this.thrown = this.caught = null;
+            this.classDef = null;
+            unrefdResources = null;
         }
     }
 }
diff -u -r javac/comp/Infer.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Infer.java
--- javac/comp/Infer.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Infer.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,10 +32,9 @@
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.code.Type.*;
+import com.sun.tools.javac.code.Type.ForAll.ConstraintKind;
 import com.sun.tools.javac.code.Symbol.*;
-import com.sun.tools.javac.comp.Resolve.InapplicableMethodException;
-import com.sun.tools.javac.comp.Resolve.VerboseResolutionMode;
-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
+import com.sun.tools.javac.util.JCDiagnostic;
 
 import static com.sun.tools.javac.code.TypeTags.*;
 
@@ -57,7 +56,6 @@
     Types types;
     Check chk;
     Resolve rs;
-    Log log;
     JCDiagnostic.Factory diags;
 
     public static Infer instance(Context context) {
@@ -72,7 +70,6 @@
         syms = Symtab.instance(context);
         types = Types.instance(context);
         rs = Resolve.instance(context);
-        log = Log.instance(context);
         chk = Check.instance(context);
         diags = JCDiagnostic.Factory.instance(context);
         ambiguousNoInstanceException =
@@ -84,7 +81,7 @@
 
     }
 
-    public static class InferenceException extends InapplicableMethodException {
+    public static class InferenceException extends Resolve.InapplicableMethodException {
         private static final long serialVersionUID = 0;
 
         InferenceException(JCDiagnostic.Factory diags) {
@@ -121,21 +118,84 @@
 
     /** A mapping that turns type variables into undetermined type variables.
      */
-    List<Type> makeUndetvars(List<Type> tvars) {
-        List<Type> undetvars = Type.map(tvars, fromTypeVarFun);
-        for (Type t : undetvars) {
-            UndetVar uv = (UndetVar)t;
-            uv.hibounds = types.getBounds((TypeVar)uv.qtype);
-        }
-        return undetvars;
-    }
-    //where
-            Mapping fromTypeVarFun = new Mapping("fromTypeVarFun") {
-                public Type apply(Type t) {
-                    if (t.tag == TYPEVAR) return new UndetVar(t);
-                    else return t.map(this);
+    Mapping fromTypeVarFun = new Mapping("fromTypeVarFun") {
+            public Type apply(Type t) {
+                if (t.tag == TYPEVAR) return new UndetVar(t);
+                else return t.map(this);
+            }
+        };
+
+    /** A mapping that returns its type argument with every UndetVar replaced
+     *  by its `inst' field. Throws a NoInstanceException
+     *  if this not possible because an `inst' field is null.
+     *  Note: mutually referring undertvars will be left uninstantiated
+     *  (that is, they will be replaced by the underlying type-variable).
+     */
+
+    Mapping getInstFun = new Mapping("getInstFun") {
+            public Type apply(Type t) {
+                switch (t.tag) {
+                    case UNKNOWN:
+                        throw ambiguousNoInstanceException
+                            .setMessage("undetermined.type");
+                    case UNDETVAR:
+                        UndetVar that = (UndetVar) t;
+                        if (that.inst == null)
+                            throw ambiguousNoInstanceException
+                                .setMessage("type.variable.has.undetermined.type",
+                                            that.qtype);
+                        return isConstraintCyclic(that) ?
+                            that.qtype :
+                            apply(that.inst);
+                        default:
+                            return t.map(this);
                 }
-            };
+            }
+
+            private boolean isConstraintCyclic(UndetVar uv) {
+                Types.UnaryVisitor<Boolean> constraintScanner =
+                        new Types.UnaryVisitor<Boolean>() {
+
+                    List<Type> seen = List.nil();
+
+                    Boolean visit(List<Type> ts) {
+                        for (Type t : ts) {
+                            if (visit(t)) return true;
+                        }
+                        return false;
+                    }
+
+                    public Boolean visitType(Type t, Void ignored) {
+                        return false;
+                    }
+
+                    @Override
+                    public Boolean visitClassType(ClassType t, Void ignored) {
+                        if (t.isCompound()) {
+                            return visit(types.supertype(t)) ||
+                                    visit(types.interfaces(t));
+                        } else {
+                            return visit(t.getTypeArguments());
+                        }
+                    }
+                    @Override
+                    public Boolean visitWildcardType(WildcardType t, Void ignored) {
+                        return visit(t.type);
+                    }
+
+                    @Override
+                    public Boolean visitUndetVar(UndetVar t, Void ignored) {
+                        if (seen.contains(t)) {
+                            return true;
+                        } else {
+                            seen = seen.prepend(t);
+                            return visit(t.inst);
+                        }
+                    }
+                };
+                return constraintScanner.visit(uv);
+            }
+        };
 
 /***************************************************************************
  * Mini/Maximization of UndetVars
@@ -146,15 +206,13 @@
      */
     void maximizeInst(UndetVar that, Warner warn) throws NoInstanceException {
         List<Type> hibounds = Type.filter(that.hibounds, errorFilter);
-        if (that.eq.isEmpty()) {
+        if (that.inst == null) {
             if (hibounds.isEmpty())
                 that.inst = syms.objectType;
             else if (hibounds.tail.isEmpty())
                 that.inst = hibounds.head;
             else
                 that.inst = types.glb(hibounds);
-        } else {
-            that.inst = that.eq.head;
         }
         if (that.inst == null ||
             that.inst.isErroneous())
@@ -162,6 +220,27 @@
                 .setMessage("no.unique.maximal.instance.exists",
                             that.qtype, hibounds);
     }
+    //where
+        private boolean isSubClass(Type t, final List<Type> ts) {
+            t = t.baseType();
+            if (t.tag == TYPEVAR) {
+                List<Type> bounds = types.getBounds((TypeVar)t);
+                for (Type s : ts) {
+                    if (!types.isSameType(t, s.baseType())) {
+                        for (Type bound : bounds) {
+                            if (!isSubClass(bound, List.of(s.baseType())))
+                                return false;
+                        }
+                    }
+                }
+            } else {
+                for (Type s : ts) {
+                    if (!t.tsym.isSubClass(s.baseType().tsym, types))
+                        return false;
+                }
+            }
+            return true;
+        }
 
     private Filter<Type> errorFilter = new Filter<Type>() {
         @Override
@@ -175,7 +254,7 @@
      */
     void minimizeInst(UndetVar that, Warner warn) throws NoInstanceException {
         List<Type> lobounds = Type.filter(that.lobounds, errorFilter);
-        if (that.eq.isEmpty()) {
+        if (that.inst == null) {
             if (lobounds.isEmpty())
                 that.inst = syms.botType;
             else if (lobounds.tail.isEmpty())
@@ -187,21 +266,25 @@
                     throw ambiguousNoInstanceException
                         .setMessage("no.unique.minimal.instance.exists",
                                     that.qtype, lobounds);
-        } else {
-            that.inst = that.eq.head;
-        }
-    }
-
-    Type asUndetType(Type t, List<Type> undetvars) {
-        return types.subst(t, inferenceVars(undetvars), undetvars);
-    }
-
-    List<Type> inferenceVars(List<Type> undetvars) {
-        ListBuffer<Type> tvars = ListBuffer.lb();
-        for (Type uv : undetvars) {
-            tvars.append(((UndetVar)uv).qtype);
+            // VGJ: sort of inlined maximizeInst() below.  Adding
+            // bounds can cause lobounds that are above hibounds.
+            List<Type> hibounds = Type.filter(that.hibounds, errorFilter);
+            if (hibounds.isEmpty())
+                return;
+            Type hb = null;
+            if (hibounds.tail.isEmpty())
+                hb = hibounds.head;
+            else for (List<Type> bs = hibounds;
+                      bs.nonEmpty() && hb == null;
+                      bs = bs.tail) {
+                if (isSubClass(bs.head, hibounds))
+                    hb = types.fromUnknownFun.apply(bs.head);
+            }
+            if (hb == null ||
+                !types.isSubtypeUnchecked(hb, hibounds, warn) ||
+                !types.isSubtypeUnchecked(that.inst, hb, warn))
+                throw ambiguousNoInstanceException;
         }
-        return tvars.toList();
     }
 
 /***************************************************************************
@@ -217,7 +300,21 @@
     public Type instantiateExpr(ForAll that,
                                 Type to,
                                 Warner warn) throws InferenceException {
-        List<Type> undetvars = that.undetvars();
+        List<Type> undetvars = Type.map(that.tvars, fromTypeVarFun);
+        for (List<Type> l = undetvars; l.nonEmpty(); l = l.tail) {
+            UndetVar uv = (UndetVar) l.head;
+            TypeVar tv = (TypeVar)uv.qtype;
+            ListBuffer<Type> hibounds = new ListBuffer<Type>();
+            for (Type t : that.getConstraints(tv, ConstraintKind.EXTENDS)) {
+                hibounds.append(types.subst(t, that.tvars, undetvars));
+            }
+
+            List<Type> inst = that.getConstraints(tv, ConstraintKind.EQUAL);
+            if (inst.nonEmpty() && inst.head.tag != BOT) {
+                uv.inst = inst.head;
+            }
+            uv.hibounds = hibounds.toList();
+        }
         Type qtype1 = types.subst(that.qtype, that.tvars, undetvars);
         if (!types.isSubtype(qtype1,
                 qtype1.tag == UNDETVAR ? types.boxedTypeOrType(to) : to)) {
@@ -225,72 +322,37 @@
                 .setMessage("infer.no.conforming.instance.exists",
                             that.tvars, that.qtype, to);
         }
-
-        List<Type> insttypes;
-        while (true) {
-            boolean stuck = true;
-            insttypes = List.nil();
-            for (Type t : undetvars) {
-                UndetVar uv = (UndetVar)t;
-                if (uv.inst == null && (uv.eq.nonEmpty() || !Type.containsAny(uv.hibounds, that.tvars))) {
-                    maximizeInst((UndetVar)t, warn);
-                    stuck = false;
-                }
-                insttypes = insttypes.append(uv.inst == null ? uv.qtype : uv.inst);
-            }
-            if (!Type.containsAny(insttypes, that.tvars)) {
-                //all variables have been instantiated - exit
-                break;
-            } else if (stuck) {
-                //some variables could not be instantiated because of cycles in
-                //upper bounds - provide a (possibly recursive) default instantiation
-                insttypes = types.subst(insttypes,
+        for (List<Type> l = undetvars; l.nonEmpty(); l = l.tail)
+            maximizeInst((UndetVar) l.head, warn);
+        // System.out.println(" = " + qtype1.map(getInstFun));//DEBUG
+
+        // check bounds
+        List<Type> targs = Type.map(undetvars, getInstFun);
+        if (Type.containsAny(targs, that.tvars)) {
+            //replace uninferred type-vars
+            targs = types.subst(targs,
                     that.tvars,
-                    instantiateAsUninferredVars(undetvars, that.tvars));
-                break;
-            } else {
-                //some variables have been instantiated - replace newly instantiated
-                //variables in remaining upper bounds and continue
-                for (Type t : undetvars) {
-                    UndetVar uv = (UndetVar)t;
-                    uv.hibounds = types.subst(uv.hibounds, that.tvars, insttypes);
-                }
-            }
+                    instaniateAsUninferredVars(undetvars, that.tvars));
         }
-        return that.inst(insttypes, types);
+        return chk.checkType(warn.pos(), that.inst(targs, types), to);
     }
-
-    /**
-     * Infer cyclic inference variables as described in 15.12.2.8.
-     */
-    private List<Type> instantiateAsUninferredVars(List<Type> undetvars, List<Type> tvars) {
-        Assert.check(undetvars.length() == tvars.length());
-        ListBuffer<Type> insttypes = ListBuffer.lb();
-        ListBuffer<Type> todo = ListBuffer.lb();
-        //step 1 - create fresh tvars
+    //where
+    private List<Type> instaniateAsUninferredVars(List<Type> undetvars, List<Type> tvars) {
+        ListBuffer<Type> new_targs = ListBuffer.lb();
+        //step 1 - create syntethic captured vars
         for (Type t : undetvars) {
             UndetVar uv = (UndetVar)t;
-            if (uv.inst == null) {
-                TypeSymbol fresh_tvar = new TypeSymbol(Flags.SYNTHETIC, uv.qtype.tsym.name, null, uv.qtype.tsym.owner);
-                fresh_tvar.type = new TypeVar(fresh_tvar, types.makeCompoundType(uv.hibounds), null);
-                todo.append(uv);
-                uv.inst = fresh_tvar.type;
-            }
-            insttypes.append(uv.inst);
-        }
-        //step 2 - replace fresh tvars in their bounds
-        List<Type> formals = tvars;
-        for (Type t : todo) {
-            UndetVar uv = (UndetVar)t;
-            TypeVar ct = (TypeVar)uv.inst;
-            ct.bound = types.glb(types.subst(types.getBounds(ct), tvars, insttypes.toList()));
-            if (ct.bound.isErroneous()) {
-                //report inference error if glb fails
-                reportBoundError(uv, BoundErrorKind.BAD_UPPER);
-            }
-            formals = formals.tail;
+            Type newArg = new CapturedType(t.tsym.name, t.tsym, uv.inst, syms.botType, null);
+            new_targs = new_targs.append(newArg);
         }
-        return insttypes.toList();
+        //step 2 - replace synthetic vars in their bounds
+        for (Type t : new_targs.toList()) {
+            CapturedType ct = (CapturedType)t;
+            ct.bound = types.subst(ct.bound, tvars, new_targs.toList());
+            WildcardType wt = new WildcardType(ct.bound, BoundKind.EXTENDS, syms.boundClass);
+            ct.wildcard = wt;
+        }
+        return new_targs.toList();
     }
 
     /** Instantiate method type `mt' by finding instantiations of
@@ -305,11 +367,63 @@
                                   final boolean useVarargs,
                                   final Warner warn) throws InferenceException {
         //-System.err.println("instantiateMethod(" + tvars + ", " + mt + ", " + argtypes + ")"); //DEBUG
-        final List<Type> undetvars =  makeUndetvars(tvars);
+        List<Type> undetvars = Type.map(tvars, fromTypeVarFun);
+        List<Type> formals = mt.argtypes;
+        //need to capture exactly once - otherwise subsequent
+        //applicability checks might fail
+        final List<Type> capturedArgs = types.capture(argtypes);
+        List<Type> actuals = capturedArgs;
+        List<Type> actualsNoCapture = argtypes;
+        // instantiate all polymorphic argument types and
+        // set up lower bounds constraints for undetvars
+        Type varargsFormal = useVarargs ? formals.last() : null;
+        if (varargsFormal == null &&
+                actuals.size() != formals.size()) {
+            throw unambiguousNoInstanceException
+                .setMessage("infer.arg.length.mismatch");
+        }
+        while (actuals.nonEmpty() && formals.head != varargsFormal) {
+            Type formal = formals.head;
+            Type actual = actuals.head.baseType();
+            Type actualNoCapture = actualsNoCapture.head.baseType();
+            if (actual.tag == FORALL)
+                actual = instantiateArg((ForAll)actual, formal, tvars, warn);
+            Type undetFormal = types.subst(formal, tvars, undetvars);
+            boolean works = allowBoxing
+                ? types.isConvertible(actual, undetFormal, warn)
+                : types.isSubtypeUnchecked(actual, undetFormal, warn);
+            if (!works) {
+                throw unambiguousNoInstanceException
+                    .setMessage("infer.no.conforming.assignment.exists",
+                                tvars, actualNoCapture, formal);
+            }
+            formals = formals.tail;
+            actuals = actuals.tail;
+            actualsNoCapture = actualsNoCapture.tail;
+        }
 
-        final List<Type> capturedArgs =
-                rs.checkRawArgumentsAcceptable(env, undetvars, argtypes, mt.getParameterTypes(),
-                    allowBoxing, useVarargs, warn, new InferenceCheckHandler(undetvars));
+        if (formals.head != varargsFormal) // not enough args
+            throw unambiguousNoInstanceException.setMessage("infer.arg.length.mismatch");
+
+        // for varargs arguments as well
+        if (useVarargs) {
+            Type elemType = types.elemtype(varargsFormal);
+            Type elemUndet = types.subst(elemType, tvars, undetvars);
+            while (actuals.nonEmpty()) {
+                Type actual = actuals.head.baseType();
+                Type actualNoCapture = actualsNoCapture.head.baseType();
+                if (actual.tag == FORALL)
+                    actual = instantiateArg((ForAll)actual, elemType, tvars, warn);
+                boolean works = types.isConvertible(actual, elemUndet, warn);
+                if (!works) {
+                    throw unambiguousNoInstanceException
+                        .setMessage("infer.no.conforming.assignment.exists",
+                                    tvars, actualNoCapture, elemType);
+                }
+                actuals = actuals.tail;
+                actualsNoCapture = actualsNoCapture.tail;
+            }
+        }
 
         // minimize as yet undetermined type variables
         for (Type t : undetvars)
@@ -340,7 +454,7 @@
                 undettypes.append(uv.inst);
             }
         }
-        checkWithinBounds(tvars, undetvars, insttypes.toList(), warn);
+        checkWithinBounds(tvars, undettypes.toList(), warn);
 
         mt = (MethodType)types.subst(mt, tvars, insttypes.toList());
 
@@ -349,26 +463,32 @@
             // quantify result type with them
             final List<Type> inferredTypes = insttypes.toList();
             final List<Type> all_tvars = tvars; //this is the wrong tvars
-            return new UninferredMethodType(env.tree.pos(), msym, mt, restvars.toList()) {
+            return new UninferredMethodType(mt, restvars.toList()) {
                 @Override
-                List<Type> undetvars() {
-                    return restundet.toList();
+                List<Type> getConstraints(TypeVar tv, ConstraintKind ck) {
+                    for (Type t : restundet.toList()) {
+                        UndetVar uv = (UndetVar)t;
+                        if (uv.qtype == tv) {
+                            switch (ck) {
+                                case EXTENDS: return uv.hibounds.appendList(types.subst(types.getBounds(tv), all_tvars, inferredTypes));
+                                case SUPER: return uv.lobounds;
+                                case EQUAL: return uv.inst != null ? List.of(uv.inst) : List.<Type>nil();
+                            }
+                        }
+                    }
+                    return List.nil();
                 }
                 @Override
-                void instantiateReturnType(Type restype, List<Type> inferred, Types types) throws NoInstanceException {
-                    Type owntype = new MethodType(types.subst(getParameterTypes(), tvars, inferred),
-                                       restype,
-                                       types.subst(getThrownTypes(), tvars, inferred),
-                                       qtype.tsym);
+                void check(List<Type> inferred, Types types) throws NoInstanceException {
                     // check that actuals conform to inferred formals
-                    warn.clear();
-                    checkArgumentsAcceptable(env, capturedArgs, owntype.getParameterTypes(), allowBoxing, useVarargs, warn);
+                    checkArgumentsAcceptable(env, capturedArgs, getParameterTypes(), allowBoxing, useVarargs, warn);
                     // check that inferred bounds conform to their bounds
-                    checkWithinBounds(all_tvars, undetvars,
+                    checkWithinBounds(all_tvars,
                            types.subst(inferredTypes, tvars, inferred), warn);
-                    qtype = chk.checkMethod(owntype, msym, env, TreeInfo.args(env.tree), capturedArgs, useVarargs, warn.hasNonSilentLint(Lint.LintCategory.UNCHECKED));
-                }
-            };
+                    if (useVarargs) {
+                        chk.checkVararg(env.tree.pos(), getParameterTypes(), msym);
+                    }
+            }};
         }
         else {
             // check that actuals conform to inferred formals
@@ -379,48 +499,19 @@
     }
     //where
 
-        /** inference check handler **/
-        class InferenceCheckHandler implements Resolve.MethodCheckHandler {
-
-            List<Type> undetvars;
-
-            public InferenceCheckHandler(List<Type> undetvars) {
-                this.undetvars = undetvars;
-            }
-
-            public InapplicableMethodException arityMismatch() {
-                return unambiguousNoInstanceException.setMessage("infer.arg.length.mismatch");
-            }
-            public InapplicableMethodException argumentMismatch(boolean varargs, Type found, Type expected) {
-                String key = varargs ?
-                    "infer.varargs.argument.mismatch" :
-                    "infer.no.conforming.assignment.exists";
-                return unambiguousNoInstanceException.setMessage(key,
-                        inferenceVars(undetvars), found, expected);
-            }
-            public InapplicableMethodException inaccessibleVarargs(Symbol location, Type expected) {
-                return unambiguousNoInstanceException.setMessage("inaccessible.varargs.type",
-                        expected, Kinds.kindName(location), location);
-            }
-        }
-
         /**
          * A delegated type representing a partially uninferred method type.
          * The return type of a partially uninferred method type is a ForAll
          * type - when the return type is instantiated (see Infer.instantiateExpr)
          * the underlying method type is also updated.
          */
-        abstract class UninferredMethodType extends DelegatedType {
+        static abstract class UninferredMethodType extends DelegatedType {
 
             final List<Type> tvars;
-            final Symbol msym;
-            final DiagnosticPosition pos;
 
-            public UninferredMethodType(DiagnosticPosition pos, Symbol msym, MethodType mtype, List<Type> tvars) {
+            public UninferredMethodType(MethodType mtype, List<Type> tvars) {
                 super(METHOD, new MethodType(mtype.argtypes, null, mtype.thrown, mtype.tsym));
                 this.tvars = tvars;
-                this.msym = msym;
-                this.pos = pos;
                 asMethodType().restype = new UninferredReturnType(tvars, mtype.restype);
             }
 
@@ -434,9 +525,18 @@
                 return qtype.map(f);
             }
 
-            abstract void instantiateReturnType(Type restype, List<Type> inferred, Types types);
+            void instantiateReturnType(Type restype, List<Type> inferred, Types types) throws NoInstanceException {
+                //update method type with newly inferred type-arguments
+                qtype = new MethodType(types.subst(getParameterTypes(), tvars, inferred),
+                                       restype,
+                                       types.subst(UninferredMethodType.this.getThrownTypes(), tvars, inferred),
+                                       UninferredMethodType.this.qtype.tsym);
+                check(inferred, types);
+            }
+
+            abstract void check(List<Type> inferred, Types types) throws NoInstanceException;
 
-            abstract List<Type> undetvars();
+            abstract List<Type> getConstraints(TypeVar tv, ConstraintKind ck);
 
             class UninferredReturnType extends ForAll {
                 public UninferredReturnType(List<Type> tvars, Type restype) {
@@ -446,14 +546,11 @@
                 public Type inst(List<Type> actuals, Types types) {
                     Type newRestype = super.inst(actuals, types);
                     instantiateReturnType(newRestype, actuals, types);
-                    if (rs.verboseResolutionMode.contains(VerboseResolutionMode.DEFERRED_INST)) {
-                        log.note(pos, "deferred.method.inst", msym, UninferredMethodType.this.qtype, newRestype);
-                    }
-                    return UninferredMethodType.this.qtype.getReturnType();
+                    return newRestype;
                 }
                 @Override
-                public List<Type> undetvars() {
-                    return UninferredMethodType.this.undetvars();
+                public List<Type> getConstraints(TypeVar tv, ConstraintKind ck) {
+                    return UninferredMethodType.this.getConstraints(tv, ck);
                 }
             }
         }
@@ -464,100 +561,49 @@
                 rs.checkRawArgumentsAcceptable(env, actuals, formals,
                        allowBoxing, useVarargs, warn);
             }
-            catch (InapplicableMethodException ex) {
+            catch (Resolve.InapplicableMethodException ex) {
                 // inferred method is not applicable
                 throw invalidInstanceException.setMessage(ex.getDiagnostic());
             }
         }
 
-    /** check that type parameters are within their bounds.
+    /** Try to instantiate argument type `that' to given type `to'.
+     *  If this fails, try to insantiate `that' to `to' where
+     *  every occurrence of a type variable in `tvars' is replaced
+     *  by an unknown type.
      */
-    void checkWithinBounds(List<Type> tvars,
-                           List<Type> undetvars,
-                           List<Type> arguments,
-                           Warner warn)
-        throws InvalidInstanceException {
-        List<Type> args = arguments;
-        for (Type t : undetvars) {
-            UndetVar uv = (UndetVar)t;
-            uv.hibounds = types.subst(uv.hibounds, tvars, arguments);
-            uv.lobounds = types.subst(uv.lobounds, tvars, arguments);
-            uv.eq = types.subst(uv.eq, tvars, arguments);
-            checkCompatibleUpperBounds(uv, tvars);
-            if (args.head.tag != TYPEVAR || !args.head.containsAny(tvars)) {
-                Type inst = args.head;
-                for (Type u : uv.hibounds) {
-                    if (!types.isSubtypeUnchecked(inst, types.subst(u, tvars, undetvars), warn)) {
-                        reportBoundError(uv, BoundErrorKind.UPPER);
-                    }
-                }
-                for (Type l : uv.lobounds) {
-                    if (!types.isSubtypeUnchecked(types.subst(l, tvars, undetvars), inst, warn)) {
-                        reportBoundError(uv, BoundErrorKind.LOWER);
-                    }
-                }
-                for (Type e : uv.eq) {
-                    if (!types.isSameType(inst, types.subst(e, tvars, undetvars))) {
-                        reportBoundError(uv, BoundErrorKind.EQ);
-                    }
-                }
-            }
-            args = args.tail;
+    private Type instantiateArg(ForAll that,
+                                Type to,
+                                List<Type> tvars,
+                                Warner warn) throws InferenceException {
+        List<Type> targs;
+        try {
+            return instantiateExpr(that, to, warn);
+        } catch (NoInstanceException ex) {
+            Type to1 = to;
+            for (List<Type> l = tvars; l.nonEmpty(); l = l.tail)
+                to1 = types.subst(to1, List.of(l.head), List.of(syms.unknownType));
+            return instantiateExpr(that, to1, warn);
         }
     }
 
-    void checkCompatibleUpperBounds(UndetVar uv, List<Type> tvars) {
-        // VGJ: sort of inlined maximizeInst() below.  Adding
-        // bounds can cause lobounds that are above hibounds.
-        ListBuffer<Type> hiboundsNoVars = ListBuffer.lb();
-        for (Type t : Type.filter(uv.hibounds, errorFilter)) {
-            if (!t.containsAny(tvars)) {
-                hiboundsNoVars.append(t);
-            }
+    /** check that type parameters are within their bounds.
+     */
+    void checkWithinBounds(List<Type> tvars,
+                                   List<Type> arguments,
+                                   Warner warn)
+        throws InvalidInstanceException {
+        for (List<Type> tvs = tvars, args = arguments;
+             tvs.nonEmpty();
+             tvs = tvs.tail, args = args.tail) {
+            if (args.head instanceof UndetVar ||
+                    tvars.head.getUpperBound().isErroneous()) continue;
+            List<Type> bounds = types.subst(types.getBounds((TypeVar)tvs.head), tvars, arguments);
+            if (!types.isSubtypeUnchecked(args.head, bounds, warn))
+                throw invalidInstanceException
+                    .setMessage("inferred.do.not.conform.to.bounds",
+                                args.head, bounds);
         }
-        List<Type> hibounds = hiboundsNoVars.toList();
-        Type hb = null;
-        if (hibounds.isEmpty())
-            hb = syms.objectType;
-        else if (hibounds.tail.isEmpty())
-            hb = hibounds.head;
-        else
-            hb = types.glb(hibounds);
-        if (hb == null || hb.isErroneous())
-            reportBoundError(uv, BoundErrorKind.BAD_UPPER);
-    }
-
-    enum BoundErrorKind {
-        BAD_UPPER() {
-            @Override
-            InapplicableMethodException setMessage(InferenceException ex, UndetVar uv) {
-                return ex.setMessage("incompatible.upper.bounds", uv.qtype, uv.hibounds);
-            }
-        },
-        UPPER() {
-            @Override
-            InapplicableMethodException setMessage(InferenceException ex, UndetVar uv) {
-                return ex.setMessage("inferred.do.not.conform.to.upper.bounds", uv.inst, uv.hibounds);
-            }
-        },
-        LOWER() {
-            @Override
-            InapplicableMethodException setMessage(InferenceException ex, UndetVar uv) {
-                return ex.setMessage("inferred.do.not.conform.to.lower.bounds", uv.inst, uv.lobounds);
-            }
-        },
-        EQ() {
-            @Override
-            InapplicableMethodException setMessage(InferenceException ex, UndetVar uv) {
-                return ex.setMessage("inferred.do.not.conform.to.eq.bounds", uv.inst, uv.eq);
-            }
-        };
-
-        abstract InapplicableMethodException setMessage(InferenceException ex, UndetVar uv);
-    }
-    //where
-    void reportBoundError(UndetVar uv, BoundErrorKind bk) {
-        throw bk.setMessage(uv.inst == null ? ambiguousNoInstanceException : invalidInstanceException, uv);
     }
 
     /**
@@ -565,7 +611,8 @@
      * method signature. The target return type is computed from the immediately
      * enclosing scope surrounding the polymorphic-signature call.
      */
-    Type instantiatePolymorphicSignatureInstance(Env<AttrContext> env,
+    Type instantiatePolymorphicSignatureInstance(Env<AttrContext> env, Type site,
+                                            Name name,
                                             MethodSymbol spMethod,  // sig. poly. method or null if none
                                             List<Type> argtypes) {
         final Type restype;
@@ -579,13 +626,13 @@
         //the polymorphic signature call environment is nested.
 
         switch (env.next.tree.getTag()) {
-            case TYPECAST:
+            case JCTree.TYPECAST:
                 JCTypeCast castTree = (JCTypeCast)env.next.tree;
                 restype = (TreeInfo.skipParens(castTree.expr) == env.tree) ?
                     castTree.clazz.type :
                     syms.objectType;
                 break;
-            case EXEC:
+            case JCTree.EXEC:
                 JCTree.JCExpressionStatement execTree =
                         (JCTree.JCExpressionStatement)env.next.tree;
                 restype = (TreeInfo.skipParens(execTree.expr) == env.tree) ?
diff -u -r javac/comp/Lower.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Lower.java
--- javac/comp/Lower.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Lower.java	2011-06-27 15:21:47.000000000 -0500
@@ -29,7 +29,7 @@
 
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.jvm.*;
-import com.sun.tools.javac.main.Option.PkgInfo;
+import com.sun.tools.javac.main.RecognizedOptions.PkgInfo;
 import com.sun.tools.javac.tree.*;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
@@ -40,14 +40,11 @@
 import com.sun.tools.javac.code.Type.*;
 
 import com.sun.tools.javac.jvm.Target;
-import com.sun.tools.javac.parser.EndPosTable;
 
 import static com.sun.tools.javac.code.Flags.*;
-import static com.sun.tools.javac.code.Flags.BLOCK;
 import static com.sun.tools.javac.code.Kinds.*;
 import static com.sun.tools.javac.code.TypeTags.*;
 import static com.sun.tools.javac.jvm.ByteCodes.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
 
 /** This pass translates away some syntactic sugar: inner classes,
  *  class literals, assertions, foreach loops, etc.
@@ -128,7 +125,7 @@
 
     /** A hash table mapping syntax trees to their ending source positions.
      */
-    EndPosTable endPosTable;
+    Map<JCTree, Integer> endPositions;
 
 /**************************************************************************
  * Global mappings
@@ -306,7 +303,7 @@
                 Symbol constructor = TreeInfo.symbol(tree.meth);
                 ClassSymbol c = (ClassSymbol)constructor.owner;
                 if (c.hasOuterInstance() &&
-                    !tree.meth.hasTag(SELECT) &&
+                    tree.meth.getTag() != JCTree.SELECT &&
                     outerThisStack.head != null)
                     visitSymbol(outerThisStack.head);
             }
@@ -511,7 +508,7 @@
      *  @param optag    The operators tree tag.
      *  @param arg      The operator's argument.
      */
-    JCUnary makeUnary(JCTree.Tag optag, JCExpression arg) {
+    JCUnary makeUnary(int optag, JCExpression arg) {
         JCUnary tree = make.Unary(optag, arg);
         tree.operator = rs.resolveUnaryOperator(
             make_pos, optag, attrEnv, arg.type);
@@ -524,7 +521,7 @@
      *  @param lhs      The operator's left argument.
      *  @param rhs      The operator's right argument.
      */
-    JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
+    JCBinary makeBinary(int optag, JCExpression lhs, JCExpression rhs) {
         JCBinary tree = make.Binary(optag, lhs, rhs);
         tree.operator = rs.resolveBinaryOperator(
             make_pos, optag, attrEnv, lhs.type, rhs.type);
@@ -537,10 +534,10 @@
      *  @param lhs      The operator's left argument.
      *  @param rhs      The operator's right argument.
      */
-    JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {
+    JCAssignOp makeAssignop(int optag, JCTree lhs, JCTree rhs) {
         JCAssignOp tree = make.Assignop(optag, lhs, rhs);
         tree.operator = rs.resolveBinaryOperator(
-            make_pos, tree.getTag().noAssignOp(), attrEnv, lhs.type, rhs.type);
+            make_pos, tree.getTag() - JCTree.ASGOffset, attrEnv, lhs.type, rhs.type);
         tree.type = lhs.type;
         return tree;
     }
@@ -723,7 +720,7 @@
     // where
     private boolean isTranslatedClassAvailable(ClassSymbol c) {
         for (JCTree tree: translated) {
-            if (tree.hasTag(CLASSDEF)
+            if (tree.getTag() == JCTree.CLASSDEF
                     && ((JCClassDecl) tree).sym == c) {
                 return true;
             }
@@ -805,13 +802,13 @@
     private static int accessCode(JCTree tree, JCTree enclOp) {
         if (enclOp == null)
             return DEREFcode;
-        else if (enclOp.hasTag(ASSIGN) &&
+        else if (enclOp.getTag() == JCTree.ASSIGN &&
                  tree == TreeInfo.skipParens(((JCAssign) enclOp).lhs))
             return ASSIGNcode;
-        else if (enclOp.getTag().isIncOrDecUnaryOp() &&
+        else if (JCTree.PREINC <= enclOp.getTag() && enclOp.getTag() <= JCTree.POSTDEC &&
                  tree == TreeInfo.skipParens(((JCUnary) enclOp).arg))
-            return mapTagToUnaryOpCode(enclOp.getTag());
-        else if (enclOp.getTag().isAssignop() &&
+            return (enclOp.getTag() - JCTree.PREINC) * 2 + PREINCcode;
+        else if (JCTree.BITOR_ASG <= enclOp.getTag() && enclOp.getTag() <= JCTree.MOD_ASG &&
                  tree == TreeInfo.skipParens(((JCAssignOp) enclOp).lhs))
             return accessCode(((OperatorSymbol) ((JCAssignOp) enclOp).operator).opcode);
         else
@@ -835,39 +832,39 @@
     /** Return tree tag for assignment operation corresponding
      *  to given binary operator.
      */
-    private static JCTree.Tag treeTag(OperatorSymbol operator) {
+    private static int treeTag(OperatorSymbol operator) {
         switch (operator.opcode) {
         case ByteCodes.ior: case ByteCodes.lor:
-            return BITOR_ASG;
+            return JCTree.BITOR_ASG;
         case ByteCodes.ixor: case ByteCodes.lxor:
-            return BITXOR_ASG;
+            return JCTree.BITXOR_ASG;
         case ByteCodes.iand: case ByteCodes.land:
-            return BITAND_ASG;
+            return JCTree.BITAND_ASG;
         case ByteCodes.ishl: case ByteCodes.lshl:
         case ByteCodes.ishll: case ByteCodes.lshll:
-            return SL_ASG;
+            return JCTree.SL_ASG;
         case ByteCodes.ishr: case ByteCodes.lshr:
         case ByteCodes.ishrl: case ByteCodes.lshrl:
-            return SR_ASG;
+            return JCTree.SR_ASG;
         case ByteCodes.iushr: case ByteCodes.lushr:
         case ByteCodes.iushrl: case ByteCodes.lushrl:
-            return USR_ASG;
+            return JCTree.USR_ASG;
         case ByteCodes.iadd: case ByteCodes.ladd:
         case ByteCodes.fadd: case ByteCodes.dadd:
         case ByteCodes.string_add:
-            return PLUS_ASG;
+            return JCTree.PLUS_ASG;
         case ByteCodes.isub: case ByteCodes.lsub:
         case ByteCodes.fsub: case ByteCodes.dsub:
-            return MINUS_ASG;
+            return JCTree.MINUS_ASG;
         case ByteCodes.imul: case ByteCodes.lmul:
         case ByteCodes.fmul: case ByteCodes.dmul:
-            return MUL_ASG;
+            return JCTree.MUL_ASG;
         case ByteCodes.idiv: case ByteCodes.ldiv:
         case ByteCodes.fdiv: case ByteCodes.ddiv:
-            return DIV_ASG;
+            return JCTree.DIV_ASG;
         case ByteCodes.imod: case ByteCodes.lmod:
         case ByteCodes.fmod: case ByteCodes.dmod:
-            return MOD_ASG;
+            return JCTree.MOD_ASG;
         default:
             throw new AssertionError();
         }
@@ -1006,7 +1003,7 @@
         if (!currentClass.isSubClass(sym.owner, types))
             return true;
         if ((sym.flags() & STATIC) != 0 ||
-            !tree.hasTag(SELECT) ||
+            tree.getTag() != JCTree.SELECT ||
             TreeInfo.name(((JCFieldAccess) tree).selected) == names._super)
             return false;
         return !((JCFieldAccess) tree).selected.type.tsym.isSubClass(currentClass, types);
@@ -1021,7 +1018,7 @@
         if (protAccess) {
             Symbol qualifier = null;
             ClassSymbol c = currentClass;
-            if (tree.hasTag(SELECT) && (sym.flags() & STATIC) == 0) {
+            if (tree.getTag() == JCTree.SELECT && (sym.flags() & STATIC) == 0) {
                 qualifier = ((JCFieldAccess) tree).selected.type.tsym;
                 while (!qualifier.isSubClass(c, types)) {
                     c = c.owner.enclClass();
@@ -1061,7 +1058,7 @@
             Assert.check(sym != null && (sym.flags_field & FINAL) != 0);
             tree = make.at(tree.pos).Ident(sym);
         }
-        JCExpression base = (tree.hasTag(SELECT)) ? ((JCFieldAccess) tree).selected : null;
+        JCExpression base = (tree.getTag() == JCTree.SELECT) ? ((JCFieldAccess) tree).selected : null;
         switch (sym.kind) {
         case TYP:
             if (sym.owner.kind != PCK) {
@@ -1071,11 +1068,11 @@
                 while (base != null &&
                        TreeInfo.symbol(base) != null &&
                        TreeInfo.symbol(base).kind != PCK) {
-                    base = (base.hasTag(SELECT))
+                    base = (base.getTag() == JCTree.SELECT)
                         ? ((JCFieldAccess) base).selected
                         : null;
                 }
-                if (tree.hasTag(IDENT)) {
+                if (tree.getTag() == JCTree.IDENT) {
                     ((JCIdent) tree).name = flatname;
                 } else if (base == null) {
                     tree = make.at(tree.pos).Ident(sym);
@@ -1223,42 +1220,6 @@
         }
     }
 
-    /** Maps unary operator integer codes to JCTree.Tag objects
-     *  @param unaryOpCode the unary operator code
-     */
-    private static Tag mapUnaryOpCodeToTag(int unaryOpCode){
-        switch (unaryOpCode){
-            case PREINCcode:
-                return PREINC;
-            case PREDECcode:
-                return PREDEC;
-            case POSTINCcode:
-                return POSTINC;
-            case POSTDECcode:
-                return POSTDEC;
-            default:
-                return NO_TAG;
-        }
-    }
-
-    /** Maps JCTree.Tag objects to unary operator integer codes
-     *  @param tag the JCTree.Tag
-     */
-    private static int mapTagToUnaryOpCode(Tag tag){
-        switch (tag){
-            case PREINC:
-                return PREINCcode;
-            case PREDEC:
-                return PREDECcode;
-            case POSTINC:
-                return POSTINCcode;
-            case POSTDEC:
-                return POSTDECcode;
-            default:
-                return -1;
-        }
-    }
-
     /** Construct definition of an access method.
      *  @param pos        The source code position of the definition.
      *  @param vsym       The private or protected symbol.
@@ -1298,7 +1259,8 @@
                 expr = make.Assign(ref, args.head);
                 break;
             case PREINCcode: case POSTINCcode: case PREDECcode: case POSTDECcode:
-                expr = makeUnary(mapUnaryOpCodeToTag(acode1), ref);
+                expr = makeUnary(
+                    ((acode1 - PREINCcode) >> 1) + JCTree.PREINC, ref);
                 break;
             default:
                 expr = make.Assignop(
@@ -1614,7 +1576,7 @@
     }
 
     private JCExpression makeNonNullCheck(JCExpression expression) {
-        return makeBinary(NE, expression, makeNull());
+        return makeBinary(JCTree.NE, expression, makeNull());
     }
 
     /** Construct a tree that represents the outer instance
@@ -1846,7 +1808,7 @@
             // $newcache.getClass().getComponentType().getClassLoader() : cl$"
             JCExpression clvalue =
                 make.Conditional(
-                    makeBinary(EQ, make.Ident(clsym), makeNull()),
+                    makeBinary(JCTree.EQ, make.Ident(clsym), makeNull()),
                     make.Assign(
                         make.Ident(clsym),
                         makeCall(
@@ -2014,7 +1976,7 @@
                 writer.xClassName(type).toString().replace('/', '.');
             Symbol cs = cacheSym(pos, sig);
             return make_at(pos).Conditional(
-                makeBinary(EQ, make.Ident(cs), makeNull()),
+                makeBinary(JCTree.EQ, make.Ident(cs), makeNull()),
                 make.Assign(
                     make.Ident(cs),
                     make.App(
@@ -2061,7 +2023,7 @@
                                                             List.<Type>nil());
             JCClassDecl containerDef = classDef(container);
             make_at(containerDef.pos());
-            JCExpression notStatus = makeUnary(NOT, make.App(make.Select(
+            JCExpression notStatus = makeUnary(JCTree.NOT, make.App(make.Select(
                     classOfType(types.erasure(outermostClass.type),
                                 containerDef.pos()),
                     desiredAssertionStatusSym)));
@@ -2070,7 +2032,7 @@
             containerDef.defs = containerDef.defs.prepend(assertDisabledDef);
         }
         make_at(pos);
-        return makeUnary(NOT, make.Ident(assertDisabledSym));
+        return makeUnary(JCTree.NOT, make.Ident(assertDisabledSym));
     }
 
 
@@ -2100,9 +2062,9 @@
     JCTree abstractRval(JCTree rval, Type type, TreeBuilder builder) {
         rval = TreeInfo.skipParens(rval);
         switch (rval.getTag()) {
-        case LITERAL:
+        case JCTree.LITERAL:
             return builder.build(rval);
-        case IDENT:
+        case JCTree.IDENT:
             JCIdent id = (JCIdent) rval;
             if ((id.sym.flags() & FINAL) != 0 && id.sym.owner.kind == MTH)
                 return builder.build(rval);
@@ -2135,9 +2097,9 @@
     JCTree abstractLval(JCTree lval, final TreeBuilder builder) {
         lval = TreeInfo.skipParens(lval);
         switch (lval.getTag()) {
-        case IDENT:
+        case JCTree.IDENT:
             return builder.build(lval);
-        case SELECT: {
+        case JCTree.SELECT: {
             final JCFieldAccess s = (JCFieldAccess)lval;
             JCTree selected = TreeInfo.skipParens(s.selected);
             Symbol lid = TreeInfo.symbol(s.selected);
@@ -2148,7 +2110,7 @@
                     }
                 });
         }
-        case INDEXED: {
+        case JCTree.INDEXED: {
             final JCArrayAccess i = (JCArrayAccess)lval;
             return abstractRval(i.indexed, new TreeBuilder() {
                     public JCTree build(final JCTree indexed) {
@@ -2163,7 +2125,7 @@
                     }
                 });
         }
-        case TYPECAST: {
+        case JCTree.TYPECAST: {
             return abstractLval(((JCTypeCast)lval).expr, builder);
         }
         }
@@ -2196,8 +2158,9 @@
         } else {
             make_at(tree.pos());
             T result = super.translate(tree);
-            if (endPosTable != null && result != tree) {
-                endPosTable.replaceTree(tree, result);
+            if (endPositions != null && result != tree) {
+                Integer endPos = endPositions.remove(tree);
+                if (endPos != null) endPositions.put(result, endPos);
             }
             return result;
         }
@@ -2308,14 +2271,6 @@
         tree.extending = translate(tree.extending);
         tree.implementing = translate(tree.implementing);
 
-        if (currentClass.isLocal()) {
-            ClassSymbol encl = currentClass.owner.enclClass();
-            if (encl.trans_local == null) {
-                encl.trans_local = List.nil();
-            }
-            encl.trans_local = encl.trans_local.prepend(currentClass);
-        }
-
         // Recursively translate members, taking into account that new members
         // might be created during the translation and prepended to the member
         // list `tree.defs'.
@@ -2382,7 +2337,7 @@
         for (List<JCTree> defs = tree.defs;
              defs.nonEmpty();
              defs=defs.tail) {
-            if (defs.head.hasTag(VARDEF) && (((JCVariableDecl) defs.head).mods.flags & ENUM) != 0) {
+            if (defs.head.getTag() == JCTree.VARDEF && (((JCVariableDecl) defs.head).mods.flags & ENUM) != 0) {
                 JCVariableDecl var = (JCVariableDecl)defs.head;
                 visitEnumConstantDef(var, nextOrdinal++);
                 values.append(make.QualIdent(var.sym));
@@ -2794,9 +2749,9 @@
                 List.<JCExpression>nil() : List.of(translate(tree.detail));
             if (!tree.cond.type.isFalse()) {
                 cond = makeBinary
-                    (AND,
+                    (JCTree.AND,
                      cond,
-                     makeUnary(NOT, tree.cond));
+                     makeUnary(JCTree.NOT, tree.cond));
             }
             result =
                 make.If(cond,
@@ -2853,7 +2808,7 @@
             // first argument.
             if (c.hasOuterInstance()) {
                 JCExpression thisArg;
-                if (tree.meth.hasTag(SELECT)) {
+                if (tree.meth.getTag() == JCTree.SELECT) {
                     thisArg = attr.
                         makeNullCheck(translate(((JCFieldAccess) tree.meth).selected));
                     tree.meth = make.Ident(constructor);
@@ -2874,7 +2829,7 @@
             // If the translated method itself is an Apply tree, we are
             // seeing an access method invocation. In this case, append
             // the method arguments to the arguments of the access method.
-            if (tree.meth.hasTag(APPLY)) {
+            if (tree.meth.getTag() == JCTree.APPLY) {
                 JCMethodInvocation app = (JCMethodInvocation)tree.meth;
                 app.args = tree.args.prependList(app.args);
                 result = app;
@@ -3008,7 +2963,7 @@
         // If translated left hand side is an Apply, we are
         // seeing an access method invocation. In this case, append
         // right hand side as last argument of the access method.
-        if (tree.lhs.hasTag(APPLY)) {
+        if (tree.lhs.getTag() == JCTree.APPLY) {
             JCMethodInvocation app = (JCMethodInvocation)tree.lhs;
             app.args = List.of(tree.rhs).prependList(app.args);
             result = app;
@@ -3025,7 +2980,7 @@
             // (but without recomputing x)
             JCTree newTree = abstractLval(tree.lhs, new TreeBuilder() {
                     public JCTree build(final JCTree lhs) {
-                        JCTree.Tag newTag = tree.getTag().noAssignOp();
+                        int newTag = tree.getTag() - JCTree.ASGOffset;
                         // Erasure (TransTypes) can change the type of
                         // tree.lhs.  However, we can still get the
                         // unerased type of tree.lhs as it is stored
@@ -3055,7 +3010,7 @@
         // If translated left hand side is an Apply, we are
         // seeing an access method invocation. In this case, append
         // right hand side as last argument of the access method.
-        if (tree.lhs.hasTag(APPLY)) {
+        if (tree.lhs.getTag() == JCTree.APPLY) {
             JCMethodInvocation app = (JCMethodInvocation)tree.lhs;
             // if operation is a += on strings,
             // make sure to convert argument to string
@@ -3075,13 +3030,13 @@
         // or
         // translate to tmp1=lval(e); tmp2=tmp1; (typeof tree)tmp1 OP 1; tmp2
         // where OP is += or -=
-        final boolean cast = TreeInfo.skipParens(tree.arg).hasTag(TYPECAST);
+        final boolean cast = TreeInfo.skipParens(tree.arg).getTag() == JCTree.TYPECAST;
         return abstractLval(tree.arg, new TreeBuilder() {
                 public JCTree build(final JCTree tmp1) {
                     return abstractRval(tmp1, tree.arg.type, new TreeBuilder() {
                             public JCTree build(final JCTree tmp2) {
-                                JCTree.Tag opcode = (tree.hasTag(POSTINC))
-                                    ? PLUS_ASG : MINUS_ASG;
+                                int opcode = (tree.getTag() == JCTree.POSTINC)
+                                    ? JCTree.PLUS_ASG : JCTree.MINUS_ASG;
                                 JCTree lhs = cast
                                     ? make.TypeCast(tree.arg.type, (JCExpression)tmp1)
                                     : tmp1;
@@ -3096,24 +3051,25 @@
     }
 
     public void visitUnary(JCUnary tree) {
-        boolean isUpdateOperator = tree.getTag().isIncOrDecUnaryOp();
+        boolean isUpdateOperator =
+            JCTree.PREINC <= tree.getTag() && tree.getTag() <= JCTree.POSTDEC;
         if (isUpdateOperator && !tree.arg.type.isPrimitive()) {
             switch(tree.getTag()) {
-            case PREINC:            // ++ e
+            case JCTree.PREINC:            // ++ e
                     // translate to e += 1
-            case PREDEC:            // -- e
+            case JCTree.PREDEC:            // -- e
                     // translate to e -= 1
                 {
-                    JCTree.Tag opcode = (tree.hasTag(PREINC))
-                        ? PLUS_ASG : MINUS_ASG;
+                    int opcode = (tree.getTag() == JCTree.PREINC)
+                        ? JCTree.PLUS_ASG : JCTree.MINUS_ASG;
                     JCAssignOp newTree = makeAssignop(opcode,
                                                     tree.arg,
                                                     make.Literal(1));
                     result = translate(newTree, tree.type);
                     return;
                 }
-            case POSTINC:           // e ++
-            case POSTDEC:           // e --
+            case JCTree.POSTINC:           // e ++
+            case JCTree.POSTDEC:           // e --
                 {
                     result = translate(lowerBoxedPostop(tree), tree.type);
                     return;
@@ -3124,14 +3080,14 @@
 
         tree.arg = boxIfNeeded(translate(tree.arg, tree), tree.type);
 
-        if (tree.hasTag(NOT) && tree.arg.type.constValue() != null) {
+        if (tree.getTag() == JCTree.NOT && tree.arg.type.constValue() != null) {
             tree.type = cfolder.fold1(bool_not, tree.arg.type);
         }
 
         // If translated left hand side is an Apply, we are
         // seeing an access method invocation. In this case, return
         // that access method invocation as result.
-        if (isUpdateOperator && tree.arg.hasTag(APPLY)) {
+        if (isUpdateOperator && tree.arg.getTag() == JCTree.APPLY) {
             result = tree.arg;
         } else {
             result = tree;
@@ -3142,7 +3098,7 @@
         List<Type> formals = tree.operator.type.getParameterTypes();
         JCTree lhs = tree.lhs = translate(tree.lhs, formals.head);
         switch (tree.getTag()) {
-        case OR:
+        case JCTree.OR:
             if (lhs.type.isTrue()) {
                 result = lhs;
                 return;
@@ -3152,7 +3108,7 @@
                 return;
             }
             break;
-        case AND:
+        case JCTree.AND:
             if (lhs.type.isFalse()) {
                 result = lhs;
                 return;
@@ -3222,9 +3178,9 @@
             indexdef.init.type = indexdef.type = syms.intType.constType(0);
 
             List<JCStatement> loopinit = List.of(arraycachedef, lencachedef, indexdef);
-            JCBinary cond = makeBinary(LT, make.Ident(index), make.Ident(lencache));
+            JCBinary cond = makeBinary(JCTree.LT, make.Ident(index), make.Ident(lencache));
 
-            JCExpressionStatement step = make.Exec(makeUnary(PREINC, make.Ident(index)));
+            JCExpressionStatement step = make.Exec(makeUnary(JCTree.PREINC, make.Ident(index)));
 
             Type elemtype = types.elemtype(tree.expr.type);
             JCExpression loopvarinit = make.Indexed(make.Ident(arraycache),
@@ -3494,7 +3450,6 @@
                 JCExpression expression = oneCase.getExpression();
 
                 if (expression != null) { // expression for a "default" case is null
-                    expression = TreeInfo.skipParens(expression);
                     String labelExpr = (String) expression.type.constValue();
                     Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);
                     Assert.checkNull(mapping);
@@ -3600,8 +3555,8 @@
                 if (isDefault)
                     caseExpr = null;
                 else {
-                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens(oneCase.
-                                                                                                getExpression()).
+                    caseExpr = make.Literal(caseLabelToPosition.get((String)oneCase.
+                                                                    getExpression().
                                                                     type.constValue()));
                 }
 
@@ -3628,7 +3583,7 @@
         // need to special case-access of the form C.super.x
         // these will always need an access method.
         boolean qualifiedSuperAccess =
-            tree.selected.hasTag(SELECT) &&
+            tree.selected.getTag() == JCTree.SELECT &&
             TreeInfo.name(tree.selected) == names._super;
         tree.selected = translate(tree.selected);
         if (tree.name == names._class)
@@ -3675,10 +3630,10 @@
         try {
             attrEnv = env;
             this.make = make;
-            endPosTable = env.toplevel.endPositions;
+            endPositions = env.toplevel.endPositions;
             currentClass = null;
             currentMethodDef = null;
-            outermostClassDef = (cdef.hasTag(CLASSDEF)) ? (JCClassDecl)cdef : null;
+            outermostClassDef = (cdef.getTag() == JCTree.CLASSDEF) ? (JCClassDecl)cdef : null;
             outermostMemberDef = null;
             this.translated = new ListBuffer<JCTree>();
             classdefs = new HashMap<ClassSymbol,JCClassDecl>();
@@ -3704,7 +3659,7 @@
             // note that recursive invocations of this method fail hard
             attrEnv = null;
             this.make = null;
-            endPosTable = null;
+            endPositions = null;
             currentClass = null;
             currentMethodDef = null;
             outermostClassDef = null;
@@ -3874,7 +3829,7 @@
 
         JCIdent fLocUsageId = make.Ident(otherVarSym);
         JCExpression sel = make.Select(fLocUsageId, ordinalSymbol);
-        JCBinary bin = makeBinary(MINUS, id1, sel);
+        JCBinary bin = makeBinary(JCTree.MINUS, id1, sel);
         JCReturn ret = make.Return(bin);
         blockStatements.append(ret);
         JCMethodDecl compareToMethod = make.MethodDef((MethodSymbol)compareToSym,
diff -u -r javac/comp/MemberEnter.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/MemberEnter.java
--- javac/comp/MemberEnter.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/MemberEnter.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -40,11 +40,8 @@
 import com.sun.tools.javac.tree.JCTree.*;
 
 import static com.sun.tools.javac.code.Flags.*;
-import static com.sun.tools.javac.code.Flags.ANNOTATION;
 import static com.sun.tools.javac.code.Kinds.*;
 import static com.sun.tools.javac.code.TypeTags.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 
 /** This is the second phase of Enter, in which classes are completed
@@ -143,7 +140,7 @@
                 JCDiagnostic msg = diags.fragment("fatal.err.no.java.lang");
                 throw new FatalError(msg);
             } else {
-                log.error(DiagnosticFlag.RESOLVE_ERROR, pos, "doesnt.exist", tsym);
+                log.error(pos, "doesnt.exist", tsym);
             }
         }
         env.toplevel.starImportScope.importAll(tsym.members());
@@ -529,17 +526,24 @@
 
     // process the non-static imports and the static imports of types.
     public void visitImport(JCImport tree) {
-        JCFieldAccess imp = (JCFieldAccess)tree.qualid;
+        JCTree imp = tree.qualid;
         Name name = TreeInfo.name(imp);
+        TypeSymbol p;
 
         // Create a local environment pointing to this tree to disable
         // effects of other imports in Resolve.findGlobalType
         Env<AttrContext> localEnv = env.dup(tree);
 
-        TypeSymbol p = attr.attribImportQualifier(tree, localEnv).tsym;
+        // Attribute qualifying package or class.
+        JCFieldAccess s = (JCFieldAccess) imp;
+        p = attr.
+            attribTree(s.selected,
+                       localEnv,
+                       tree.staticImport ? TYP : (TYP | PCK),
+                       Type.noType).tsym;
         if (name == names.asterisk) {
             // Import on demand.
-            chk.checkCanonical(imp.selected);
+            chk.checkCanonical(s.selected);
             if (tree.staticImport)
                 importStaticAll(tree.pos, p, env);
             else
@@ -548,7 +552,7 @@
             // Named type import.
             if (tree.staticImport) {
                 importNamedStatic(tree.pos(), p, name, localEnv);
-                chk.checkCanonical(imp.selected);
+                chk.checkCanonical(s.selected);
             } else {
                 TypeSymbol c = attribImportType(imp, localEnv).tsym;
                 chk.checkCanonical(imp);
@@ -640,7 +644,7 @@
         tree.sym = v;
         if (tree.init != null) {
             v.flags_field |= HASINIT;
-            if ((v.flags_field & FINAL) != 0 && !tree.init.hasTag(NEWCLASS)) {
+            if ((v.flags_field & FINAL) != 0 && tree.init.getTag() != JCTree.NEWCLASS) {
                 Env<AttrContext> initEnv = getInitEnv(tree, env);
                 initEnv.info.enclVar = v;
                 v.setLazyConstValue(initEnv(tree, initEnv), attr, tree.init);
@@ -781,6 +785,20 @@
                 && s.owner.kind != MTH
                 && types.isSameType(c.type, syms.deprecatedType))
                 s.flags_field |= Flags.DEPRECATED;
+            // Internally to java.lang.invoke, a @PolymorphicSignature annotation
+            // acts like a classfile attribute.
+            if (!c.type.isErroneous() &&
+                types.isSameType(c.type, syms.polymorphicSignatureType)) {
+                if (!target.hasMethodHandles()) {
+                    // Somebody is compiling JDK7 source code to a JDK6 target.
+                    // Make it an error, since it is unlikely but important.
+                    log.error(env.tree.pos(),
+                            "wrong.target.for.polymorphic.signature.definition",
+                            target.name);
+                }
+                // Pull the flag through for better diagnostics, even on a bad target.
+                s.flags_field |= Flags.POLYMORPHIC_SIGNATURE;
+            }
             if (!annotated.add(a.type.tsym))
                 log.error(a.pos, "duplicate.annotation");
         }
@@ -850,7 +868,7 @@
             // If this is a toplevel-class, make sure any preceding import
             // clauses have been seen.
             if (c.owner.kind == PCK) {
-                memberEnter(env.toplevel, env.enclosing(TOPLEVEL));
+                memberEnter(env.toplevel, env.enclosing(JCTree.TOPLEVEL));
                 todo.append(env);
             }
 
diff -u -r javac/comp/Resolve.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Resolve.java
--- javac/comp/Resolve.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/Resolve.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,38 +25,29 @@
 
 package com.sun.tools.javac.comp;
 
-import com.sun.tools.javac.api.Formattable.LocalizedString;
+import com.sun.tools.javac.util.*;
+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.code.*;
-import com.sun.tools.javac.code.Type.*;
-import com.sun.tools.javac.code.Symbol.*;
-import com.sun.tools.javac.comp.Attr.ResultInfo;
-import com.sun.tools.javac.comp.Check.CheckContext;
-import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
 import com.sun.tools.javac.jvm.*;
 import com.sun.tools.javac.tree.*;
+import com.sun.tools.javac.api.Formattable.LocalizedString;
+import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
+
+import com.sun.tools.javac.code.Type.*;
+import com.sun.tools.javac.code.Symbol.*;
 import com.sun.tools.javac.tree.JCTree.*;
-import com.sun.tools.javac.util.*;
+
+import static com.sun.tools.javac.code.Flags.*;
+import static com.sun.tools.javac.code.Kinds.*;
+import static com.sun.tools.javac.code.TypeTags.*;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
+import javax.lang.model.element.ElementVisitor;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.EnumMap;
-import java.util.EnumSet;
-import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
-
-import javax.lang.model.element.ElementVisitor;
-
-import static com.sun.tools.javac.code.Flags.*;
-import static com.sun.tools.javac.code.Flags.BLOCK;
-import static com.sun.tools.javac.code.Kinds.*;
-import static com.sun.tools.javac.code.Kinds.ERRONEOUS;
-import static com.sun.tools.javac.code.TypeTags.*;
-import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
+import java.util.HashMap;
+import java.util.HashSet;
 
 /** Helper class for name resolution, used mostly by the attribution phase.
  *
@@ -72,7 +63,6 @@
     Names names;
     Log log;
     Symtab syms;
-    Attr attr;
     Check chk;
     Infer infer;
     ClassReader reader;
@@ -83,10 +73,16 @@
     public final boolean varargsEnabled; // = source.allowVarargs();
     public final boolean allowMethodHandles;
     private final boolean debugResolve;
-    final EnumSet<VerboseResolutionMode> verboseResolutionMode;
 
     Scope polymorphicSignatureScope;
 
+    public static Resolve instance(Context context) {
+        Resolve instance = context.get(resolveKey);
+        if (instance == null)
+            instance = new Resolve(context);
+        return instance;
+    }
+
     protected Resolve(Context context) {
         context.put(resolveKey, this);
         syms = Symtab.instance(context);
@@ -94,9 +90,9 @@
         varNotFound = new
             SymbolNotFoundError(ABSENT_VAR);
         wrongMethod = new
-            InapplicableSymbolError();
+            InapplicableSymbolError(syms.errSymbol);
         wrongMethods = new
-            InapplicableSymbolsError();
+            InapplicableSymbolsError(syms.errSymbol);
         methodNotFound = new
             SymbolNotFoundError(ABSENT_MTH);
         typeNotFound = new
@@ -104,7 +100,6 @@
 
         names = Names.instance(context);
         log = Log.instance(context);
-        attr = Attr.instance(context);
         chk = Check.instance(context);
         infer = Infer.instance(context);
         reader = ClassReader.instance(context);
@@ -116,7 +111,6 @@
         varargsEnabled = source.allowVarargs();
         Options options = Options.instance(context);
         debugResolve = options.isSet("debugresolve");
-        verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
         Target target = Target.instance(context);
         allowMethodHandles = target.hasMethodHandles();
         polymorphicSignatureScope = new Scope(syms.noSymbol);
@@ -126,123 +120,11 @@
 
     /** error symbols, which are returned when resolution fails
      */
-    private final SymbolNotFoundError varNotFound;
-    private final InapplicableSymbolError wrongMethod;
-    private final InapplicableSymbolsError wrongMethods;
-    private final SymbolNotFoundError methodNotFound;
-    private final SymbolNotFoundError typeNotFound;
-
-    public static Resolve instance(Context context) {
-        Resolve instance = context.get(resolveKey);
-        if (instance == null)
-            instance = new Resolve(context);
-        return instance;
-    }
-
-    // <editor-fold defaultstate="collapsed" desc="Verbose resolution diagnostics support">
-    enum VerboseResolutionMode {
-        SUCCESS("success"),
-        FAILURE("failure"),
-        APPLICABLE("applicable"),
-        INAPPLICABLE("inapplicable"),
-        DEFERRED_INST("deferred-inference"),
-        PREDEF("predef"),
-        OBJECT_INIT("object-init"),
-        INTERNAL("internal");
-
-        String opt;
-
-        private VerboseResolutionMode(String opt) {
-            this.opt = opt;
-        }
-
-        static EnumSet<VerboseResolutionMode> getVerboseResolutionMode(Options opts) {
-            String s = opts.get("verboseResolution");
-            EnumSet<VerboseResolutionMode> res = EnumSet.noneOf(VerboseResolutionMode.class);
-            if (s == null) return res;
-            if (s.contains("all")) {
-                res = EnumSet.allOf(VerboseResolutionMode.class);
-            }
-            Collection<String> args = Arrays.asList(s.split(","));
-            for (VerboseResolutionMode mode : values()) {
-                if (args.contains(mode.opt)) {
-                    res.add(mode);
-                } else if (args.contains("-" + mode.opt)) {
-                    res.remove(mode);
-                }
-            }
-            return res;
-        }
-    }
-
-    void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,
-            List<Type> argtypes, List<Type> typeargtypes, Symbol bestSoFar) {
-        boolean success = bestSoFar.kind < ERRONEOUS;
-
-        if (success && !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {
-            return;
-        } else if (!success && !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {
-            return;
-        }
-
-        if (bestSoFar.name == names.init &&
-                bestSoFar.owner == syms.objectType.tsym &&
-                !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {
-            return; //skip diags for Object constructor resolution
-        } else if (site == syms.predefClass.type &&
-                !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
-            return; //skip spurious diags for predef symbols (i.e. operators)
-        } else if (currentResolutionContext.internalResolution &&
-                !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {
-            return;
-        }
-
-        int pos = 0;
-        int mostSpecificPos = -1;
-        ListBuffer<JCDiagnostic> subDiags = ListBuffer.lb();
-        for (Candidate c : currentResolutionContext.candidates) {
-            if (currentResolutionContext.step != c.step ||
-                    (c.isApplicable() && !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||
-                    (!c.isApplicable() && !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {
-                continue;
-            } else {
-                subDiags.append(c.isApplicable() ?
-                        getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :
-                        getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));
-                if (c.sym == bestSoFar)
-                    mostSpecificPos = pos;
-                pos++;
-            }
-        }
-        String key = success ? "verbose.resolve.multi" : "verbose.resolve.multi.1";
-        JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,
-                site.tsym, mostSpecificPos, currentResolutionContext.step,
-                methodArguments(argtypes), methodArguments(typeargtypes));
-        JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());
-        log.report(d);
-    }
-
-    JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
-        JCDiagnostic subDiag = null;
-        if (inst.getReturnType().tag == FORALL) {
-            Type diagType = types.createMethodTypeWithReturn(inst.asMethodType(),
-                                                            ((ForAll)inst.getReturnType()).qtype);
-            subDiag = diags.fragment("partial.inst.sig", diagType);
-        } else if (sym.type.tag == FORALL) {
-            subDiag = diags.fragment("full.inst.sig", inst.asMethodType());
-        }
-
-        String key = subDiag == null ?
-                "applicable.method.found" :
-                "applicable.method.found.1";
-
-        return diags.fragment(key, pos, sym, subDiag);
-    }
-
-    JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
-        return diags.fragment("not.applicable.method.found", pos, sym, subDiag);
-    }
-    // </editor-fold>
+    final SymbolNotFoundError varNotFound;
+    final InapplicableSymbolError wrongMethod;
+    final InapplicableSymbolsError wrongMethods;
+    final SymbolNotFoundError methodNotFound;
+    final SymbolNotFoundError typeNotFound;
 
 /* ************************************************************************
  * Identifier resolution
@@ -399,6 +281,7 @@
         else {
             Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
             return (s2 == null || s2 == sym || sym.owner == s2.owner ||
+                    s2.isPolymorphicSignatureGeneric() ||
                     !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
         }
     }
@@ -448,6 +331,7 @@
                         boolean useVarargs,
                         Warner warn)
         throws Infer.InferenceException {
+        boolean polymorphicSignature = m.isPolymorphicSignatureGeneric() && allowMethodHandles;
         if (useVarargs && (m.flags() & VARARGS) == 0)
             throw inapplicableMethodException.setMessage();
         Type mt = types.memberType(site, m);
@@ -488,7 +372,8 @@
         }
 
         // find out whether we need to go the slow route via infer
-        boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
+        boolean instNeeded = tvars.tail != null || /*inlined: tvars.nonEmpty()*/
+                polymorphicSignature;
         for (List<Type> l = argtypes;
              l.tail != null/*inlined: l.nonEmpty()*/ && !instNeeded;
              l = l.tail) {
@@ -496,7 +381,9 @@
         }
 
         if (instNeeded)
-            return infer.instantiateMethod(env,
+            return polymorphicSignature ?
+                infer.instantiatePolymorphicSignatureInstance(env, site, m.name, (MethodSymbol)m, argtypes) :
+                infer.instantiateMethod(env,
                                     tvars,
                                     (MethodType)mt,
                                     m,
@@ -543,226 +430,86 @@
             return false;
         }
     }
-    /**
-     * A check handler is used by the main method applicability routine in order
-     * to handle specific method applicability failures. It is assumed that a class
-     * implementing this interface should throw exceptions that are a subtype of
-     * InapplicableMethodException (see below). Such exception will terminate the
-     * method applicability check and propagate important info outwards (for the
-     * purpose of generating better diagnostics).
-     */
-    interface MethodCheckHandler {
-        /* The number of actuals and formals differ */
-        InapplicableMethodException arityMismatch();
-        /* An actual argument type does not conform to the corresponding formal type */
-        InapplicableMethodException argumentMismatch(boolean varargs, Type found, Type expected);
-        /* The element type of a varargs is not accessible in the current context */
-        InapplicableMethodException inaccessibleVarargs(Symbol location, Type expected);
-    }
-
-    /**
-     * Basic method check handler used within Resolve - all methods end up
-     * throwing InapplicableMethodException; a diagnostic fragment that describes
-     * the cause as to why the method is not applicable is set on the exception
-     * before it is thrown.
-     */
-    MethodCheckHandler resolveHandler = new MethodCheckHandler() {
-            public InapplicableMethodException arityMismatch() {
-                return inapplicableMethodException.setMessage("arg.length.mismatch");
-            }
-            public InapplicableMethodException argumentMismatch(boolean varargs, Type found, Type expected) {
-                String key = varargs ?
-                        "varargs.argument.mismatch" :
-                        "no.conforming.assignment.exists";
-                return inapplicableMethodException.setMessage(key,
-                        found, expected);
-            }
-            public InapplicableMethodException inaccessibleVarargs(Symbol location, Type expected) {
-                return inapplicableMethodException.setMessage("inaccessible.varargs.type",
-                        expected, Kinds.kindName(location), location);
-            }
-    };
-
     void checkRawArgumentsAcceptable(Env<AttrContext> env,
                                 List<Type> argtypes,
                                 List<Type> formals,
                                 boolean allowBoxing,
                                 boolean useVarargs,
                                 Warner warn) {
-        checkRawArgumentsAcceptable(env, List.<Type>nil(), argtypes, formals,
-                allowBoxing, useVarargs, warn, resolveHandler);
-    }
-
-    /**
-     * Main method applicability routine. Given a list of actual types A,
-     * a list of formal types F, determines whether the types in A are
-     * compatible (by method invocation conversion) with the types in F.
-     *
-     * Since this routine is shared between overload resolution and method
-     * type-inference, it is crucial that actual types are converted to the
-     * corresponding 'undet' form (i.e. where inference variables are replaced
-     * with undetvars) so that constraints can be propagated and collected.
-     *
-     * Moreover, if one or more types in A is a poly type, this routine calls
-     * Infer.instantiateArg in order to complete the poly type (this might involve
-     * deferred attribution).
-     *
-     * A method check handler (see above) is used in order to report errors.
-     */
-    List<Type> checkRawArgumentsAcceptable(Env<AttrContext> env,
-                                List<Type> undetvars,
-                                List<Type> argtypes,
-                                List<Type> formals,
-                                boolean allowBoxing,
-                                boolean useVarargs,
-                                Warner warn,
-                                MethodCheckHandler handler) {
         Type varargsFormal = useVarargs ? formals.last() : null;
-        ListBuffer<Type> checkedArgs = ListBuffer.lb();
-
         if (varargsFormal == null &&
                 argtypes.size() != formals.size()) {
-            throw handler.arityMismatch(); // not enough args
+            throw inapplicableMethodException.setMessage("arg.length.mismatch"); // not enough args
         }
 
         while (argtypes.nonEmpty() && formals.head != varargsFormal) {
-            ResultInfo resultInfo = methodCheckResult(formals.head, allowBoxing, false, undetvars, handler, warn);
-            checkedArgs.append(resultInfo.check(env.tree.pos(), argtypes.head));
+            boolean works = allowBoxing
+                ? types.isConvertible(argtypes.head, formals.head, warn)
+                : types.isSubtypeUnchecked(argtypes.head, formals.head, warn);
+            if (!works)
+                throw inapplicableMethodException.setMessage("no.conforming.assignment.exists",
+                        argtypes.head,
+                        formals.head);
             argtypes = argtypes.tail;
             formals = formals.tail;
         }
 
-        if (formals.head != varargsFormal) {
-            throw handler.arityMismatch(); // not enough args
-        }
+        if (formals.head != varargsFormal)
+            throw inapplicableMethodException.setMessage("arg.length.mismatch"); // not enough args
 
         if (useVarargs) {
-            //note: if applicability check is triggered by most specific test,
-            //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
             Type elt = types.elemtype(varargsFormal);
             while (argtypes.nonEmpty()) {
-                ResultInfo resultInfo = methodCheckResult(elt, allowBoxing, true, undetvars, handler, warn);
-                checkedArgs.append(resultInfo.check(env.tree.pos(), argtypes.head));
+                if (!types.isConvertible(argtypes.head, elt, warn))
+                    throw inapplicableMethodException.setMessage("varargs.argument.mismatch",
+                            argtypes.head,
+                            elt);
                 argtypes = argtypes.tail;
             }
             //check varargs element type accessibility
-            if (undetvars.isEmpty() && !isAccessible(env, elt)) {
+            if (!isAccessible(env, elt)) {
                 Symbol location = env.enclClass.sym;
-                throw handler.inaccessibleVarargs(location, elt);
+                throw inapplicableMethodException.setMessage("inaccessible.varargs.type",
+                            elt,
+                            Kinds.kindName(location),
+                            location);
             }
         }
-        return checkedArgs.toList();
-    }
-
-    /**
-     * Check context to be used during method applicability checks. A method check
-     * context might contain inference variables.
-     */
-    abstract class MethodCheckContext implements CheckContext {
-
-        MethodCheckHandler handler;
-        boolean useVarargs;
-        List<Type> undetvars;
-        Warner rsWarner;
-
-        public MethodCheckContext(MethodCheckHandler handler, boolean useVarargs, List<Type> undetvars, Warner rsWarner) {
-            this.handler = handler;
-            this.useVarargs = useVarargs;
-            this.undetvars = undetvars;
-            this.rsWarner = rsWarner;
-        }
-
-        public void report(DiagnosticPosition pos, Type found, Type req, JCDiagnostic details) {
-            throw handler.argumentMismatch(useVarargs, found, req);
-        }
-
-        public Type rawInstantiatePoly(ForAll found, Type req, Warner warn) {
-            throw new AssertionError("ForAll in argument position");
-        }
-
-        public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
-            return rsWarner;
-        }
-    }
-
-    /**
-     * Subclass of method check context class that implements strict method conversion.
-     * Strict method conversion checks compatibility between types using subtyping tests.
-     */
-    class StrictMethodContext extends MethodCheckContext {
-
-        public StrictMethodContext(MethodCheckHandler handler, boolean useVarargs, List<Type> undetvars, Warner rsWarner) {
-            super(handler, useVarargs, undetvars, rsWarner);
-        }
-
-        public boolean compatible(Type found, Type req, Warner warn) {
-            return types.isSubtypeUnchecked(found, infer.asUndetType(req, undetvars), warn);
-        }
+        return;
     }
+    // where
+        public static class InapplicableMethodException extends RuntimeException {
+            private static final long serialVersionUID = 0;
 
-    /**
-     * Subclass of method check context class that implements loose method conversion.
-     * Loose method conversion checks compatibility between types using method conversion tests.
-     */
-    class LooseMethodContext extends MethodCheckContext {
-
-        public LooseMethodContext(MethodCheckHandler handler, boolean useVarargs, List<Type> undetvars, Warner rsWarner) {
-            super(handler, useVarargs, undetvars, rsWarner);
-        }
-
-        public boolean compatible(Type found, Type req, Warner warn) {
-            return types.isConvertible(found, infer.asUndetType(req, undetvars), warn);
-        }
-    }
+            JCDiagnostic diagnostic;
+            JCDiagnostic.Factory diags;
 
-    /**
-     * Create a method check context to be used during method applicability check
-     */
-    ResultInfo methodCheckResult(Type to, boolean allowBoxing, boolean useVarargs,
-            List<Type> undetvars, MethodCheckHandler methodHandler, Warner rsWarner) {
-        MethodCheckContext checkContext = allowBoxing ?
-                new LooseMethodContext(methodHandler, useVarargs, undetvars, rsWarner) :
-                new StrictMethodContext(methodHandler, useVarargs, undetvars, rsWarner);
-        return attr.new ResultInfo(VAL, to, checkContext) {
-            @Override
-            protected Type check(DiagnosticPosition pos, Type found) {
-                return super.check(pos, chk.checkNonVoid(pos, types.capture(types.upperBound(found))));
+            InapplicableMethodException(JCDiagnostic.Factory diags) {
+                this.diagnostic = null;
+                this.diags = diags;
+            }
+            InapplicableMethodException setMessage() {
+                this.diagnostic = null;
+                return this;
+            }
+            InapplicableMethodException setMessage(String key) {
+                this.diagnostic = key != null ? diags.fragment(key) : null;
+                return this;
+            }
+            InapplicableMethodException setMessage(String key, Object... args) {
+                this.diagnostic = key != null ? diags.fragment(key, args) : null;
+                return this;
+            }
+            InapplicableMethodException setMessage(JCDiagnostic diag) {
+                this.diagnostic = diag;
+                return this;
             }
-        };
-    }
-
-    public static class InapplicableMethodException extends RuntimeException {
-        private static final long serialVersionUID = 0;
-
-        JCDiagnostic diagnostic;
-        JCDiagnostic.Factory diags;
-
-        InapplicableMethodException(JCDiagnostic.Factory diags) {
-            this.diagnostic = null;
-            this.diags = diags;
-        }
-        InapplicableMethodException setMessage() {
-            this.diagnostic = null;
-            return this;
-        }
-        InapplicableMethodException setMessage(String key) {
-            this.diagnostic = key != null ? diags.fragment(key) : null;
-            return this;
-        }
-        InapplicableMethodException setMessage(String key, Object... args) {
-            this.diagnostic = key != null ? diags.fragment(key, args) : null;
-            return this;
-        }
-        InapplicableMethodException setMessage(JCDiagnostic diag) {
-            this.diagnostic = diag;
-            return this;
-        }
 
-        public JCDiagnostic getDiagnostic() {
-            return diagnostic;
+            public JCDiagnostic getDiagnostic() {
+                return diagnostic;
+            }
         }
-    }
-    private final InapplicableMethodException inapplicableMethodException;
+        private final InapplicableMethodException inapplicableMethodException;
 
 /* ***************************************************************************
  *  Symbol lookup
@@ -937,20 +684,16 @@
         if (!sym.isInheritedIn(site.tsym, types)) return bestSoFar;
         Assert.check(sym.kind < AMBIGUOUS);
         try {
-            Type mt = rawInstantiate(env, site, sym, argtypes, typeargtypes,
+            rawInstantiate(env, site, sym, argtypes, typeargtypes,
                                allowBoxing, useVarargs, Warner.noWarnings);
-            if (!operator)
-                currentResolutionContext.addApplicableCandidate(sym, mt);
         } catch (InapplicableMethodException ex) {
-            if (!operator)
-                currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
             switch (bestSoFar.kind) {
             case ABSENT_MTH:
-                return wrongMethod;
+                return wrongMethod.setWrongSym(sym, ex.getDiagnostic());
             case WRONG_MTH:
-                if (operator) return bestSoFar;
+                wrongMethods.addCandidate(currentStep, wrongMethod.sym, wrongMethod.explanation);
             case WRONG_MTHS:
-                return wrongMethods;
+                return wrongMethods.addCandidate(currentStep, sym, ex.getDiagnostic());
             default:
                 return bestSoFar;
             }
@@ -959,7 +702,7 @@
             return (bestSoFar.kind == ABSENT_MTH)
                 ? new AccessError(env, site, sym)
                 : bestSoFar;
-        }
+            }
         return (bestSoFar.kind > AMBIGUOUS)
             ? sym
             : mostSpecific(sym, bestSoFar, env, site,
@@ -1024,13 +767,16 @@
                                        m2.erasure(types).getParameterTypes()))
                     return ambiguityError(m1, m2);
                 // both abstract, neither overridden; merge throws clause and result type
-                Type mst = mostSpecificReturnType(mt1, mt2);
-                if (mst == null) {
+                Symbol mostSpecific;
+                if (types.returnTypeSubstitutable(mt1, mt2))
+                    mostSpecific = m1;
+                else if (types.returnTypeSubstitutable(mt2, mt1))
+                    mostSpecific = m2;
+                else {
                     // Theoretically, this can't happen, but it is possible
                     // due to error recovery or mixing incompatible class files
                     return ambiguityError(m1, m2);
                 }
-                Symbol mostSpecific = mst == mt1 ? m1 : m2;
                 List<Type> allThrown = chk.intersect(mt1.getThrownTypes(), mt2.getThrownTypes());
                 Type newSig = types.createMethodTypeWithThrown(mostSpecific.type, allThrown);
                 MethodSymbol result = new MethodSymbol(
@@ -1113,28 +859,6 @@
         }
     }
     //where
-    Type mostSpecificReturnType(Type mt1, Type mt2) {
-        Type rt1 = mt1.getReturnType();
-        Type rt2 = mt2.getReturnType();
-
-        if (mt1.tag == FORALL && mt2.tag == FORALL) {
-            //if both are generic methods, adjust return type ahead of subtyping check
-            rt1 = types.subst(rt1, mt1.getTypeArguments(), mt2.getTypeArguments());
-        }
-        //first use subtyping, then return type substitutability
-        if (types.isSubtype(rt1, rt2)) {
-            return mt1;
-        } else if (types.isSubtype(rt2, rt1)) {
-            return mt2;
-        } else if (types.returnTypeSubstitutable(mt1, mt2)) {
-            return mt1;
-        } else if (types.returnTypeSubstitutable(mt2, mt1)) {
-            return mt2;
-        } else {
-            return null;
-        }
-    }
-    //where
     Symbol ambiguityError(Symbol m1, Symbol m2) {
         if (((m1.flags() | m2.flags()) & CLASH) != 0) {
             return (m1.flags() & CLASH) == 0 ? m1 : m2;
@@ -1163,7 +887,7 @@
                       boolean useVarargs,
                       boolean operator) {
         Symbol bestSoFar = methodNotFound;
-        bestSoFar = findMethod(env,
+        return findMethod(env,
                           site,
                           name,
                           argtypes,
@@ -1175,8 +899,6 @@
                           useVarargs,
                           operator,
                           new HashSet<TypeSymbol>());
-        reportVerboseResolutionDiagnostic(env.tree.pos(), name, site, argtypes, typeargtypes, bestSoFar);
-        return bestSoFar;
     }
     // where
     private Symbol findMethod(Env<AttrContext> env,
@@ -1422,7 +1144,7 @@
                 staticOnly = true;
         }
 
-        if (!env.tree.hasTag(IMPORT)) {
+        if (env.tree.getTag() != JCTree.IMPORT) {
             sym = findGlobalType(env, env.toplevel.namedImportScope, name);
             if (sym.exists()) return sym;
             else if (sym.kind < bestSoFar.kind) bestSoFar = sym;
@@ -1667,33 +1389,32 @@
                          Name name,
                          List<Type> argtypes,
                          List<Type> typeargtypes) {
-        MethodResolutionContext prevResolutionContext = currentResolutionContext;
-        try {
-            currentResolutionContext = new MethodResolutionContext();
-            Symbol sym = methodNotFound;
-            List<MethodResolutionPhase> steps = methodResolutionSteps;
-            while (steps.nonEmpty() &&
-                   steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
-                   sym.kind >= ERRONEOUS) {
-                currentResolutionContext.step = steps.head;
-                sym = findFun(env, name, argtypes, typeargtypes,
-                        steps.head.isBoxingRequired,
-                        env.info.varArgs = steps.head.isVarargsRequired);
-                currentResolutionContext.resolutionCache.put(steps.head, sym);
-                steps = steps.tail;
-            }
-            if (sym.kind >= AMBIGUOUS) {//if nothing is found return the 'first' error
-                MethodResolutionPhase errPhase =
-                        currentResolutionContext.firstErroneousResolutionPhase();
-                sym = access(currentResolutionContext.resolutionCache.get(errPhase),
-                        pos, env.enclClass.sym.type, name, false, argtypes, typeargtypes);
-                env.info.varArgs = errPhase.isVarargsRequired;
-            }
-            return sym;
-        }
-        finally {
-            currentResolutionContext = prevResolutionContext;
+        Symbol sym = startResolution();
+        List<MethodResolutionPhase> steps = methodResolutionSteps;
+        while (steps.nonEmpty() &&
+               steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
+               sym.kind >= ERRONEOUS) {
+            currentStep = steps.head;
+            sym = findFun(env, name, argtypes, typeargtypes,
+                    steps.head.isBoxingRequired,
+                    env.info.varArgs = steps.head.isVarargsRequired);
+            methodResolutionCache.put(steps.head, sym);
+            steps = steps.tail;
+        }
+        if (sym.kind >= AMBIGUOUS) {//if nothing is found return the 'first' error
+            MethodResolutionPhase errPhase =
+                    firstErroneousResolutionPhase();
+            sym = access(methodResolutionCache.get(errPhase),
+                    pos, env.enclClass.sym.type, name, false, argtypes, typeargtypes);
+            env.info.varArgs = errPhase.isVarargsRequired;
         }
+        return sym;
+    }
+
+    private Symbol startResolution() {
+        wrongMethod.clear();
+        wrongMethods.clear();
+        return methodNotFound;
     }
 
     /** Resolve a qualified method identifier
@@ -1713,71 +1434,80 @@
     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env<AttrContext> env,
                                   Symbol location, Type site, Name name, List<Type> argtypes,
                                   List<Type> typeargtypes) {
-        return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);
-    }
-    private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,
-                                  DiagnosticPosition pos, Env<AttrContext> env,
-                                  Symbol location, Type site, Name name, List<Type> argtypes,
-                                  List<Type> typeargtypes) {
-        MethodResolutionContext prevResolutionContext = currentResolutionContext;
-        try {
-            currentResolutionContext = resolveContext;
-            Symbol sym = methodNotFound;
-            List<MethodResolutionPhase> steps = methodResolutionSteps;
-            while (steps.nonEmpty() &&
-                   steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
-                   sym.kind >= ERRONEOUS) {
-                currentResolutionContext.step = steps.head;
-                sym = findMethod(env, site, name, argtypes, typeargtypes,
-                        steps.head.isBoxingRequired(),
-                        env.info.varArgs = steps.head.isVarargsRequired(), false);
-                currentResolutionContext.resolutionCache.put(steps.head, sym);
-                steps = steps.tail;
+        Symbol sym = startResolution();
+        List<MethodResolutionPhase> steps = methodResolutionSteps;
+        while (steps.nonEmpty() &&
+               steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
+               sym.kind >= ERRONEOUS) {
+            currentStep = steps.head;
+            sym = findMethod(env, site, name, argtypes, typeargtypes,
+                    steps.head.isBoxingRequired(),
+                    env.info.varArgs = steps.head.isVarargsRequired(), false);
+            methodResolutionCache.put(steps.head, sym);
+            steps = steps.tail;
+        }
+        if (sym.kind >= AMBIGUOUS) {
+            if (site.tsym.isPolymorphicSignatureGeneric()) {
+                //polymorphic receiver - synthesize new method symbol
+                env.info.varArgs = false;
+                sym = findPolymorphicSignatureInstance(env,
+                        site, name, null, argtypes);
             }
-            if (sym.kind >= AMBIGUOUS) {
+            else {
                 //if nothing is found return the 'first' error
                 MethodResolutionPhase errPhase =
-                        currentResolutionContext.firstErroneousResolutionPhase();
-                sym = access(currentResolutionContext.resolutionCache.get(errPhase),
+                        firstErroneousResolutionPhase();
+                sym = access(methodResolutionCache.get(errPhase),
                         pos, location, site, name, true, argtypes, typeargtypes);
                 env.info.varArgs = errPhase.isVarargsRequired;
-            } else if (allowMethodHandles) {
-                MethodSymbol msym = (MethodSymbol)sym;
-                if (msym.isSignaturePolymorphic(types)) {
-                    env.info.varArgs = false;
-                    return findPolymorphicSignatureInstance(env, sym, argtypes);
-                }
             }
-            return sym;
-        }
-        finally {
-            currentResolutionContext = prevResolutionContext;
+        } else if (allowMethodHandles && sym.isPolymorphicSignatureGeneric()) {
+            //non-instantiated polymorphic signature - synthesize new method symbol
+            env.info.varArgs = false;
+            sym = findPolymorphicSignatureInstance(env,
+                    site, name, (MethodSymbol)sym, argtypes);
         }
+        return sym;
     }
 
     /** Find or create an implicit method of exactly the given type (after erasure).
      *  Searches in a side table, not the main scope of the site.
      *  This emulates the lookup process required by JSR 292 in JVM.
      *  @param env       Attribution environment
-     *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
-     *  @param argtypes  The required argument types
-     */
-    Symbol findPolymorphicSignatureInstance(Env<AttrContext> env,
-                                            Symbol spMethod,
+     *  @param site      The original type from where the selection takes place.
+     *  @param name      The method's name.
+     *  @param spMethod  A template for the implicit method, or null.
+     *  @param argtypes  The required argument types.
+     *  @param typeargtypes  The required type arguments.
+     */
+    Symbol findPolymorphicSignatureInstance(Env<AttrContext> env, Type site,
+                                            Name name,
+                                            MethodSymbol spMethod,  // sig. poly. method or null if none
                                             List<Type> argtypes) {
         Type mtype = infer.instantiatePolymorphicSignatureInstance(env,
-                (MethodSymbol)spMethod, argtypes);
-        for (Symbol sym : polymorphicSignatureScope.getElementsByName(spMethod.name)) {
-            if (types.isSameType(mtype, sym.type)) {
-               return sym;
+                site, name, spMethod, argtypes);
+        long flags = ABSTRACT | HYPOTHETICAL | POLYMORPHIC_SIGNATURE |
+                    (spMethod != null ?
+                        spMethod.flags() & Flags.AccessFlags :
+                        Flags.PUBLIC | Flags.STATIC);
+        Symbol m = null;
+        for (Scope.Entry e = polymorphicSignatureScope.lookup(name);
+             e.scope != null;
+             e = e.next()) {
+            Symbol sym = e.sym;
+            if (types.isSameType(mtype, sym.type) &&
+                (sym.flags() & Flags.STATIC) == (flags & Flags.STATIC) &&
+                types.isSameType(sym.owner.type, site)) {
+               m = sym;
+               break;
             }
         }
-
-        // create the desired method
-        long flags = ABSTRACT | HYPOTHETICAL | spMethod.flags() & Flags.AccessFlags;
-        Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner);
-        polymorphicSignatureScope.enter(msym);
-        return msym;
+        if (m == null) {
+            // create the desired method
+            m = new MethodSymbol(flags, name, mtype, site.tsym);
+            polymorphicSignatureScope.enter(m);
+        }
+        return m;
     }
 
     /** Resolve a qualified method identifier, throw a fatal error if not
@@ -1794,10 +1524,8 @@
                                         Type site, Name name,
                                         List<Type> argtypes,
                                         List<Type> typeargtypes) {
-        MethodResolutionContext resolveContext = new MethodResolutionContext();
-        resolveContext.internalResolution = true;
-        Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
-                site, name, argtypes, typeargtypes);
+        Symbol sym = resolveQualifiedMethod(
+            pos, env, site.tsym, site, name, argtypes, typeargtypes);
         if (sym.kind == MTH) return (MethodSymbol)sym;
         else throw new FatalError(
                  diags.fragment("fatal.err.cant.locate.meth",
@@ -1818,40 +1546,25 @@
                               Type site,
                               List<Type> argtypes,
                               List<Type> typeargtypes) {
-        return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
-    }
-    private Symbol resolveConstructor(MethodResolutionContext resolveContext,
-                              DiagnosticPosition pos,
-                              Env<AttrContext> env,
-                              Type site,
-                              List<Type> argtypes,
-                              List<Type> typeargtypes) {
-        MethodResolutionContext prevResolutionContext = currentResolutionContext;
-        try {
-            currentResolutionContext = resolveContext;
-            Symbol sym = methodNotFound;
-            List<MethodResolutionPhase> steps = methodResolutionSteps;
-            while (steps.nonEmpty() &&
-                   steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
-                   sym.kind >= ERRONEOUS) {
-                currentResolutionContext.step = steps.head;
-                sym = findConstructor(pos, env, site, argtypes, typeargtypes,
-                        steps.head.isBoxingRequired(),
-                        env.info.varArgs = steps.head.isVarargsRequired());
-                currentResolutionContext.resolutionCache.put(steps.head, sym);
-                steps = steps.tail;
-            }
-            if (sym.kind >= AMBIGUOUS) {//if nothing is found return the 'first' error
-                MethodResolutionPhase errPhase = currentResolutionContext.firstErroneousResolutionPhase();
-                sym = access(currentResolutionContext.resolutionCache.get(errPhase),
-                        pos, site, names.init, true, argtypes, typeargtypes);
-                env.info.varArgs = errPhase.isVarargsRequired();
-            }
-            return sym;
-        }
-        finally {
-            currentResolutionContext = prevResolutionContext;
+        Symbol sym = startResolution();
+        List<MethodResolutionPhase> steps = methodResolutionSteps;
+        while (steps.nonEmpty() &&
+               steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
+               sym.kind >= ERRONEOUS) {
+            currentStep = steps.head;
+            sym = resolveConstructor(pos, env, site, argtypes, typeargtypes,
+                    steps.head.isBoxingRequired(),
+                    env.info.varArgs = steps.head.isVarargsRequired());
+            methodResolutionCache.put(steps.head, sym);
+            steps = steps.tail;
+        }
+        if (sym.kind >= AMBIGUOUS) {//if nothing is found return the 'first' error
+            MethodResolutionPhase errPhase = firstErroneousResolutionPhase();
+            sym = access(methodResolutionCache.get(errPhase),
+                    pos, site, names.init, true, argtypes, typeargtypes);
+            env.info.varArgs = errPhase.isVarargsRequired();
         }
+        return sym;
     }
 
     /** Resolve constructor using diamond inference.
@@ -1869,82 +1582,38 @@
                               Type site,
                               List<Type> argtypes,
                               List<Type> typeargtypes) {
-        MethodResolutionContext prevResolutionContext = currentResolutionContext;
-        try {
-            currentResolutionContext = new MethodResolutionContext();
-            Symbol sym = methodNotFound;
-            List<MethodResolutionPhase> steps = methodResolutionSteps;
-            while (steps.nonEmpty() &&
-                   steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
-                   sym.kind >= ERRONEOUS) {
-                currentResolutionContext.step = steps.head;
-                sym = findDiamond(env, site, argtypes, typeargtypes,
-                        steps.head.isBoxingRequired(),
-                        env.info.varArgs = steps.head.isVarargsRequired());
-                currentResolutionContext.resolutionCache.put(steps.head, sym);
-                steps = steps.tail;
-            }
-            if (sym.kind >= AMBIGUOUS) {
-                final JCDiagnostic details = sym.kind == WRONG_MTH ?
-                                currentResolutionContext.candidates.head.details :
-                                null;
-                Symbol errSym = new ResolveError(WRONG_MTH, "diamond error") {
-                    @Override
-                    JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
-                            Symbol location, Type site, Name name, List<Type> argtypes, List<Type> typeargtypes) {
-                        String key = details == null ?
-                            "cant.apply.diamond" :
-                            "cant.apply.diamond.1";
-                        return diags.create(dkind, log.currentSource(), pos, key,
-                                diags.fragment("diamond", site.tsym), details);
-                    }
-                };
-                MethodResolutionPhase errPhase = currentResolutionContext.firstErroneousResolutionPhase();
-                sym = access(errSym, pos, site, names.init, true, argtypes, typeargtypes);
-                env.info.varArgs = errPhase.isVarargsRequired();
-            }
-            return sym;
-        }
-        finally {
-            currentResolutionContext = prevResolutionContext;
+        Symbol sym = startResolution();
+        List<MethodResolutionPhase> steps = methodResolutionSteps;
+        while (steps.nonEmpty() &&
+               steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
+               sym.kind >= ERRONEOUS) {
+            currentStep = steps.head;
+            sym = resolveConstructor(pos, env, site, argtypes, typeargtypes,
+                    steps.head.isBoxingRequired(),
+                    env.info.varArgs = steps.head.isVarargsRequired());
+            methodResolutionCache.put(steps.head, sym);
+            steps = steps.tail;
         }
-    }
-
-    /** This method scans all the constructor symbol in a given class scope -
-     *  assuming that the original scope contains a constructor of the kind:
-     *  Foo(X x, Y y), where X,Y are class type-variables declared in Foo,
-     *  a method check is executed against the modified constructor type:
-     *  <X,Y>Foo<X,Y>(X x, Y y). This is crucial in order to enable diamond
-     *  inference. The inferred return type of the synthetic constructor IS
-     *  the inferred type for the diamond operator.
-     */
-    private Symbol findDiamond(Env<AttrContext> env,
-                              Type site,
-                              List<Type> argtypes,
-                              List<Type> typeargtypes,
-                              boolean allowBoxing,
-                              boolean useVarargs) {
-        Symbol bestSoFar = methodNotFound;
-        for (Scope.Entry e = site.tsym.members().lookup(names.init);
-             e.scope != null;
-             e = e.next()) {
-            //- System.out.println(" e " + e.sym);
-            if (e.sym.kind == MTH &&
-                (e.sym.flags_field & SYNTHETIC) == 0) {
-                    List<Type> oldParams = e.sym.type.tag == FORALL ?
-                            ((ForAll)e.sym.type).tvars :
-                            List.<Type>nil();
-                    Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),
-                            types.createMethodTypeWithReturn(e.sym.type.asMethodType(), site));
-                    bestSoFar = selectBest(env, site, argtypes, typeargtypes,
-                            new MethodSymbol(e.sym.flags(), names.init, constrType, site.tsym),
-                            bestSoFar,
-                            allowBoxing,
-                            useVarargs,
-                            false);
-            }
+        if (sym.kind >= AMBIGUOUS) {
+            final JCDiagnostic details = sym.kind == WRONG_MTH ?
+                ((InapplicableSymbolError)sym).explanation :
+                null;
+            Symbol errSym = new ResolveError(WRONG_MTH, "diamond error") {
+                @Override
+                JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
+                        Symbol location, Type site, Name name, List<Type> argtypes, List<Type> typeargtypes) {
+                    String key = details == null ?
+                        "cant.apply.diamond" :
+                        "cant.apply.diamond.1";
+                    return diags.create(dkind, log.currentSource(), pos, key,
+                            diags.fragment("diamond", site.tsym), details);
+                }
+            };
+            MethodResolutionPhase errPhase = firstErroneousResolutionPhase();
+            sym = access(errSym, pos, site, names.init, true, argtypes, typeargtypes);
+            env.info.varArgs = errPhase.isVarargsRequired();
         }
-        return bestSoFar;
+        return sym;
     }
 
     /** Resolve constructor.
@@ -1963,25 +1632,10 @@
                               List<Type> typeargtypes,
                               boolean allowBoxing,
                               boolean useVarargs) {
-        MethodResolutionContext prevResolutionContext = currentResolutionContext;
-        try {
-            currentResolutionContext = new MethodResolutionContext();
-            return findConstructor(pos, env, site, argtypes, typeargtypes, allowBoxing, useVarargs);
-        }
-        finally {
-            currentResolutionContext = prevResolutionContext;
-        }
-    }
-
-    Symbol findConstructor(DiagnosticPosition pos, Env<AttrContext> env,
-                              Type site, List<Type> argtypes,
-                              List<Type> typeargtypes,
-                              boolean allowBoxing,
-                              boolean useVarargs) {
         Symbol sym = findMethod(env, site,
-                                    names.init, argtypes,
-                                    typeargtypes, allowBoxing,
-                                    useVarargs, false);
+                                names.init, argtypes,
+                                typeargtypes, allowBoxing,
+                                useVarargs, false);
         chk.checkDeprecated(pos, env.info.scope.owner, sym);
         return sym;
     }
@@ -1997,9 +1651,8 @@
                                         Type site,
                                         List<Type> argtypes,
                                         List<Type> typeargtypes) {
-        MethodResolutionContext resolveContext = new MethodResolutionContext();
-        resolveContext.internalResolution = true;
-        Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
+        Symbol sym = resolveConstructor(
+            pos, env, site, argtypes, typeargtypes);
         if (sym.kind == MTH) return (MethodSymbol)sym;
         else throw new FatalError(
                  diags.fragment("fatal.err.cant.locate.ctor", site));
@@ -2011,23 +1664,16 @@
      *  @param env       The environment current at the operation.
      *  @param argtypes  The types of the operands.
      */
-    Symbol resolveOperator(DiagnosticPosition pos, JCTree.Tag optag,
+    Symbol resolveOperator(DiagnosticPosition pos, int optag,
                            Env<AttrContext> env, List<Type> argtypes) {
-        MethodResolutionContext prevResolutionContext = currentResolutionContext;
-        try {
-            currentResolutionContext = new MethodResolutionContext();
-            Name name = treeinfo.operatorName(optag);
-            Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
-                                    null, false, false, true);
-            if (boxingEnabled && sym.kind >= WRONG_MTHS)
-                sym = findMethod(env, syms.predefClass.type, name, argtypes,
-                                 null, true, false, true);
-            return access(sym, pos, env.enclClass.sym.type, name,
-                          false, argtypes, null);
-        }
-        finally {
-            currentResolutionContext = prevResolutionContext;
-        }
+        Name name = treeinfo.operatorName(optag);
+        Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
+                                null, false, false, true);
+        if (boxingEnabled && sym.kind >= WRONG_MTHS)
+            sym = findMethod(env, syms.predefClass.type, name, argtypes,
+                             null, true, false, true);
+        return access(sym, pos, env.enclClass.sym.type, name,
+                      false, argtypes, null);
     }
 
     /** Resolve operator.
@@ -2036,7 +1682,7 @@
      *  @param env       The environment current at the operation.
      *  @param arg       The type of the operand.
      */
-    Symbol resolveUnaryOperator(DiagnosticPosition pos, JCTree.Tag optag, Env<AttrContext> env, Type arg) {
+    Symbol resolveUnaryOperator(DiagnosticPosition pos, int optag, Env<AttrContext> env, Type arg) {
         return resolveOperator(pos, optag, env, List.of(arg));
     }
 
@@ -2048,7 +1694,7 @@
      *  @param right     The types of the right operand.
      */
     Symbol resolveBinaryOperator(DiagnosticPosition pos,
-                                 JCTree.Tag optag,
+                                 int optag,
                                  Env<AttrContext> env,
                                  Type left,
                                  Type right) {
@@ -2140,10 +1786,9 @@
  *  ResolveError classes, indicating error situations when accessing symbols
  ****************************************************************************/
 
-    //used by TransTypes when checking target type of synthetic cast
-    public void logAccessErrorInternal(Env<AttrContext> env, JCTree tree, Type type) {
-        AccessError error = new AccessError(env, env.enclClass.type, type.tsym);
-        logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
+    public void logAccessError(Env<AttrContext> env, JCTree tree, Type type) {
+        AccessError error = new AccessError(env, type.getEnclosingType(), type.tsym);
+        logResolveError(error, tree.pos(), type.getEnclosingType().tsym, type.getEnclosingType(), null, null, null);
     }
     //where
     private void logResolveError(ResolveError error,
@@ -2164,7 +1809,7 @@
     private final LocalizedString noArgs = new LocalizedString("compiler.misc.no.args");
 
     public Object methodArguments(List<Type> argtypes) {
-        return argtypes == null || argtypes.isEmpty() ? noArgs : argtypes;
+        return argtypes.isEmpty() ? noArgs : argtypes;
     }
 
     /**
@@ -2372,24 +2017,34 @@
      * (either a method, a constructor or an operand) is not applicable
      * given an actual arguments/type argument list.
      */
-    class InapplicableSymbolError extends ResolveError {
+    class InapplicableSymbolError extends InvalidSymbolError {
+
+        /** An auxiliary explanation set in case of instantiation errors. */
+        JCDiagnostic explanation;
 
-        InapplicableSymbolError() {
-            super(WRONG_MTH, "inapplicable symbol error");
+        InapplicableSymbolError(Symbol sym) {
+            super(WRONG_MTH, sym, "inapplicable symbol error");
         }
 
-        protected InapplicableSymbolError(int kind, String debugName) {
-            super(kind, debugName);
+        /** Update sym and explanation and return this.
+         */
+        InapplicableSymbolError setWrongSym(Symbol sym, JCDiagnostic explanation) {
+            this.sym = sym;
+            if (this.sym == sym && explanation != null)
+                this.explanation = explanation; //update the details
+            return this;
         }
 
-        @Override
-        public String toString() {
-            return super.toString();
+        /** Update sym and return this.
+         */
+        InapplicableSymbolError setWrongSym(Symbol sym) {
+            this.sym = sym;
+            return this;
         }
 
         @Override
-        public boolean exists() {
-            return true;
+        public String toString() {
+            return super.toString() + " explanation=" + explanation;
         }
 
         @Override
@@ -2414,40 +2069,27 @@
                         key, name, first, second);
             }
             else {
-                Candidate c = errCandidate();
-                Symbol ws = c.sym.asMemberOf(site, types);
+                Symbol ws = sym.asMemberOf(site, types);
                 return diags.create(dkind, log.currentSource(), pos,
-                          "cant.apply.symbol" + (c.details != null ? ".1" : ""),
+                          "cant.apply.symbol" + (explanation != null ? ".1" : ""),
                           kindName(ws),
                           ws.name == names.init ? ws.owner.name : ws.name,
                           methodArguments(ws.type.getParameterTypes()),
                           methodArguments(argtypes),
                           kindName(ws.owner),
                           ws.owner.type,
-                          c.details);
+                          explanation);
             }
         }
 
+        void clear() {
+            explanation = null;
+        }
+
         @Override
         public Symbol access(Name name, TypeSymbol location) {
             return types.createErrorType(name, location, syms.errSymbol.type).tsym;
         }
-
-        protected boolean shouldReport(Candidate c) {
-            return !c.isApplicable() &&
-                    (((c.sym.flags() & VARARGS) != 0 && c.step == VARARITY) ||
-                      (c.sym.flags() & VARARGS) == 0 && c.step == (boxingEnabled ? BOX : BASIC));
-        }
-
-        private Candidate errCandidate() {
-            for (Candidate c : currentResolutionContext.candidates) {
-                if (shouldReport(c)) {
-                    return c;
-                }
-            }
-            Assert.error();
-            return null;
-        }
     }
 
     /**
@@ -2455,9 +2097,11 @@
      * (either methods, constructors or operands) is not applicable
      * given an actual arguments/type argument list.
      */
-    class InapplicableSymbolsError extends InapplicableSymbolError {
+    class InapplicableSymbolsError extends ResolveError {
+
+        private List<Candidate> candidates = List.nil();
 
-        InapplicableSymbolsError() {
+        InapplicableSymbolsError(Symbol sym) {
             super(WRONG_MTHS, "inapplicable symbols");
         }
 
@@ -2469,7 +2113,7 @@
                 Name name,
                 List<Type> argtypes,
                 List<Type> typeargtypes) {
-            if (currentResolutionContext.candidates.nonEmpty()) {
+            if (candidates.nonEmpty()) {
                 JCDiagnostic err = diags.create(dkind,
                         log.currentSource(),
                         pos,
@@ -2487,24 +2131,68 @@
         //where
         List<JCDiagnostic> candidateDetails(Type site) {
             List<JCDiagnostic> details = List.nil();
-            for (Candidate c : currentResolutionContext.candidates) {
-                if (!shouldReport(c)) continue;
-                JCDiagnostic detailDiag = diags.fragment("inapplicable.method",
-                        Kinds.kindName(c.sym),
-                        c.sym.location(site, types),
-                        c.sym.asMemberOf(site, types),
-                        c.details);
-                details = details.prepend(detailDiag);
-            }
+            for (Candidate c : candidates)
+                details = details.prepend(c.getDiagnostic(site));
             return details.reverse();
         }
 
+        Symbol addCandidate(MethodResolutionPhase currentStep, Symbol sym, JCDiagnostic details) {
+            Candidate c = new Candidate(currentStep, sym, details);
+            if (c.isValid() && !candidates.contains(c))
+                candidates = candidates.append(c);
+            return this;
+        }
+
+        void clear() {
+            candidates = List.nil();
+        }
+
         private Name getName() {
-            Symbol sym = currentResolutionContext.candidates.head.sym;
+            Symbol sym = candidates.head.sym;
             return sym.name == names.init ?
                 sym.owner.name :
                 sym.name;
         }
+
+        private class Candidate {
+
+            final MethodResolutionPhase step;
+            final Symbol sym;
+            final JCDiagnostic details;
+
+            private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details) {
+                this.step = step;
+                this.sym = sym;
+                this.details = details;
+            }
+
+            JCDiagnostic getDiagnostic(Type site) {
+                return diags.fragment("inapplicable.method",
+                        Kinds.kindName(sym),
+                        sym.location(site, types),
+                        sym.asMemberOf(site, types),
+                        details);
+            }
+
+            @Override
+            public boolean equals(Object o) {
+                if (o instanceof Candidate) {
+                    Symbol s1 = this.sym;
+                    Symbol s2 = ((Candidate)o).sym;
+                    if  ((s1 != s2 &&
+                        (s1.overrides(s2, s1.owner.type.tsym, types, false) ||
+                        (s2.overrides(s1, s2.owner.type.tsym, types, false)))) ||
+                        ((s1.isConstructor() || s2.isConstructor()) && s1.owner != s2.owner))
+                        return true;
+                }
+                return false;
+            }
+
+            boolean isValid() {
+                return  (((sym.flags() & VARARGS) != 0 && step == VARARITY) ||
+                          (sym.flags() & VARARGS) == 0 && step == (boxingEnabled ? BOX : BASIC));
+            }
+        }
     }
 
     /**
@@ -2665,91 +2353,24 @@
         }
     }
 
-    final List<MethodResolutionPhase> methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
-
-    /**
-     * A resolution context is used to keep track of intermediate results of
-     * overload resolution, such as list of method that are not applicable
-     * (used to generate more precise diagnostics) and so on. Resolution contexts
-     * can be nested - this means that when each overload resolution routine should
-     * work within the resolution context it created.
-     */
-    class MethodResolutionContext {
-
-        private List<Candidate> candidates = List.nil();
-
-        private Map<MethodResolutionPhase, Symbol> resolutionCache =
-            new EnumMap<MethodResolutionPhase, Symbol>(MethodResolutionPhase.class);
+    private Map<MethodResolutionPhase, Symbol> methodResolutionCache =
+        new HashMap<MethodResolutionPhase, Symbol>(MethodResolutionPhase.values().length);
 
-        private MethodResolutionPhase step = null;
-
-        private boolean internalResolution = false;
-
-        private MethodResolutionPhase firstErroneousResolutionPhase() {
-            MethodResolutionPhase bestSoFar = BASIC;
-            Symbol sym = methodNotFound;
-            List<MethodResolutionPhase> steps = methodResolutionSteps;
-            while (steps.nonEmpty() &&
-                   steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
-                   sym.kind >= WRONG_MTHS) {
-                sym = resolutionCache.get(steps.head);
-                bestSoFar = steps.head;
-                steps = steps.tail;
-            }
-            return bestSoFar;
-        }
-
-        void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
-            Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
-            if (!candidates.contains(c))
-                candidates = candidates.append(c);
-        }
-
-        void addApplicableCandidate(Symbol sym, Type mtype) {
-            Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
-            candidates = candidates.append(c);
-        }
-
-        /**
-         * This class represents an overload resolution candidate. There are two
-         * kinds of candidates: applicable methods and inapplicable methods;
-         * applicable methods have a pointer to the instantiated method type,
-         * while inapplicable candidates contain further details about the
-         * reason why the method has been considered inapplicable.
-         */
-        class Candidate {
-
-            final MethodResolutionPhase step;
-            final Symbol sym;
-            final JCDiagnostic details;
-            final Type mtype;
-
-            private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
-                this.step = step;
-                this.sym = sym;
-                this.details = details;
-                this.mtype = mtype;
-            }
+    final List<MethodResolutionPhase> methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
 
-            @Override
-            public boolean equals(Object o) {
-                if (o instanceof Candidate) {
-                    Symbol s1 = this.sym;
-                    Symbol s2 = ((Candidate)o).sym;
-                    if  ((s1 != s2 &&
-                        (s1.overrides(s2, s1.owner.type.tsym, types, false) ||
-                        (s2.overrides(s1, s2.owner.type.tsym, types, false)))) ||
-                        ((s1.isConstructor() || s2.isConstructor()) && s1.owner != s2.owner))
-                        return true;
-                }
-                return false;
-            }
+    private MethodResolutionPhase currentStep = null;
 
-            boolean isApplicable() {
-                return mtype != null;
-            }
+    private MethodResolutionPhase firstErroneousResolutionPhase() {
+        MethodResolutionPhase bestSoFar = BASIC;
+        Symbol sym = methodNotFound;
+        List<MethodResolutionPhase> steps = methodResolutionSteps;
+        while (steps.nonEmpty() &&
+               steps.head.isApplicable(boxingEnabled, varargsEnabled) &&
+               sym.kind >= WRONG_MTHS) {
+            sym = methodResolutionCache.get(steps.head);
+            bestSoFar = steps.head;
+            steps = steps.tail;
         }
+        return bestSoFar;
     }
-
-    MethodResolutionContext currentResolutionContext = null;
 }
diff -u -r javac/comp/TransTypes.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/TransTypes.java
--- javac/comp/TransTypes.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/comp/TransTypes.java	2011-06-27 15:21:47.000000000 -0500
@@ -107,7 +107,7 @@
         make.at(tree.pos);
         if (!types.isSameType(tree.type, target)) {
             if (!resolve.isAccessible(env, target.tsym))
-                resolve.logAccessErrorInternal(env, tree, target);
+                resolve.logAccessError(env, tree, target);
             tree = make.TypeCast(make.Type(target), tree).setType(target);
         }
         make.pos = oldpos;
diff -u -r javac/file/JavacFileManager.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/file/JavacFileManager.java
--- javac/file/JavacFileManager.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/file/JavacFileManager.java	2011-06-27 15:21:47.000000000 -0500
@@ -25,6 +25,7 @@
 
 package com.sun.tools.javac.file;
 
+import java.util.Comparator;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -40,7 +41,6 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -56,12 +56,14 @@
 
 import com.sun.tools.javac.file.RelativePath.RelativeFile;
 import com.sun.tools.javac.file.RelativePath.RelativeDirectory;
+import com.sun.tools.javac.main.OptionName;
 import com.sun.tools.javac.util.BaseFileManager;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.ListBuffer;
 
 import static javax.tools.StandardLocation.*;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /**
  * This class provides access to the source, class and other files
@@ -81,14 +83,32 @@
             return buffer.toString().toCharArray();
     }
 
+    /** Encapsulates knowledge of paths
+     */
+    private Paths paths;
+
     private FSInfo fsInfo;
 
     private boolean contextUseOptimizedZip;
     private ZipFileIndexCache zipFileIndexCache;
 
+    private final File uninited = new File("U N I N I T E D");
+
     private final Set<JavaFileObject.Kind> sourceOrClass =
         EnumSet.of(JavaFileObject.Kind.SOURCE, JavaFileObject.Kind.CLASS);
 
+    /** The standard output directory, primarily used for classes.
+     *  Initialized by the "-d" option.
+     *  If classOutDir = null, files are written into same directory as the sources
+     *  they were generated from.
+     */
+    private File classOutDir = uninited;
+
+    /** The output directory, used when generating sources while processing annotations.
+     *  Initialized by the "-s" option.
+     */
+    private File sourceOutDir = uninited;
+
     protected boolean mmappedIO;
     protected boolean ignoreSymbolFile;
 
@@ -134,6 +154,13 @@
     @Override
     public void setContext(Context context) {
         super.setContext(context);
+        if (paths == null) {
+            paths = Paths.instance(context);
+        } else {
+            // Reuse the Paths object as it stores the locations that
+            // have been set with setLocation, etc.
+            paths.setContext(context);
+        }
 
         fsInfo = FSInfo.instance(context);
 
@@ -152,7 +179,7 @@
 
     @Override
     public boolean isDefaultBootClassPath() {
-        return locations.isDefaultBootClassPath();
+        return paths.isDefaultBootClassPath();
     }
 
     public JavaFileObject getFileForInput(String name) {
@@ -466,7 +493,7 @@
      */
     private Archive openArchive(File zipFileName, boolean useOptimizedZip) throws IOException {
         File origZipFileName = zipFileName;
-        if (!ignoreSymbolFile && locations.isDefaultBootClassPathRtJar(zipFileName)) {
+        if (!ignoreSymbolFile && paths.isDefaultBootClassPathRtJar(zipFileName)) {
             File file = zipFileName.getParentFile().getParentFile(); // ${java.home}
             if (new File(file.getName()).equals(new File("jre")))
                 file = file.getParentFile();
@@ -753,7 +780,7 @@
         } else if (location == SOURCE_OUTPUT) {
             dir = (getSourceOutDir() != null ? getSourceOutDir() : getClassOutDir());
         } else {
-            Iterable<? extends File> path = locations.getLocation(location);
+            Iterable<? extends File> path = paths.getPathForLocation(location);
             dir = null;
             for (File f: path) {
                 dir = f;
@@ -788,20 +815,64 @@
         throws IOException
     {
         nullCheck(location);
-        locations.setLocation(location, path);
+        paths.lazy();
+
+        final File dir = location.isOutputLocation() ? getOutputDirectory(path) : null;
+
+        if (location == CLASS_OUTPUT)
+            classOutDir = getOutputLocation(dir, D);
+        else if (location == SOURCE_OUTPUT)
+            sourceOutDir = getOutputLocation(dir, S);
+        else
+            paths.setPathForLocation(location, path);
+    }
+    // where
+        private File getOutputDirectory(Iterable<? extends File> path) throws IOException {
+            if (path == null)
+                return null;
+            Iterator<? extends File> pathIter = path.iterator();
+            if (!pathIter.hasNext())
+                throw new IllegalArgumentException("empty path for directory");
+            File dir = pathIter.next();
+            if (pathIter.hasNext())
+                throw new IllegalArgumentException("path too long for directory");
+            if (!dir.exists())
+                throw new FileNotFoundException(dir + ": does not exist");
+            else if (!dir.isDirectory())
+                throw new IOException(dir + ": not a directory");
+            return dir;
+        }
+
+    private File getOutputLocation(File dir, OptionName defaultOptionName) {
+        if (dir != null)
+            return dir;
+        String arg = options.get(defaultOptionName);
+        if (arg == null)
+            return null;
+        return new File(arg);
     }
 
     public Iterable<? extends File> getLocation(Location location) {
         nullCheck(location);
-        return locations.getLocation(location);
+        paths.lazy();
+        if (location == CLASS_OUTPUT) {
+            return (getClassOutDir() == null ? null : List.of(getClassOutDir()));
+        } else if (location == SOURCE_OUTPUT) {
+            return (getSourceOutDir() == null ? null : List.of(getSourceOutDir()));
+        } else
+            return paths.getPathForLocation(location);
     }
 
     private File getClassOutDir() {
-        return locations.getOutputLocation(CLASS_OUTPUT);
+        if (classOutDir == uninited)
+            classOutDir = getOutputLocation(null, D);
+        return classOutDir;
     }
 
     private File getSourceOutDir() {
-        return locations.getOutputLocation(SOURCE_OUTPUT);
+        if (sourceOutDir == uninited)
+            sourceOutDir = getOutputLocation(null, S);
+        return sourceOutDir;
     }
 
     /**
Only in javac/file: Locations.java
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/file: Paths.java
diff -u -r javac/file/RegularFileObject.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/file/RegularFileObject.java
--- javac/file/RegularFileObject.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/file/RegularFileObject.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -98,7 +98,6 @@
 
     @Override
     public OutputStream openOutputStream() throws IOException {
-        fileManager.flushCache(this);
         ensureParentDirectoriesExist();
         return new FileOutputStream(file);
     }
@@ -129,7 +128,6 @@
 
     @Override
     public Writer openWriter() throws IOException {
-        fileManager.flushCache(this);
         ensureParentDirectoriesExist();
         return new OutputStreamWriter(new FileOutputStream(file), fileManager.getEncodingName());
     }
diff -u -r javac/jvm/ClassReader.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/ClassReader.java
--- javac/jvm/ClassReader.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/ClassReader.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -59,7 +59,7 @@
 import static com.sun.tools.javac.jvm.ClassFile.*;
 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
 
-import static com.sun.tools.javac.main.Option.*;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /** This class provides operations to read a classfile into an internal
  *  representation. The internal representation is anchored in a
@@ -1320,6 +1320,10 @@
                     sym.flags_field |= PROPRIETARY;
                 else
                     proxies.append(proxy);
+                if (majorVersion >= V51.major &&
+                    proxy.type.tsym == syms.polymorphicSignatureType.tsym) {
+                    sym.flags_field |= POLYMORPHIC_SIGNATURE;
+                }
             }
             annotate.later(new AnnotationCompleter(sym, proxies.toList()));
         }
@@ -2535,7 +2539,7 @@
      *  @param arg An argument for substitution into the output string.
      */
     private void printCCF(String key, Object arg) {
-        log.printLines(key, arg);
+        log.printNoteLines(key, arg);
     }
 
 
diff -u -r javac/jvm/ClassWriter.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/ClassWriter.java
--- javac/jvm/ClassWriter.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/ClassWriter.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -45,7 +45,7 @@
 import static com.sun.tools.javac.code.Kinds.*;
 import static com.sun.tools.javac.code.TypeTags.*;
 import static com.sun.tools.javac.jvm.UninitializedType.*;
-import static com.sun.tools.javac.main.Option.*;
+import static com.sun.tools.javac.main.OptionName.*;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 
@@ -69,11 +69,11 @@
      */
     private boolean verbose;
 
-    /** Switch: scramble private names.
+    /** Switch: scrable private names.
      */
     private boolean scramble;
 
-    /** Switch: scramble private names.
+    /** Switch: scrable private names.
      */
     private boolean scrambleAll;
 
@@ -863,10 +863,10 @@
         }
         if (c.type.tag != CLASS) return; // arrays
         if (pool != null && // pool might be null if called from xClassName
-            c.owner.enclClass() != null &&
+            c.owner.kind != PCK &&
             (innerClasses == null || !innerClasses.contains(c))) {
 //          log.errWriter.println("enter inner " + c);//DEBUG
-            enterInner(c.owner.enclClass());
+            if (c.owner.kind == TYP) enterInner((ClassSymbol)c.owner);
             pool.put(c);
             pool.put(c.name);
             if (innerClasses == null) {
@@ -892,9 +892,8 @@
             if ((flags & INTERFACE) != 0) flags |= ABSTRACT; // Interfaces are always ABSTRACT
             if (inner.name.isEmpty()) flags &= ~FINAL; // Anonymous class: unset FINAL flag
             if (dumpInnerClassModifiers) {
-                PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
-                pw.println("INNERCLASS  " + inner.name);
-                pw.println("---" + flagNames(flags));
+                log.errWriter.println("INNERCLASS  " + inner.name);
+                log.errWriter.println("---" + flagNames(flags));
             }
             databuf.appendChar(pool.get(inner));
             databuf.appendChar(
@@ -912,9 +911,8 @@
         int flags = adjustFlags(v.flags());
         databuf.appendChar(flags);
         if (dumpFieldModifiers) {
-            PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
-            pw.println("FIELD  " + fieldName(v));
-            pw.println("---" + flagNames(v.flags()));
+            log.errWriter.println("FIELD  " + fieldName(v));
+            log.errWriter.println("---" + flagNames(v.flags()));
         }
         databuf.appendChar(pool.put(fieldName(v)));
         databuf.appendChar(pool.put(typeSig(v.erasure(types))));
@@ -936,9 +934,8 @@
         int flags = adjustFlags(m.flags());
         databuf.appendChar(flags);
         if (dumpMethodModifiers) {
-            PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
-            pw.println("METHOD  " + fieldName(m));
-            pw.println("---" + flagNames(m.flags()));
+            log.errWriter.println("METHOD  " + fieldName(m));
+            log.errWriter.println("---" + flagNames(m.flags()));
         }
         databuf.appendChar(pool.put(fieldName(m)));
         databuf.appendChar(pool.put(typeSig(m.externalType(types))));
@@ -1486,10 +1483,9 @@
         if ((flags & INTERFACE) == 0) flags |= ACC_SUPER;
         if (c.isInner() && c.name.isEmpty()) flags &= ~FINAL;
         if (dumpClassModifiers) {
-            PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
-            pw.println();
-            pw.println("CLASSFILE  " + c.getQualifiedName());
-            pw.println("---" + flagNames(flags));
+            log.errWriter.println();
+            log.errWriter.println("CLASSFILE  " + c.getQualifiedName());
+            log.errWriter.println("---" + flagNames(flags));
         }
         databuf.appendChar(flags);
 
@@ -1509,13 +1505,6 @@
             default : Assert.error();
             }
         }
-
-        if (c.trans_local != null) {
-            for (ClassSymbol local : c.trans_local) {
-                enterInner(local);
-            }
-        }
-
         databuf.appendChar(fieldsCount);
         writeFields(c.members().elems);
         databuf.appendChar(methodsCount);
diff -u -r javac/jvm/Code.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/Code.java
--- javac/jvm/Code.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/Code.java	2011-06-27 15:21:47.000000000 -0500
@@ -1542,28 +1542,7 @@
      */
     public void addCatch(
         char startPc, char endPc, char handlerPc, char catchType) {
-            catchInfo.append(new char[]{startPc, endPc, handlerPc, catchType});
-        }
-
-
-    public void compressCatchTable() {
-        ListBuffer<char[]> compressedCatchInfo = ListBuffer.lb();
-        List<Integer> handlerPcs = List.nil();
-        for (char[] catchEntry : catchInfo.elems) {
-            handlerPcs = handlerPcs.prepend((int)catchEntry[2]);
-        }
-        for (char[] catchEntry : catchInfo.elems) {
-            int startpc = catchEntry[0];
-            int endpc = catchEntry[1];
-            if (startpc == endpc ||
-                    (startpc == (endpc - 1) &&
-                    handlerPcs.contains(startpc))) {
-                continue;
-            } else {
-                compressedCatchInfo.append(catchEntry);
-            }
-        }
-        catchInfo = compressedCatchInfo;
+        catchInfo.append(new char[]{startPc, endPc, handlerPc, catchType});
     }
 
 
diff -u -r javac/jvm/CRTable.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/CRTable.java
--- javac/jvm/CRTable.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/CRTable.java	2011-06-27 15:21:47.000000000 -0500
@@ -31,7 +31,6 @@
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.tree.JCTree.*;
-import com.sun.tools.javac.parser.EndPosTable;
 
 /** This class contains the CharacterRangeTable for some method
  *  and the hashtable for mapping trees or lists of trees to their
@@ -55,9 +54,9 @@
      */
     private Map<Object,SourceRange> positions = new HashMap<Object,SourceRange>();
 
-    /** The object for ending positions stored in the parser.
+    /** The hashtable for ending positions stored in the parser.
      */
-    private EndPosTable endPosTable;
+    private Map<JCTree, Integer> endPositions;
 
     /** The tree of the method this table is intended for.
      *  We should traverse this tree to get source ranges.
@@ -66,9 +65,9 @@
 
     /** Constructor
      */
-    public CRTable(JCTree.JCMethodDecl tree, EndPosTable endPosTable) {
+    public CRTable(JCTree.JCMethodDecl tree, Map<JCTree, Integer> endPositions) {
         this.methodTree = tree;
-        this.endPosTable = endPosTable;
+        this.endPositions = endPositions;
     }
 
     /** Create a new CRTEntry and add it to the entries.
@@ -533,9 +532,12 @@
          */
         public int endPos(JCTree tree) {
             if (tree == null) return Position.NOPOS;
-            if (tree.hasTag(JCTree.Tag.BLOCK))
+            if (tree.getTag() == JCTree.BLOCK)
                 return ((JCBlock) tree).endpos;
-            return endPosTable.getEndPos(tree);
+            Integer endpos = endPositions.get(tree);
+            if (endpos != null)
+                return endpos.intValue();
+            return Position.NOPOS;
         }
     }
 
diff -u -r javac/jvm/Gen.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/Gen.java
--- javac/jvm/Gen.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/Gen.java	2011-06-27 15:21:47.000000000 -0500
@@ -26,6 +26,8 @@
 package com.sun.tools.javac.jvm;
 import java.util.*;
 
+import javax.lang.model.element.ElementKind;
+
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.util.List;
@@ -37,7 +39,6 @@
 import com.sun.tools.javac.code.Type.*;
 import com.sun.tools.javac.jvm.Code.*;
 import com.sun.tools.javac.jvm.Items.*;
-import com.sun.tools.javac.parser.EndPosTable;
 import com.sun.tools.javac.tree.JCTree.*;
 
 import static com.sun.tools.javac.code.Flags.*;
@@ -45,9 +46,7 @@
 import static com.sun.tools.javac.code.TypeTags.*;
 import static com.sun.tools.javac.jvm.ByteCodes.*;
 import static com.sun.tools.javac.jvm.CRTFlags.*;
-import static com.sun.tools.javac.main.Option.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.BLOCK;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /** This pass maps flat Java (i.e. without inner classes) to bytecodes.
  *
@@ -196,10 +195,9 @@
      */
     private int nerrs = 0;
 
-    /** An object containing mappings of syntax trees to their
-     *  ending source positions.
+    /** A hash table mapping syntax trees to their ending source positions.
      */
-    EndPosTable endPosTable;
+    private Map<JCTree, Integer> endPositions;
 
     /** Generate code to load an integer constant.
      *  @param n     The integer to be loaded.
@@ -435,7 +433,7 @@
      */
     boolean hasFinally(JCTree target, Env<GenContext> env) {
         while (env.tree != target) {
-            if (env.tree.hasTag(TRY) && env.info.finalize.hasFinalizer())
+            if (env.tree.getTag() == JCTree.TRY && env.info.finalize.hasFinalizer())
                 return true;
             env = env.next;
         }
@@ -462,17 +460,17 @@
         for (List<JCTree> l = defs; l.nonEmpty(); l = l.tail) {
             JCTree def = l.head;
             switch (def.getTag()) {
-            case BLOCK:
+            case JCTree.BLOCK:
                 JCBlock block = (JCBlock)def;
                 if ((block.flags & STATIC) != 0)
                     clinitCode.append(block);
                 else
                     initCode.append(block);
                 break;
-            case METHODDEF:
+            case JCTree.METHODDEF:
                 methodDefs.append(def);
                 break;
-            case VARDEF:
+            case JCTree.VARDEF:
                 JCVariableDecl vdef = (JCVariableDecl) def;
                 VarSymbol sym = vdef.sym;
                 checkDimension(vdef.pos(), sym.type);
@@ -482,14 +480,20 @@
                         JCStatement init = make.at(vdef.pos()).
                             Assignment(sym, vdef.init);
                         initCode.append(init);
-                        endPosTable.replaceTree(vdef, init);
+                        if (endPositions != null) {
+                            Integer endPos = endPositions.remove(vdef);
+                            if (endPos != null) endPositions.put(init, endPos);
+                        }
                     } else if (sym.getConstValue() == null) {
                         // Initialize class (static) variables only if
                         // they are not compile-time constants.
                         JCStatement init = make.at(vdef.pos).
                             Assignment(sym, vdef.init);
                         clinitCode.append(init);
-                        endPosTable.replaceTree(vdef, init);
+                        if (endPositions != null) {
+                            Integer endPos = endPositions.remove(vdef);
+                            if (endPos != null) endPositions.put(init, endPos);
+                        }
                     } else {
                         checkStringConstant(vdef.init.pos(), sym.getConstValue());
                     }
@@ -703,7 +707,7 @@
         }
         int startpc = code.curPc();
         genStat(tree, env);
-        if (tree.hasTag(BLOCK)) crtFlags |= CRT_BLOCK;
+        if (tree.getTag() == JCTree.BLOCK) crtFlags |= CRT_BLOCK;
         code.crt.put(tree, crtFlags, startpc, code.curPc());
     }
 
@@ -713,7 +717,7 @@
         if (code.isAlive()) {
             code.statBegin(tree.pos);
             genDef(tree, env);
-        } else if (env.info.isSwitch && tree.hasTag(VARDEF)) {
+        } else if (env.info.isSwitch && tree.getTag() == JCTree.VARDEF) {
             // variables whose declarations are in a switch
             // can be used even if the decl is unreachable.
             code.newLocal(((JCVariableDecl) tree).sym);
@@ -780,7 +784,7 @@
      */
     public CondItem genCond(JCTree _tree, boolean markBranches) {
         JCTree inner_tree = TreeInfo.skipParens(_tree);
-        if (inner_tree.hasTag(CONDEXPR)) {
+        if (inner_tree.getTag() == JCTree.CONDEXPR) {
             JCConditional tree = (JCConditional)inner_tree;
             CondItem cond = genCond(tree.cond, CRT_FLOW_CONTROLLER);
             if (cond.isTrue()) {
@@ -955,9 +959,6 @@
                     code.lastFrame = null;
                     code.frameBeforeLast = null;
                 }
-
-                //compress exception table
-                code.compressCatchTable();
             }
         }
 
@@ -1029,7 +1030,7 @@
         Env<GenContext> localEnv = env.dup(tree, new GenContext());
         genStats(tree.stats, localEnv);
         // End the scope of all block-local variables in variable info.
-        if (!env.tree.hasTag(METHODDEF)) {
+        if (env.tree.getTag() != JCTree.METHODDEF) {
             code.statBegin(tree.endpos);
             code.endScopes(limit);
             code.pendingStatPos = Position.NOPOS;
@@ -1436,6 +1437,7 @@
                     code.markDead();
                 }
             }
+
             // Resolve all breaks.
             code.resolve(exitChain);
 
@@ -1494,21 +1496,23 @@
         void registerCatch(DiagnosticPosition pos,
                            int startpc, int endpc,
                            int handler_pc, int catch_type) {
-            char startpc1 = (char)startpc;
-            char endpc1 = (char)endpc;
-            char handler_pc1 = (char)handler_pc;
-            if (startpc1 == startpc &&
-                endpc1 == endpc &&
-                handler_pc1 == handler_pc) {
-                code.addCatch(startpc1, endpc1, handler_pc1,
-                              (char)catch_type);
-            } else {
-                if (!useJsrLocally && !target.generateStackMapTable()) {
-                    useJsrLocally = true;
-                    throw new CodeSizeOverflow();
+            if (startpc != endpc) {
+                char startpc1 = (char)startpc;
+                char endpc1 = (char)endpc;
+                char handler_pc1 = (char)handler_pc;
+                if (startpc1 == startpc &&
+                    endpc1 == endpc &&
+                    handler_pc1 == handler_pc) {
+                    code.addCatch(startpc1, endpc1, handler_pc1,
+                                  (char)catch_type);
                 } else {
-                    log.error(pos, "limit.code.too.large.for.try.stmt");
-                    nerrs++;
+                    if (!useJsrLocally && !target.generateStackMapTable()) {
+                        useJsrLocally = true;
+                        throw new CodeSizeOverflow();
+                    } else {
+                        log.error(pos, "limit.code.too.large.for.try.stmt");
+                        nerrs++;
+                    }
                 }
             }
         }
@@ -1624,11 +1628,11 @@
         // Optimize x++ to ++x and x-- to --x.
         JCExpression e = tree.expr;
         switch (e.getTag()) {
-            case POSTINC:
-                ((JCUnary) e).setTag(PREINC);
+            case JCTree.POSTINC:
+                ((JCUnary) e).setTag(JCTree.PREINC);
                 break;
-            case POSTDEC:
-                ((JCUnary) e).setTag(PREDEC);
+            case JCTree.POSTDEC:
+                ((JCUnary) e).setTag(JCTree.PREDEC);
                 break;
         }
         genExpr(tree.expr, tree.expr.type).drop();
@@ -1685,8 +1689,6 @@
         // outer instance of a super(...) call appears as first parameter).
         genArgs(tree.args,
                 TreeInfo.symbol(tree.meth).externalType(types).getParameterTypes());
-        code.statBegin(tree.pos);
-        code.markStatBegin();
         result = m.invoke();
     }
 
@@ -1815,13 +1817,13 @@
             // If we have an increment of -32768 to +32767 of a local
             // int variable we can use an incr instruction instead of
             // proceeding further.
-            if ((tree.hasTag(PLUS_ASG) || tree.hasTag(MINUS_ASG)) &&
+            if ((tree.getTag() == JCTree.PLUS_ASG || tree.getTag() == JCTree.MINUS_ASG) &&
                 l instanceof LocalItem &&
                 tree.lhs.type.tag <= INT &&
                 tree.rhs.type.tag <= INT &&
                 tree.rhs.type.constValue() != null) {
                 int ival = ((Number) tree.rhs.type.constValue()).intValue();
-                if (tree.hasTag(MINUS_ASG)) ival = -ival;
+                if (tree.getTag() == JCTree.MINUS_ASG) ival = -ival;
                 ((LocalItem)l).incr(ival);
                 result = l;
                 return;
@@ -1837,29 +1839,29 @@
 
     public void visitUnary(JCUnary tree) {
         OperatorSymbol operator = (OperatorSymbol)tree.operator;
-        if (tree.hasTag(NOT)) {
+        if (tree.getTag() == JCTree.NOT) {
             CondItem od = genCond(tree.arg, false);
             result = od.negate();
         } else {
             Item od = genExpr(tree.arg, operator.type.getParameterTypes().head);
             switch (tree.getTag()) {
-            case POS:
+            case JCTree.POS:
                 result = od.load();
                 break;
-            case NEG:
+            case JCTree.NEG:
                 result = od.load();
                 code.emitop0(operator.opcode);
                 break;
-            case COMPL:
+            case JCTree.COMPL:
                 result = od.load();
                 emitMinusOne(od.typecode);
                 code.emitop0(operator.opcode);
                 break;
-            case PREINC: case PREDEC:
+            case JCTree.PREINC: case JCTree.PREDEC:
                 od.duplicate();
                 if (od instanceof LocalItem &&
                     (operator.opcode == iadd || operator.opcode == isub)) {
-                    ((LocalItem)od).incr(tree.hasTag(PREINC) ? 1 : -1);
+                    ((LocalItem)od).incr(tree.getTag() == JCTree.PREINC ? 1 : -1);
                     result = od;
                 } else {
                     od.load();
@@ -1873,12 +1875,12 @@
                     result = items.makeAssignItem(od);
                 }
                 break;
-            case POSTINC: case POSTDEC:
+            case JCTree.POSTINC: case JCTree.POSTDEC:
                 od.duplicate();
                 if (od instanceof LocalItem &&
                     (operator.opcode == iadd || operator.opcode == isub)) {
                     Item res = od.load();
-                    ((LocalItem)od).incr(tree.hasTag(POSTINC) ? 1 : -1);
+                    ((LocalItem)od).incr(tree.getTag() == JCTree.POSTINC ? 1 : -1);
                     result = res;
                 } else {
                     Item res = od.load();
@@ -1894,7 +1896,7 @@
                     result = res;
                 }
                 break;
-            case NULLCHK:
+            case JCTree.NULLCHK:
                 result = od.load();
                 code.emitop0(dup);
                 genNullCheck(tree.pos());
@@ -1922,7 +1924,7 @@
             // Convert buffer to string.
             bufferToString(tree.pos());
             result = items.makeStackItem(syms.stringType);
-        } else if (tree.hasTag(AND)) {
+        } else if (tree.getTag() == JCTree.AND) {
             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
             if (!lcond.isFalse()) {
                 Chain falseJumps = lcond.jumpFalse();
@@ -1936,7 +1938,7 @@
             } else {
                 result = lcond;
             }
-        } else if (tree.hasTag(OR)) {
+        } else if (tree.getTag() == JCTree.OR) {
             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
             if (!lcond.isTrue()) {
                 Chain trueJumps = lcond.jumpTrue();
@@ -1993,7 +1995,7 @@
          */
         void appendStrings(JCTree tree) {
             tree = TreeInfo.skipParens(tree);
-            if (tree.hasTag(PLUS) && tree.type.constValue() == null) {
+            if (tree.getTag() == JCTree.PLUS && tree.type.constValue() == null) {
                 JCBinary op = (JCBinary) tree;
                 if (op.operator.kind == MTH &&
                     ((OperatorSymbol) op.operator).opcode == string_add) {
@@ -2211,7 +2213,7 @@
             attrEnv = env;
             ClassSymbol c = cdef.sym;
             this.toplevel = env.toplevel;
-            this.endPosTable = toplevel.endPositions;
+            this.endPositions = toplevel.endPositions;
             // If this is a class definition requiring Miranda methods,
             // add them.
             if (generateIproxies &&
@@ -2236,7 +2238,7 @@
             if (nerrs != 0) {
                 // if errors, discard code
                 for (List<JCTree> l = cdef.defs; l.nonEmpty(); l = l.tail) {
-                    if (l.head.hasTag(METHODDEF))
+                    if (l.head.getTag() == JCTree.METHODDEF)
                         ((JCMethodDecl) l.head).sym.code = null;
                 }
             }
@@ -2247,7 +2249,7 @@
             attrEnv = null;
             this.env = null;
             toplevel = null;
-            endPosTable = null;
+            endPositions = null;
             nerrs = 0;
         }
     }
Only in javac/jvm: JNIWriter.java
diff -u -r javac/jvm/Target.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/Target.java
--- javac/jvm/Target.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/jvm/Target.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,7 @@
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.util.*;
 
-import static com.sun.tools.javac.main.Option.*;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /** The classfile version target.
  *
@@ -66,10 +66,7 @@
     JDK1_6("1.6", 50, 0),
 
     /** JDK 7. */
-    JDK1_7("1.7", 51, 0),
-
-    /** JDK 8. */ // For now, a clone of 7
-    JDK1_8("1.8", 51, 0);
+    JDK1_7("1.7", 51, 0);
 
     private static final Context.Key<Target> targetKey =
         new Context.Key<Target>();
@@ -102,7 +99,6 @@
         tab.put("5", JDK1_5);
         tab.put("6", JDK1_6);
         tab.put("7", JDK1_7);
-        tab.put("8", JDK1_8);
     }
 
     public final String name;
@@ -114,7 +110,7 @@
         this.minorVersion = minorVersion;
     }
 
-    public static final Target DEFAULT = JDK1_8;
+    public static final Target DEFAULT = JDK1_7;
 
     public static Target lookup(String name) {
         return tab.get(name);
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac: Launcher.java
diff -u -r javac/main/JavaCompiler.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/main/JavaCompiler.java
--- javac/main/JavaCompiler.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/main/JavaCompiler.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,8 +28,8 @@
 import java.io.*;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.MissingResourceException;
 import java.util.Queue;
@@ -41,29 +41,27 @@
 
 import javax.annotation.processing.Processor;
 import javax.lang.model.SourceVersion;
-import javax.tools.DiagnosticListener;
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileObject;
-import javax.tools.StandardLocation;
-
-import static javax.tools.StandardLocation.CLASS_OUTPUT;
+import javax.tools.DiagnosticListener;
 
 import com.sun.source.util.TaskEvent;
-import com.sun.tools.javac.api.MultiTaskListener;
+import com.sun.source.util.TaskListener;
+
+import com.sun.tools.javac.file.JavacFileManager;
+import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.code.Lint.LintCategory;
 import com.sun.tools.javac.code.Symbol.*;
+import com.sun.tools.javac.tree.*;
+import com.sun.tools.javac.tree.JCTree.*;
+import com.sun.tools.javac.parser.*;
 import com.sun.tools.javac.comp.*;
-import com.sun.tools.javac.file.JavacFileManager;
 import com.sun.tools.javac.jvm.*;
-import com.sun.tools.javac.parser.*;
 import com.sun.tools.javac.processing.*;
-import com.sun.tools.javac.tree.*;
-import com.sun.tools.javac.tree.JCTree.*;
-import com.sun.tools.javac.util.*;
-import com.sun.tools.javac.util.Log.WriterKind;
 
-import static com.sun.tools.javac.main.Option.*;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+import static com.sun.tools.javac.main.OptionName.*;
 import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;
 import static com.sun.tools.javac.util.ListBuffer.lb;
 
@@ -230,10 +228,6 @@
      */
     protected ClassWriter writer;
 
-    /** The native header writer.
-     */
-    protected JNIWriter jniWriter;
-
     /** The module for the symbol table entry phases.
      */
     protected Enter enter;
@@ -294,9 +288,9 @@
      */
     protected ParserFactory parserFactory;
 
-    /** Broadcasting listener for progress events
+    /** Optional listener for progress events
      */
-    protected MultiTaskListener taskListener;
+    protected TaskListener taskListener;
 
     /**
      * Annotation processing may require and provide a new instance
@@ -337,7 +331,6 @@
         reader = ClassReader.instance(context);
         make = TreeMaker.instance(context);
         writer = ClassWriter.instance(context);
-        jniWriter = JNIWriter.instance(context);
         enter = Enter.instance(context);
         todo = Todo.instance(context);
 
@@ -362,7 +355,7 @@
         lower = Lower.instance(context);
         annotate = Annotate.instance(context);
         types = Types.instance(context);
-        taskListener = MultiTaskListener.instance(context);
+        taskListener = context.get(TaskListener.class);
 
         reader.sourceCompleter = this;
 
@@ -495,10 +488,6 @@
      */
     public Todo todo;
 
-    /** A list of items to be closed when the compilation is complete.
-     */
-    public List<Closeable> closeables = List.nil();
-
     /** Ordered list of compiler phases for each compilation unit. */
     public enum CompileState {
         PARSE(1),
@@ -598,7 +587,7 @@
             if (verbose) {
                 log.printVerbose("parsing.started", filename);
             }
-            if (!taskListener.isEmpty()) {
+            if (taskListener != null) {
                 TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, filename);
                 taskListener.started(e);
             }
@@ -611,7 +600,7 @@
 
         tree.sourcefile = filename;
 
-        if (content != null && !taskListener.isEmpty()) {
+        if (content != null && taskListener != null) {
             TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, tree);
             taskListener.finished(e);
         }
@@ -757,14 +746,14 @@
             log.useSource(prev);
         }
 
-        if (!taskListener.isEmpty()) {
+        if (taskListener != null) {
             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
             taskListener.started(e);
         }
 
         enter.complete(List.of(tree), c);
 
-        if (!taskListener.isEmpty()) {
+        if (taskListener != null) {
             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
             taskListener.finished(e);
         }
@@ -823,8 +812,8 @@
 
         // forcibly set the equivalent of -Xlint:-options, so that no further
         // warnings about command line options are generated from this point on
-        options.put(XLINT_CUSTOM.text + "-" + LintCategory.OPTIONS.option, "true");
-        options.remove(XLINT_CUSTOM.text + LintCategory.OPTIONS.option);
+        options.put(XLINT_CUSTOM + "-" + LintCategory.OPTIONS.option, "true");
+        options.remove(XLINT_CUSTOM + LintCategory.OPTIONS.option);
 
         start_msec = now();
 
@@ -930,7 +919,7 @@
      */
     public List<JCCompilationUnit> enterTrees(List<JCCompilationUnit> roots) {
         //enter symbols for all files
-        if (!taskListener.isEmpty()) {
+        if (taskListener != null) {
             for (JCCompilationUnit unit: roots) {
                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, unit);
                 taskListener.started(e);
@@ -939,7 +928,7 @@
 
         enter.main(roots);
 
-        if (!taskListener.isEmpty()) {
+        if (taskListener != null) {
             for (JCCompilationUnit unit: roots) {
                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, unit);
                 taskListener.finished(e);
@@ -1008,7 +997,7 @@
                 reader.saveParameterNames = true;
                 keepComments = true;
                 genEndPos = true;
-                if (!taskListener.isEmpty())
+                if (taskListener != null)
                     taskListener.started(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING));
                 log.deferDiagnostics = true;
             } else { // free resources
@@ -1023,7 +1012,7 @@
     }
 
     /**
-     * Process any annotations found in the specified compilation units.
+     * Process any anotations found in the specifed compilation units.
      * @param roots a list of compilation units
      * @return an instance of the compiler in which to complete the compilation
      */
@@ -1083,9 +1072,7 @@
                     boolean errors = false;
                     for (String nameStr : classnames) {
                         Symbol sym = resolveBinaryNameOrIdent(nameStr);
-                        if (sym == null ||
-                            (sym.kind == Kinds.PCK && !processPcks) ||
-                            sym.kind == Kinds.ABSENT_TYP) {
+                        if (sym == null || (sym.kind == Kinds.PCK && !processPcks)) {
                             log.error("proc.cant.find.class", nameStr);
                             errors = true;
                             continue;
@@ -1182,7 +1169,7 @@
         if (verbose)
             log.printVerbose("checking.attribution", env.enclClass.sym);
 
-        if (!taskListener.isEmpty()) {
+        if (taskListener != null) {
             TaskEvent e = new TaskEvent(TaskEvent.Kind.ANALYZE, env.toplevel, env.enclClass.sym);
             taskListener.started(e);
         }
@@ -1265,7 +1252,7 @@
             }
         }
         finally {
-            if (!taskListener.isEmpty()) {
+            if (taskListener != null) {
                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ANALYZE, env.toplevel, env.enclClass.sym);
                 taskListener.finished(e);
             }
@@ -1446,7 +1433,7 @@
                                + " " + cdef.sym + "]");
             }
 
-            if (!taskListener.isEmpty()) {
+            if (taskListener != null) {
                 TaskEvent e = new TaskEvent(TaskEvent.Kind.GENERATE, env.toplevel, cdef.sym);
                 taskListener.started(e);
             }
@@ -1458,13 +1445,8 @@
                 JavaFileObject file;
                 if (usePrintSource)
                     file = printSource(env, cdef);
-                else {
-                    if (fileManager.hasLocation(StandardLocation.NATIVE_HEADER_OUTPUT)
-                            && jniWriter.needsHeader(cdef.sym)) {
-                        jniWriter.write(cdef.sym);
-                    }
+                else
                     file = genCode(env, cdef);
-                }
                 if (results != null && file != null)
                     results.add(file);
             } catch (IOException ex) {
@@ -1475,7 +1457,7 @@
                 log.useSource(prev);
             }
 
-            if (!taskListener.isEmpty()) {
+            if (taskListener != null) {
                 TaskEvent e = new TaskEvent(TaskEvent.Kind.GENERATE, env.toplevel, cdef.sym);
                 taskListener.finished(e);
             }
@@ -1520,20 +1502,20 @@
                     for (List<JCTree> it = tree.defs; it.tail != null; it = it.tail) {
                         JCTree t = it.head;
                         switch (t.getTag()) {
-                        case CLASSDEF:
+                        case JCTree.CLASSDEF:
                             if (isInterface ||
                                 (((JCClassDecl) t).mods.flags & (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
                                 (((JCClassDecl) t).mods.flags & (Flags.PRIVATE)) == 0 && ((JCClassDecl) t).sym.packge().getQualifiedName() == names.java_lang)
                                 newdefs.append(t);
                             break;
-                        case METHODDEF:
+                        case JCTree.METHODDEF:
                             if (isInterface ||
                                 (((JCMethodDecl) t).mods.flags & (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
                                 ((JCMethodDecl) t).sym.name == names.init ||
                                 (((JCMethodDecl) t).mods.flags & (Flags.PRIVATE)) == 0 && ((JCMethodDecl) t).sym.packge().getQualifiedName() == names.java_lang)
                                 newdefs.append(t);
                             break;
-                        case VARDEF:
+                        case JCTree.VARDEF:
                             if (isInterface || (((JCVariableDecl) t).mods.flags & (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
                                 (((JCVariableDecl) t).mods.flags & (Flags.PRIVATE)) == 0 && ((JCVariableDecl) t).sym.packge().getQualifiedName() == names.java_lang)
                                 newdefs.append(t);
@@ -1599,24 +1581,11 @@
             if (names != null && disposeNames)
                 names.dispose();
             names = null;
-
-            for (Closeable c: closeables) {
-                try {
-                    c.close();
-                } catch (IOException e) {
-                    // When javac uses JDK 7 as a baseline, this code would be
-                    // better written to set any/all exceptions from all the
-                    // Closeables as suppressed exceptions on the FatalError
-                    // that is thrown.
-                    JCDiagnostic msg = diagFactory.fragment("fatal.err.cant.close");
-                    throw new FatalError(msg, e);
-                }
-            }
         }
     }
 
     protected void printNote(String lines) {
-        log.printRawLines(Log.WriterKind.NOTICE, lines);
+        Log.printLines(log.noticeWriter, lines);
     }
 
     /** Print numbers of errors and warnings.
@@ -1628,8 +1597,8 @@
                 key = "count." + kind;
             else
                 key = "count." + kind + ".plural";
-            log.printLines(WriterKind.ERROR, key, String.valueOf(count));
-            log.flush(Log.WriterKind.ERROR);
+            log.printErrLines(key, String.valueOf(count));
+            log.errWriter.flush();
         }
     }
 
@@ -1646,8 +1615,6 @@
         keepComments = prev.keepComments;
         start_msec = prev.start_msec;
         hasBeenUsed = true;
-        closeables = prev.closeables;
-        prev.closeables = List.nil();
     }
 
     public static void enableLogging() {
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/main: JavacOption.java
diff -u -r javac/main/Main.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/main/Main.java
--- javac/main/Main.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/main/Main.java	2011-06-27 15:21:47.000000000 -0500
@@ -31,10 +31,7 @@
 import java.net.URL;
 import java.security.DigestInputStream;
 import java.security.MessageDigest;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.LinkedHashSet;
-import java.util.Set;
+import java.util.MissingResourceException;
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileObject;
 import javax.annotation.processing.Processor;
@@ -43,12 +40,12 @@
 import com.sun.tools.javac.file.CacheFSInfo;
 import com.sun.tools.javac.file.JavacFileManager;
 import com.sun.tools.javac.jvm.Target;
+import com.sun.tools.javac.main.JavacOption.Option;
+import com.sun.tools.javac.main.RecognizedOptions.OptionHelper;
 import com.sun.tools.javac.util.*;
-import com.sun.tools.javac.util.Log.WriterKind;
-import com.sun.tools.javac.util.Log.PrefixKind;
 import com.sun.tools.javac.processing.AnnotationProcessingError;
 
-import static com.sun.tools.javac.main.Option.*;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /** This class provides a commandline interface to the GJC compiler.
  *
@@ -67,10 +64,6 @@
      */
     PrintWriter out;
 
-    /** The log to use for diagnostic output.
-     */
-    Log log;
-
     /**
      * If true, certain errors will cause an exception, such as command line
      * arg errors, or exceptions in user provided code.
@@ -80,69 +73,49 @@
 
     /** Result codes.
      */
-    public enum Result {
-        OK(0),        // Compilation completed with no errors.
-        ERROR(1),     // Completed but reported errors.
-        CMDERR(2),    // Bad command-line arguments
-        SYSERR(3),    // System error or resource exhaustion.
-        ABNORMAL(4);  // Compiler terminated abnormally
+    static final int
+        EXIT_OK = 0,        // Compilation completed with no errors.
+        EXIT_ERROR = 1,     // Completed but reported errors.
+        EXIT_CMDERR = 2,    // Bad command-line arguments
+        EXIT_SYSERR = 3,    // System error or resource exhaustion.
+        EXIT_ABNORMAL = 4;  // Compiler terminated abnormally
 
-        Result(int exitCode) {
-            this.exitCode = exitCode;
-        }
+    private Option[] recognizedOptions = RecognizedOptions.getJavaCompilerOptions(new OptionHelper() {
 
-        public boolean isOK() {
-            return (exitCode == 0);
+        public void setOut(PrintWriter out) {
+            Main.this.out = out;
         }
 
-        public final int exitCode;
-    }
-
-    private Option[] recognizedOptions =
-            Option.getJavaCompilerOptions().toArray(new Option[0]);
-
-    private OptionHelper optionHelper = new OptionHelper() {
-        @Override
-        public String get(Option option) {
-            return options.get(option);
-        }
-
-        @Override
-        public void put(String name, String value) {
-            options.put(name, value);
+        public void error(String key, Object... args) {
+            Main.this.error(key, args);
         }
 
-        @Override
-        public void remove(String name) {
-            options.remove(name);
+        public void printVersion() {
+            Log.printLines(out, getLocalizedString("version", ownName,  JavaCompiler.version()));
         }
 
-        @Override
-        public Log getLog() {
-            return log;
+        public void printFullVersion() {
+            Log.printLines(out, getLocalizedString("fullVersion", ownName,  JavaCompiler.fullVersion()));
         }
 
-        @Override
-        public String getOwnName() {
-            return ownName;
+        public void printHelp() {
+            help();
         }
 
-        @Override
-        public void error(String key, Object... args) {
-            Main.this.error(key, args);
+        public void printXhelp() {
+            xhelp();
         }
 
-        @Override
         public void addFile(File f) {
-            filenames.add(f);
+            if (!filenames.contains(f))
+                filenames.append(f);
         }
 
-        @Override
         public void addClassName(String s) {
             classnames.append(s);
         }
 
-    };
+    });
 
     /**
      * Construct a compiler instance.
@@ -163,27 +136,48 @@
 
     /** The list of source files to process
      */
-    public Set<File> filenames = null; // XXX sb protected
+    public ListBuffer<File> filenames = null; // XXX sb protected
 
     /** List of class files names passed on the command line
      */
     public ListBuffer<String> classnames = null; // XXX sb protected
 
+    /** Print a string that explains usage.
+     */
+    void help() {
+        Log.printLines(out, getLocalizedString("msg.usage.header", ownName));
+        for (int i=0; i<recognizedOptions.length; i++) {
+            recognizedOptions[i].help(out);
+        }
+        out.println();
+    }
+
+    /** Print a string that explains usage for X options.
+     */
+    void xhelp() {
+        for (int i=0; i<recognizedOptions.length; i++) {
+            recognizedOptions[i].xhelp(out);
+        }
+        out.println();
+        Log.printLines(out, getLocalizedString("msg.usage.nonstandard.footer"));
+    }
+
     /** Report a usage error.
      */
     void error(String key, Object... args) {
         if (apiMode) {
-            String msg = log.localize(PrefixKind.JAVAC, key, args);
+            String msg = getLocalizedString(key, args);
             throw new PropagatedException(new IllegalStateException(msg));
         }
         warning(key, args);
-        log.printLines(PrefixKind.JAVAC, "msg.usage", ownName);
+        Log.printLines(out, getLocalizedString("msg.usage", ownName));
     }
 
     /** Report a warning.
      */
     void warning(String key, Object... args) {
-        log.printRawLines(ownName + ": " + log.localize(PrefixKind.JAVAC, key, args));
+        Log.printLines(out, ownName + ": "
+                       + getLocalizedString(key, args));
     }
 
     public Option getOption(String flag) {
@@ -208,11 +202,7 @@
      *  in `options' table and return all source filenames.
      *  @param flags    The array of command line arguments.
      */
-    public Collection<File> processArgs(String[] flags) { // XXX sb protected
-        return processArgs(flags, null);
-    }
-
-    public Collection<File> processArgs(String[] flags, String[] classNames) { // XXX sb protected
+    public List<File> processArgs(String[] flags) { // XXX sb protected
         int ac = 0;
         while (ac < flags.length) {
             String flag = flags[ac];
@@ -245,18 +235,14 @@
                 }
                 String operand = flags[ac];
                 ac++;
-                if (option.process(optionHelper, flag, operand))
+                if (option.process(options, flag, operand))
                     return null;
             } else {
-                if (option.process(optionHelper, flag))
+                if (option.process(options, flag))
                     return null;
             }
         }
 
-        if (this.classnames != null && classNames != null) {
-            this.classnames.addAll(Arrays.asList(classNames));
-        }
-
         if (!checkDirectory(D))
             return null;
         if (!checkDirectory(S))
@@ -308,13 +294,11 @@
             showClass(showClass);
         }
 
-        options.notifyListeners();
-
-        return filenames;
+        return filenames.toList();
     }
     // where
-        private boolean checkDirectory(Option option) {
-            String value = options.get(option);
+        private boolean checkDirectory(OptionName optName) {
+            String value = options.get(optName);
             if (value == null)
                 return true;
             File file = new File(value);
@@ -332,10 +316,10 @@
     /** Programmatic interface for main function.
      * @param args    The command line parameters.
      */
-    public Result compile(String[] args) {
+    public int compile(String[] args) {
         Context context = new Context();
         JavacFileManager.preRegister(context); // can't create it until Log has been set up
-        Result result = compile(args, context);
+        int result = compile(args, context);
         if (fileManager instanceof JavacFileManager) {
             // A fresh context was created above, so jfm must be a JavacFileManager
             ((JavacFileManager)fileManager).close();
@@ -343,34 +327,22 @@
         return result;
     }
 
-    public Result compile(String[] args, Context context) {
+    public int compile(String[] args, Context context) {
         return compile(args, context, List.<JavaFileObject>nil(), null);
     }
 
     /** Programmatic interface for main function.
      * @param args    The command line parameters.
      */
-    public Result compile(String[] args,
+    public int compile(String[] args,
                        Context context,
                        List<JavaFileObject> fileObjects,
                        Iterable<? extends Processor> processors)
     {
-        return compile(args,  null, context, fileObjects, processors);
-    }
-
-    public Result compile(String[] args,
-                       String[] classNames,
-                       Context context,
-                       List<JavaFileObject> fileObjects,
-                       Iterable<? extends Processor> processors)
-    {
-        context.put(Log.outKey, out);
-        log = Log.instance(context);
-
         if (options == null)
             options = Options.instance(context); // creates a new one
 
-        filenames = new LinkedHashSet<File>();
+        filenames = new ListBuffer<File>();
         classnames = new ListBuffer<String>();
         JavaCompiler comp = null;
         /*
@@ -379,44 +351,46 @@
          * into account.
          */
         try {
-            if (args.length == 0
-                    && (classNames == null || classNames.length == 0)
-                    && fileObjects.isEmpty()) {
-                Option.HELP.process(optionHelper, "-help");
-                return Result.CMDERR;
+            if (args.length == 0 && fileObjects.isEmpty()) {
+                help();
+                return EXIT_CMDERR;
             }
 
-            Collection<File> files;
+            List<File> files;
             try {
-                files = processArgs(CommandLine.parse(args), classNames);
+                files = processArgs(CommandLine.parse(args));
                 if (files == null) {
                     // null signals an error in options, abort
-                    return Result.CMDERR;
+                    return EXIT_CMDERR;
                 } else if (files.isEmpty() && fileObjects.isEmpty() && classnames.isEmpty()) {
                     // it is allowed to compile nothing if just asking for help or version info
                     if (options.isSet(HELP)
                         || options.isSet(X)
                         || options.isSet(VERSION)
                         || options.isSet(FULLVERSION))
-                        return Result.OK;
+                        return EXIT_OK;
                     if (JavaCompiler.explicitAnnotationProcessingRequested(options)) {
                         error("err.no.source.files.classes");
                     } else {
                         error("err.no.source.files");
                     }
-                    return Result.CMDERR;
+                    return EXIT_CMDERR;
                 }
             } catch (java.io.FileNotFoundException e) {
-                warning("err.file.not.found", e.getMessage());
-                return Result.SYSERR;
+                Log.printLines(out, ownName + ": " +
+                               getLocalizedString("err.file.not.found",
+                                                  e.getMessage()));
+                return EXIT_SYSERR;
             }
 
             boolean forceStdOut = options.isSet("stdout");
             if (forceStdOut) {
-                log.flush();
-                log.setWriters(new PrintWriter(System.out, true));
+                out.flush();
+                out = new PrintWriter(System.out, true);
             }
 
+            context.put(Log.outKey, out);
+
             // allow System property in following line as a Mustang legacy
             boolean batchMode = (options.isUnset("nonBatchMode")
                         && System.getProperty("nonBatchMode") == null);
@@ -426,7 +400,9 @@
             fileManager = context.get(JavaFileManager.class);
 
             comp = JavaCompiler.instance(context);
-            if (comp == null) return Result.SYSERR;
+            if (comp == null) return EXIT_SYSERR;
+
+            Log log = Log.instance(context);
 
             if (!files.isEmpty()) {
                 // add filenames to fileObjects
@@ -444,33 +420,33 @@
 
             if (log.expectDiagKeys != null) {
                 if (log.expectDiagKeys.isEmpty()) {
-                    log.printRawLines("all expected diagnostics found");
-                    return Result.OK;
+                    Log.printLines(log.noticeWriter, "all expected diagnostics found");
+                    return EXIT_OK;
                 } else {
-                    log.printRawLines("expected diagnostic keys not found: " + log.expectDiagKeys);
-                    return Result.ERROR;
+                    Log.printLines(log.noticeWriter, "expected diagnostic keys not found: " + log.expectDiagKeys);
+                    return EXIT_ERROR;
                 }
             }
 
             if (comp.errorCount() != 0)
-                return Result.ERROR;
+                return EXIT_ERROR;
         } catch (IOException ex) {
             ioMessage(ex);
-            return Result.SYSERR;
+            return EXIT_SYSERR;
         } catch (OutOfMemoryError ex) {
             resourceMessage(ex);
-            return Result.SYSERR;
+            return EXIT_SYSERR;
         } catch (StackOverflowError ex) {
             resourceMessage(ex);
-            return Result.SYSERR;
+            return EXIT_SYSERR;
         } catch (FatalError ex) {
             feMessage(ex);
-            return Result.SYSERR;
+            return EXIT_SYSERR;
         } catch (AnnotationProcessingError ex) {
             if (apiMode)
                 throw new RuntimeException(ex.getCause());
             apMessage(ex);
-            return Result.SYSERR;
+            return EXIT_SYSERR;
         } catch (ClientCodeException ex) {
             // as specified by javax.tools.JavaCompiler#getTask
             // and javax.tools.JavaCompiler.CompilationTask#call
@@ -484,7 +460,7 @@
             if (comp == null || comp.errorCount() == 0 ||
                 options == null || options.isSet("dev"))
                 bugMessage(ex);
-            return Result.ABNORMAL;
+            return EXIT_ABNORMAL;
         } finally {
             if (comp != null) {
                 try {
@@ -496,56 +472,58 @@
             filenames = null;
             options = null;
         }
-        return Result.OK;
+        return EXIT_OK;
     }
 
     /** Print a message reporting an internal error.
      */
     void bugMessage(Throwable ex) {
-        log.printLines(PrefixKind.JAVAC, "msg.bug", JavaCompiler.version());
-        ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
+        Log.printLines(out, getLocalizedString("msg.bug",
+                                               JavaCompiler.version()));
+        ex.printStackTrace(out);
     }
 
     /** Print a message reporting a fatal error.
      */
     void feMessage(Throwable ex) {
-        log.printRawLines(ex.getMessage());
+        Log.printLines(out, ex.getMessage());
         if (ex.getCause() != null && options.isSet("dev")) {
-            ex.getCause().printStackTrace(log.getWriter(WriterKind.NOTICE));
+            ex.getCause().printStackTrace(out);
         }
     }
 
     /** Print a message reporting an input/output error.
      */
     void ioMessage(Throwable ex) {
-        log.printLines(PrefixKind.JAVAC, "msg.io");
-        ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
+        Log.printLines(out, getLocalizedString("msg.io"));
+        ex.printStackTrace(out);
     }
 
     /** Print a message reporting an out-of-resources error.
      */
     void resourceMessage(Throwable ex) {
-        log.printLines(PrefixKind.JAVAC, "msg.resource");
-        ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
+        Log.printLines(out, getLocalizedString("msg.resource"));
+//      System.out.println("(name buffer len = " + Name.names.length + " " + Name.nc);//DEBUG
+        ex.printStackTrace(out);
     }
 
     /** Print a message reporting an uncaught exception from an
      * annotation processor.
      */
     void apMessage(AnnotationProcessingError ex) {
-        log.printLines("msg.proc.annotation.uncaught.exception");
-        ex.getCause().printStackTrace(log.getWriter(WriterKind.NOTICE));
+        Log.printLines(out,
+                       getLocalizedString("msg.proc.annotation.uncaught.exception"));
+        ex.getCause().printStackTrace(out);
     }
 
     /** Display the location and checksum of a class. */
     void showClass(String className) {
-        PrintWriter pw = log.getWriter(WriterKind.NOTICE);
-        pw.println("javac: show class: " + className);
+        out.println("javac: show class: " + className);
         URL url = getClass().getResource('/' + className.replace('.', '/') + ".class");
         if (url == null)
-            pw.println("  class not found");
+            out.println("  class not found");
         else {
-            pw.println("  " + url);
+            out.println("  " + url);
             try {
                 final String algorithm = "MD5";
                 byte[] digest;
@@ -562,9 +540,9 @@
                 StringBuilder sb = new StringBuilder();
                 for (byte b: digest)
                     sb.append(String.format("%02x", b));
-                pw.println("  " + algorithm + " checksum: " + sb);
+                out.println("  " + algorithm + " checksum: " + sb);
             } catch (Exception e) {
-                pw.println("  cannot compute digest: " + e);
+                out.println("  cannot compute digest: " + e);
             }
         }
     }
@@ -575,35 +553,35 @@
      * Internationalization
      *************************************************************************/
 
-//    /** Find a localized string in the resource bundle.
-//     *  @param key     The key for the localized string.
-//     */
-//    public static String getLocalizedString(String key, Object... args) { // FIXME sb private
-//        try {
-//            if (messages == null)
-//                messages = new JavacMessages(javacBundleName);
-//            return messages.getLocalizedString("javac." + key, args);
-//        }
-//        catch (MissingResourceException e) {
-//            throw new Error("Fatal Error: Resource for javac is missing", e);
-//        }
-//    }
-//
-//    public static void useRawMessages(boolean enable) {
-//        if (enable) {
-//            messages = new JavacMessages(javacBundleName) {
-//                    @Override
-//                    public String getLocalizedString(String key, Object... args) {
-//                        return key;
-//                    }
-//                };
-//        } else {
-//            messages = new JavacMessages(javacBundleName);
-//        }
-//    }
+    /** Find a localized string in the resource bundle.
+     *  @param key     The key for the localized string.
+     */
+    public static String getLocalizedString(String key, Object... args) { // FIXME sb private
+        try {
+            if (messages == null)
+                messages = new JavacMessages(javacBundleName);
+            return messages.getLocalizedString("javac." + key, args);
+        }
+        catch (MissingResourceException e) {
+            throw new Error("Fatal Error: Resource for javac is missing", e);
+        }
+    }
 
-    public static final String javacBundleName =
+    public static void useRawMessages(boolean enable) {
+        if (enable) {
+            messages = new JavacMessages(javacBundleName) {
+                    @Override
+                    public String getLocalizedString(String key, Object... args) {
+                        return key;
+                    }
+                };
+        } else {
+            messages = new JavacMessages(javacBundleName);
+        }
+    }
+
+    private static final String javacBundleName =
         "com.sun.tools.javac.resources.javac";
-//
-//    private static JavacMessages messages;
+
+    private static JavacMessages messages;
 }
Only in javac/main: OptionHelper.java
Only in javac/main: Option.java
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/main: OptionName.java
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/main: RecognizedOptions.java
diff -u -r javac/Main.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/Main.java
--- javac/Main.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/Main.java	2011-06-27 15:21:47.000000000 -0500
@@ -73,7 +73,7 @@
     public static int compile(String[] args) {
         com.sun.tools.javac.main.Main compiler =
             new com.sun.tools.javac.main.Main("javac");
-        return compiler.compile(args).exitCode;
+        return compiler.compile(args);
     }
 
 
@@ -91,6 +91,6 @@
     public static int compile(String[] args, PrintWriter out) {
         com.sun.tools.javac.main.Main compiler =
             new com.sun.tools.javac.main.Main("javac", out);
-        return compiler.compile(args).exitCode;
+        return compiler.compile(args);
     }
 }
diff -u -r javac/model/JavacElements.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/model/JavacElements.java
--- javac/model/JavacElements.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/model/JavacElements.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -48,7 +48,6 @@
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.Name;
 
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
@@ -289,7 +288,7 @@
                 }
             }
             public void visitArray(Attribute.Array array) {
-                if (tree.hasTag(NEWARRAY) &&
+                if (tree.getTag() == JCTree.NEWARRAY &&
                         types.elemtype(array.type).tsym == findme.type.tsym) {
                     List<JCExpression> elems = ((JCNewArray) tree).elems;
                     for (Attribute value : array.values) {
@@ -328,7 +327,7 @@
                     scan(t.args);
             }
             public void visitAssign(JCAssign t) {
-                if (t.lhs.hasTag(IDENT)) {
+                if (t.lhs.getTag() == JCTree.IDENT) {
                     JCIdent ident = (JCIdent) t.lhs;
                     if (ident.sym == sym)
                         result = t.rhs;
diff -u -r javac/nio/JavacPathFileManager.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/nio/JavacPathFileManager.java
--- javac/nio/JavacPathFileManager.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/nio/JavacPathFileManager.java	2011-06-27 15:21:47.000000000 -0500
@@ -25,7 +25,9 @@
 
 package com.sun.tools.javac.nio;
 
+
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.URL;
@@ -58,12 +60,13 @@
 import static java.nio.file.FileVisitOption.*;
 import static javax.tools.StandardLocation.*;
 
+import com.sun.tools.javac.file.Paths;
 import com.sun.tools.javac.util.BaseFileManager;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.ListBuffer;
 
-import static com.sun.tools.javac.main.Option.*;
+import static com.sun.tools.javac.main.OptionName.*;
 
 
 // NOTE the imports carefully for this compilation unit.
@@ -122,8 +125,9 @@
      * Set the context for JavacPathFileManager.
      */
     @Override
-    public void setContext(Context context) {
+    protected void setContext(Context context) {
         super.setContext(context);
+        searchPaths = Paths.instance(context);
     }
 
     @Override
@@ -169,7 +173,7 @@
 
     @Override
     public boolean isDefaultBootClassPath() {
-        return locations.isDefaultBootClassPath();
+        return searchPaths.isDefaultBootClassPath();
     }
 
     // <editor-fold defaultstate="collapsed" desc="Location handling">
@@ -227,13 +231,13 @@
         if (locn instanceof StandardLocation) {
             switch ((StandardLocation) locn) {
                 case CLASS_PATH:
-                    files = locations.userClassPath();
+                    files = searchPaths.userClassPath();
                     break;
                 case PLATFORM_CLASS_PATH:
-                    files = locations.bootClassPath();
+                    files = searchPaths.bootClassPath();
                     break;
                 case SOURCE_PATH:
-                    files = locations.sourcePath();
+                    files = searchPaths.sourcePath();
                     break;
                 case CLASS_OUTPUT: {
                     String arg = options.get(D);
@@ -268,6 +272,7 @@
         private boolean inited = false;
 
     private Map<Location, PathsForLocation> pathsForLocation;
+    private Paths searchPaths;
 
     private static class PathsForLocation extends LinkedHashSet<Path> {
         private static final long serialVersionUID = 6788510222394486733L;
diff -u -r javac/nio/PathFileObject.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/nio/PathFileObject.java
--- javac/nio/PathFileObject.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/nio/PathFileObject.java	2011-06-27 15:21:47.000000000 -0500
@@ -205,7 +205,6 @@
 
     @Override
     public OutputStream openOutputStream() throws IOException {
-        fileManager.flushCache(this);
         ensureParentDirectoriesExist();
         return Files.newOutputStream(path);
     }
@@ -242,7 +241,6 @@
 
     @Override
     public Writer openWriter() throws IOException {
-        fileManager.flushCache(this);
         ensureParentDirectoriesExist();
         return new OutputStreamWriter(Files.newOutputStream(path), fileManager.getEncodingName());
     }
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser: DocCommentScanner.java
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser: EndPosParser.java
Only in javac/parser: EndPosTable.java
diff -u -r javac/parser/JavacParser.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/JavacParser.java
--- javac/parser/JavacParser.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/JavacParser.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,28 +27,16 @@
 
 import java.util.*;
 
-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
-
-import com.sun.tools.javac.code.*;
-import com.sun.tools.javac.parser.Tokens.*;
-import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
 import com.sun.tools.javac.tree.*;
-import com.sun.tools.javac.tree.JCTree.*;
+import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.util.List;
-
-import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
-import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
-import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
-import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
-import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
-import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
-import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
-import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
 import static com.sun.tools.javac.util.ListBuffer.lb;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
+
+import com.sun.tools.javac.tree.JCTree.*;
+
+import static com.sun.tools.javac.parser.Token.*;
 
 /** The parser maps a token sequence into an abstract syntax
  *  tree. It operates by recursive descent, with code derived
@@ -69,7 +57,7 @@
 
     /** The scanner used for lexical analysis.
      */
-    protected Lexer S;
+    private Lexer S;
 
     /** The factory to be used for abstract syntax tree construction.
      */
@@ -79,27 +67,27 @@
      */
     private Log log;
 
+    /** The keyword table. */
+    private Keywords keywords;
+
     /** The Source language setting. */
     private Source source;
 
     /** The name table. */
     private Names names;
 
-    /** End position mappings container */
-    private final AbstractEndPosTable endPosTable;
-
     /** Construct a parser from a given scanner, tree factory and log.
      */
     protected JavacParser(ParserFactory fac,
                      Lexer S,
                      boolean keepDocComments,
-                     boolean keepLineMap,
-                     boolean keepEndPositions) {
+                     boolean keepLineMap) {
         this.S = S;
-        nextToken(); // prime the pump
+        S.nextToken(); // prime the pump
         this.F = fac.F;
         this.log = fac.log;
         this.names = fac.names;
+        this.keywords = fac.keywords;
         this.source = fac.source;
         this.allowGenerics = source.allowGenerics();
         this.allowVarargs = source.allowVarargs();
@@ -111,23 +99,13 @@
         this.allowTWR = source.allowTryWithResources();
         this.allowDiamond = source.allowDiamond();
         this.allowMulticatch = source.allowMulticatch();
-        this.allowStringFolding = fac.options.getBoolean("allowStringFolding", true);
-        this.allowLambda = source.allowLambda() &&
-                fac.options.isSet("allowLambda");
-        this.allowMethodReferences = source.allowMethodReferences() &&
-                fac.options.isSet("allowMethodReferences");
         this.keepDocComments = keepDocComments;
-        docComments = keepDocComments ? new HashMap<JCTree,String>() : null;
+        if (keepDocComments)
+            docComments = new HashMap<JCTree,String>();
         this.keepLineMap = keepLineMap;
         this.errorTree = F.Erroneous();
-        endPosTable = newEndPosTable(keepEndPositions);
     }
 
-    protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
-        return  keepEndPositions
-                ? new SimpleEndPosTable()
-                : new EmptyEndPosTable();
-    }
     /** Switch: Should generics be recognized?
      */
     boolean allowGenerics;
@@ -168,18 +146,6 @@
      */
     boolean allowTWR;
 
-    /** Switch: should we fold strings?
-     */
-    boolean allowStringFolding;
-
-    /** Switch: should we recognize lambda expressions?
-     */
-    boolean allowLambda;
-
-    /** Switch: should we allow method/constructor references?
-     */
-    boolean allowMethodReferences;
-
     /** Switch: should we keep docComments?
      */
     boolean keepDocComments;
@@ -208,40 +174,7 @@
      */
     private int lastmode = 0;
 
-    /* ---------- token management -------------- */
-
-    protected Token token;
-
-    protected void nextToken() {
-        S.nextToken();
-        token = S.token();
-    }
-
-    protected boolean peekToken(TokenKind tk) {
-        return S.token(1).kind == tk;
-    }
-
-    protected boolean peekToken(TokenKind tk1, TokenKind tk2) {
-        return S.token(1).kind == tk1 &&
-                S.token(2).kind == tk2;
-    }
-
-    protected boolean peekToken(TokenKind tk1, TokenKind tk2, TokenKind tk3) {
-        return S.token(1).kind == tk1 &&
-                S.token(2).kind == tk2 &&
-                S.token(3).kind == tk3;
-    }
-
-    protected boolean peekToken(TokenKind... kinds) {
-        for (int lookahead = 0 ; lookahead < kinds.length ; lookahead++) {
-            if (S.token(lookahead + 1).kind != kinds[lookahead]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /* ---------- error recovery -------------- */
+/* ---------- error recovery -------------- */
 
     private JCErroneous errorTree;
 
@@ -249,9 +182,9 @@
      */
     private void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
          while (true) {
-             switch (token.kind) {
+             switch (S.token()) {
                 case SEMI:
-                    nextToken();
+                    S.nextToken();
                     return;
                 case PUBLIC:
                 case FINAL:
@@ -312,54 +245,36 @@
                         return;
                     break;
             }
-            nextToken();
+            S.nextToken();
         }
     }
 
-    private JCErroneous syntaxError(int pos, String key, TokenKind... args) {
-        return syntaxError(pos, List.<JCTree>nil(), key, args);
+    private JCErroneous syntaxError(int pos, String key, Token... args) {
+        return syntaxError(pos, null, key, args);
     }
 
-    private JCErroneous syntaxError(int pos, List<JCTree> errs, String key, TokenKind... args) {
+    private JCErroneous syntaxError(int pos, List<JCTree> errs, String key, Token... args) {
         setErrorEndPos(pos);
-        JCErroneous err = F.at(pos).Erroneous(errs);
-        reportSyntaxError(err, key, (Object[])args);
-        if (errs != null) {
-            JCTree last = errs.last();
-            if (last != null)
-                storeEnd(last, pos);
-        }
-        return toP(err);
+        reportSyntaxError(pos, key, (Object[])args);
+        return toP(F.at(pos).Erroneous(errs));
     }
 
     private int errorPos = Position.NOPOS;
-
     /**
-     * Report a syntax using the given the position parameter and arguments,
-     * unless one was already reported at the same position.
+     * Report a syntax error at given position using the given
+     * argument unless one was already reported at the same position.
      */
     private void reportSyntaxError(int pos, String key, Object... args) {
-        JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
-        reportSyntaxError(diag, key, args);
-    }
-
-    /**
-     * Report a syntax error using the given DiagnosticPosition object and
-     * arguments, unless one was already reported at the same position.
-     */
-    private void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, String key, Object... args) {
-        int pos = diagPos.getPreferredPosition();
         if (pos > S.errPos() || pos == Position.NOPOS) {
-            if (token.kind == EOF) {
-                error(diagPos, "premature.eof");
-            } else {
-                error(diagPos, key, args);
-            }
+            if (S.token() == EOF)
+                error(pos, "premature.eof");
+            else
+                error(pos, key, args);
         }
         S.errPos(pos);
-        if (token.pos == errorPos)
-            nextToken(); // guarantee progress
-        errorPos = token.pos;
+        if (S.pos() == errorPos)
+            S.nextToken(); // guarantee progress
+        errorPos = S.pos();
     }
 
 
@@ -367,32 +282,32 @@
      *  reported at the same position.
      */
     private JCErroneous syntaxError(String key) {
-        return syntaxError(token.pos, key);
+        return syntaxError(S.pos(), key);
     }
 
     /** Generate a syntax error at current position unless one was
      *  already reported at the same position.
      */
-    private JCErroneous syntaxError(String key, TokenKind arg) {
-        return syntaxError(token.pos, key, arg);
+    private JCErroneous syntaxError(String key, Token arg) {
+        return syntaxError(S.pos(), key, arg);
     }
 
     /** If next input token matches given token, skip it, otherwise report
      *  an error.
      */
-    public void accept(TokenKind tk) {
-        if (token.kind == tk) {
-            nextToken();
+    public void accept(Token token) {
+        if (S.token() == token) {
+            S.nextToken();
         } else {
-            setErrorEndPos(token.pos);
-            reportSyntaxError(S.prevToken().endPos, "expected", tk);
+            setErrorEndPos(S.pos());
+            reportSyntaxError(S.prevEndPos(), "expected", token);
         }
     }
 
     /** Report an illegal start of expression/type error at given position.
      */
     JCExpression illegal(int pos) {
-        setErrorEndPos(pos);
+        setErrorEndPos(S.pos());
         if ((mode & EXPR) != 0)
             return syntaxError(pos, "illegal.start.of.expr");
         else
@@ -403,14 +318,14 @@
     /** Report an illegal start of expression/type error at current position.
      */
     JCExpression illegal() {
-        return illegal(token.pos);
+        return illegal(S.pos());
     }
 
     /** Diagnose a modifier flag from the set, if any. */
     void checkNoMods(long mods) {
         if (mods != 0) {
             long lowestMod = mods & -mods;
-            error(token.pos, "mod.not.allowed.here",
+            error(S.pos(), "mod.not.allowed.here",
                       Flags.asFlagSet(lowestMod));
         }
     }
@@ -421,7 +336,7 @@
      *  indexed by the tree nodes they refer to.
      *  defined only if option flag keepDocComment is set.
      */
-    private final Map<JCTree, String> docComments;
+    Map<JCTree, String> docComments;
 
     /** Make an entry into docComments hashtable,
      *  provided flag keepDocComments is set and given doc comment is non-null.
@@ -437,21 +352,37 @@
 
 /* -------- source positions ------- */
 
+    private int errorEndPos = -1;
+
     private void setErrorEndPos(int errPos) {
-        endPosTable.setErrorEndPos(errPos);
+        if (errPos > errorEndPos)
+            errorEndPos = errPos;
     }
 
-    private void storeEnd(JCTree tree, int endpos) {
-        endPosTable.storeEnd(tree, endpos);
+    protected int getErrorEndPos() {
+        return errorEndPos;
     }
 
-    private <T extends JCTree> T to(T t) {
-        return endPosTable.to(t);
-    }
+    /**
+     * Store ending position for a tree.
+     * @param tree   The tree.
+     * @param endpos The ending position to associate with the tree.
+     */
+    protected void storeEnd(JCTree tree, int endpos) {}
 
-    private <T extends JCTree> T toP(T t) {
-        return endPosTable.toP(t);
-    }
+    /**
+     * Store ending position for a tree.  The ending position should
+     * be the ending position of the current token.
+     * @param t The tree.
+     */
+    protected <T extends JCTree> T to(T t) { return t; }
+
+    /**
+     * Store ending position for a tree.  The ending position should
+     * be greater of the ending position of the previous token and errorEndPos.
+     * @param t The tree.
+     */
+    protected <T extends JCTree> T toP(T t) { return t; }
 
     /** Get the start position for a tree node.  The start position is
      * defined to be the position of the first character of the first
@@ -471,7 +402,7 @@
      * @param tree  The tree node
      */
     public int getEndPos(JCTree tree) {
-        return endPosTable.getEndPos(tree);
+        return Position.NOPOS;
     }
 
 
@@ -482,30 +413,30 @@
      * Ident = IDENTIFIER
      */
     Name ident() {
-        if (token.kind == IDENTIFIER) {
-            Name name = token.name();
-            nextToken();
+        if (S.token() == IDENTIFIER) {
+            Name name = S.name();
+            S.nextToken();
             return name;
-        } else if (token.kind == ASSERT) {
+        } else if (S.token() == ASSERT) {
             if (allowAsserts) {
-                error(token.pos, "assert.as.identifier");
-                nextToken();
+                error(S.pos(), "assert.as.identifier");
+                S.nextToken();
                 return names.error;
             } else {
-                warning(token.pos, "assert.as.identifier");
-                Name name = token.name();
-                nextToken();
+                warning(S.pos(), "assert.as.identifier");
+                Name name = S.name();
+                S.nextToken();
                 return name;
             }
-        } else if (token.kind == ENUM) {
+        } else if (S.token() == ENUM) {
             if (allowEnums) {
-                error(token.pos, "enum.as.identifier");
-                nextToken();
+                error(S.pos(), "enum.as.identifier");
+                S.nextToken();
                 return names.error;
             } else {
-                warning(token.pos, "enum.as.identifier");
-                Name name = token.name();
-                nextToken();
+                warning(S.pos(), "enum.as.identifier");
+                Name name = S.name();
+                S.nextToken();
                 return name;
             }
         } else {
@@ -518,19 +449,15 @@
      * Qualident = Ident { DOT Ident }
      */
     public JCExpression qualident() {
-        JCExpression t = toP(F.at(token.pos).Ident(ident()));
-        while (token.kind == DOT) {
-            int pos = token.pos;
-            nextToken();
+        JCExpression t = toP(F.at(S.pos()).Ident(ident()));
+        while (S.token() == DOT) {
+            int pos = S.pos();
+            S.nextToken();
             t = toP(F.at(pos).Select(t, ident()));
         }
         return t;
     }
 
-    JCExpression literal(Name prefix) {
-        return literal(prefix, token.pos);
-    }
-
     /**
      * Literal =
      *     INTLITERAL
@@ -543,31 +470,30 @@
      *   | FALSE
      *   | NULL
      */
-    JCExpression literal(Name prefix, int pos) {
+    JCExpression literal(Name prefix) {
+        int pos = S.pos();
         JCExpression t = errorTree;
-        switch (token.kind) {
+        switch (S.token()) {
         case INTLITERAL:
             try {
                 t = F.at(pos).Literal(
                     TypeTags.INT,
-                    Convert.string2int(strval(prefix), token.radix()));
+                    Convert.string2int(strval(prefix), S.radix()));
             } catch (NumberFormatException ex) {
-                error(token.pos, "int.number.too.large", strval(prefix));
+                error(S.pos(), "int.number.too.large", strval(prefix));
             }
             break;
         case LONGLITERAL:
             try {
                 t = F.at(pos).Literal(
                     TypeTags.LONG,
-                    new Long(Convert.string2long(strval(prefix), token.radix())));
+                    new Long(Convert.string2long(strval(prefix), S.radix())));
             } catch (NumberFormatException ex) {
-                error(token.pos, "int.number.too.large", strval(prefix));
+                error(S.pos(), "int.number.too.large", strval(prefix));
             }
             break;
         case FLOATLITERAL: {
-            String proper = token.radix() == 16 ?
-                    ("0x"+ token.stringVal()) :
-                    token.stringVal();
+            String proper = (S.radix() == 16 ? ("0x"+ S.stringVal()) : S.stringVal());
             Float n;
             try {
                 n = Float.valueOf(proper);
@@ -576,17 +502,15 @@
                 n = Float.NaN;
             }
             if (n.floatValue() == 0.0f && !isZero(proper))
-                error(token.pos, "fp.number.too.small");
+                error(S.pos(), "fp.number.too.small");
             else if (n.floatValue() == Float.POSITIVE_INFINITY)
-                error(token.pos, "fp.number.too.large");
+                error(S.pos(), "fp.number.too.large");
             else
                 t = F.at(pos).Literal(TypeTags.FLOAT, n);
             break;
         }
         case DOUBLELITERAL: {
-            String proper = token.radix() == 16 ?
-                    ("0x"+ token.stringVal()) :
-                    token.stringVal();
+            String proper = (S.radix() == 16 ? ("0x"+ S.stringVal()) : S.stringVal());
             Double n;
             try {
                 n = Double.valueOf(proper);
@@ -595,9 +519,9 @@
                 n = Double.NaN;
             }
             if (n.doubleValue() == 0.0d && !isZero(proper))
-                error(token.pos, "fp.number.too.small");
+                error(S.pos(), "fp.number.too.small");
             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
-                error(token.pos, "fp.number.too.large");
+                error(S.pos(), "fp.number.too.large");
             else
                 t = F.at(pos).Literal(TypeTags.DOUBLE, n);
             break;
@@ -605,17 +529,17 @@
         case CHARLITERAL:
             t = F.at(pos).Literal(
                 TypeTags.CHAR,
-                token.stringVal().charAt(0) + 0);
+                S.stringVal().charAt(0) + 0);
             break;
         case STRINGLITERAL:
             t = F.at(pos).Literal(
                 TypeTags.CLASS,
-                token.stringVal());
+                S.stringVal());
             break;
         case TRUE: case FALSE:
             t = F.at(pos).Literal(
                 TypeTags.BOOLEAN,
-                (token.kind == TRUE ? 1 : 0));
+                (S.token() == TRUE ? 1 : 0));
             break;
         case NULL:
             t = F.at(pos).Literal(
@@ -627,8 +551,8 @@
         }
         if (t == errorTree)
             t = F.at(pos).Erroneous();
-        storeEnd(t, token.endPos);
-        nextToken();
+        storeEnd(t, S.endPos());
+        S.nextToken();
         return t;
     }
 //where
@@ -641,7 +565,7 @@
         }
 
         String strval(Name prefix) {
-            String s = token.stringVal();
+            String s = S.stringVal();
             return prefix.isEmpty() ? s : prefix + s;
         }
 
@@ -678,17 +602,17 @@
     JCExpression term() {
         JCExpression t = term1();
         if ((mode & EXPR) != 0 &&
-            token.kind == EQ || PLUSEQ.compareTo(token.kind) <= 0 && token.kind.compareTo(GTGTGTEQ) <= 0)
+            S.token() == EQ || PLUSEQ.compareTo(S.token()) <= 0 && S.token().compareTo(GTGTGTEQ) <= 0)
             return termRest(t);
         else
             return t;
     }
 
     JCExpression termRest(JCExpression t) {
-        switch (token.kind) {
+        switch (S.token()) {
         case EQ: {
-            int pos = token.pos;
-            nextToken();
+            int pos = S.pos();
+            S.nextToken();
             mode = EXPR;
             JCExpression t1 = term();
             return toP(F.at(pos).Assign(t, t1));
@@ -704,12 +628,12 @@
         case LTLTEQ:
         case GTGTEQ:
         case GTGTGTEQ:
-            int pos = token.pos;
-            TokenKind tk = token.kind;
-            nextToken();
+            int pos = S.pos();
+            Token token = S.token();
+            S.nextToken();
             mode = EXPR;
             JCExpression t1 = term();
-            return F.at(pos).Assignop(optag(tk), t, t1);
+            return F.at(pos).Assignop(optag(token), t, t1);
         default:
             return t;
         }
@@ -721,7 +645,7 @@
      */
     JCExpression term1() {
         JCExpression t = term2();
-        if ((mode & EXPR) != 0 && token.kind == QUES) {
+        if ((mode & EXPR) != 0 && S.token() == QUES) {
             mode = EXPR;
             return term1Rest(t);
         } else {
@@ -732,9 +656,9 @@
     /** Expression1Rest = ["?" Expression ":" Expression1]
      */
     JCExpression term1Rest(JCExpression t) {
-        if (token.kind == QUES) {
-            int pos = token.pos;
-            nextToken();
+        if (S.token() == QUES) {
+            int pos = S.pos();
+            S.nextToken();
             JCExpression t1 = term();
             accept(COLON);
             JCExpression t2 = term1();
@@ -750,7 +674,7 @@
      */
     JCExpression term2() {
         JCExpression t = term3();
-        if ((mode & EXPR) != 0 && prec(token.kind) >= TreeInfo.orPrec) {
+        if ((mode & EXPR) != 0 && prec(S.token()) >= TreeInfo.orPrec) {
             mode = EXPR;
             return term2Rest(t, TreeInfo.orPrec);
         } else {
@@ -776,29 +700,34 @@
         JCExpression[] odStack = newOdStack();
         List<Token[]> savedOp = opStackSupply.elems;
         Token[] opStack = newOpStack();
-
+        List<int[]> savedPos = posStackSupply.elems;
+        int[] posStack = newPosStack();
         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
         int top = 0;
         odStack[0] = t;
-        int startPos = token.pos;
-        Token topOp = Tokens.DUMMY;
-        while (prec(token.kind) >= minprec) {
+        int startPos = S.pos();
+        Token topOp = ERROR;
+        int topOpPos = Position.NOPOS;
+        while (prec(S.token()) >= minprec) {
+            posStack[top] = topOpPos;
             opStack[top] = topOp;
             top++;
-            topOp = token;
-            nextToken();
-            odStack[top] = (topOp.kind == INSTANCEOF) ? parseType() : term3();
-            while (top > 0 && prec(topOp.kind) >= prec(token.kind)) {
-                odStack[top-1] = makeOp(topOp.pos, topOp.kind, odStack[top-1],
+            topOp = S.token();
+            topOpPos = S.pos();
+            S.nextToken();
+            odStack[top] = (topOp == INSTANCEOF) ? parseType() : term3();
+            while (top > 0 && prec(topOp) >= prec(S.token())) {
+                odStack[top-1] = makeOp(topOpPos, topOp, odStack[top-1],
                                         odStack[top]);
                 top--;
                 topOp = opStack[top];
+                topOpPos = posStack[top];
             }
         }
         Assert.check(top == 0);
         t = odStack[0];
 
-        if (t.hasTag(JCTree.Tag.PLUS)) {
+        if (t.getTag() == JCTree.PLUS) {
             StringBuffer buf = foldStrings(t);
             if (buf != null) {
                 t = toP(F.at(startPos).Literal(TypeTags.CLASS, buf.toString()));
@@ -807,13 +736,14 @@
 
         odStackSupply.elems = savedOd; // optimization
         opStackSupply.elems = savedOp; // optimization
+        posStackSupply.elems = savedPos; // optimization
         return t;
     }
 //where
         /** Construct a binary or type test node.
          */
         private JCExpression makeOp(int pos,
-                                    TokenKind topOp,
+                                    Token topOp,
                                     JCExpression od1,
                                     JCExpression od2)
         {
@@ -827,11 +757,9 @@
          *  by a single literal representing the concatenated string.
          */
         protected StringBuffer foldStrings(JCTree tree) {
-            if (!allowStringFolding)
-                return null;
             List<String> buf = List.nil();
             while (true) {
-                if (tree.hasTag(LITERAL)) {
+                if (tree.getTag() == JCTree.LITERAL) {
                     JCLiteral lit = (JCLiteral) tree;
                     if (lit.typetag == TypeTags.CLASS) {
                         StringBuffer sbuf =
@@ -842,9 +770,9 @@
                         }
                         return sbuf;
                     }
-                } else if (tree.hasTag(JCTree.Tag.PLUS)) {
+                } else if (tree.getTag() == JCTree.PLUS) {
                     JCBinary op = (JCBinary)tree;
-                    if (op.rhs.hasTag(LITERAL)) {
+                    if (op.rhs.getTag() == JCTree.LITERAL) {
                         JCLiteral lit = (JCLiteral) op.rhs;
                         if (lit.typetag == TypeTags.CLASS) {
                             buf = buf.prepend((String) lit.value);
@@ -862,6 +790,7 @@
          */
         ListBuffer<JCExpression[]> odStackSupply = new ListBuffer<JCExpression[]>();
         ListBuffer<Token[]> opStackSupply = new ListBuffer<Token[]>();
+        ListBuffer<int[]> posStackSupply = new ListBuffer<int[]>();
 
         private JCExpression[] newOdStack() {
             if (odStackSupply.elems == odStackSupply.last)
@@ -879,6 +808,14 @@
             return opStack;
         }
 
+        private int[] newPosStack() {
+            if (posStackSupply.elems == posStackSupply.last)
+                posStackSupply.append(new int[infixPrecedenceLevels + 1]);
+            int[] posStack = posStackSupply.elems.head;
+            posStackSupply.elems = posStackSupply.elems.tail;
+            return posStack;
+        }
+
     /** Expression3    = PrefixOp Expression3
      *                 | "(" Expr | TypeNoParams ")" Expression3
      *                 | Primary {Selector} {PostfixOp}
@@ -887,10 +824,7 @@
      *                 | [TypeArguments] THIS [Arguments]
      *                 | [TypeArguments] SUPER SuperSuffix
      *                 | NEW [TypeArguments] Creator
-     *                 | "(" Arguments ")" "->" ( Expression | Block )
-     *                 | Ident "->" ( Expression | Block )
      *                 | Ident { "." Ident }
-     *                 | Expression3 MemberReferenceSuffix
      *                   [ "[" ( "]" BracketsOpt "." CLASS | Expression "]" )
      *                   | Arguments
      *                   | "." ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
@@ -910,10 +844,10 @@
      *  SuperSuffix    = Arguments | "." Ident [Arguments]
      */
     protected JCExpression term3() {
-        int pos = token.pos;
+        int pos = S.pos();
         JCExpression t;
         List<JCExpression> typeArgs = typeArgumentsOpt(EXPR);
-        switch (token.kind) {
+        switch (S.token()) {
         case QUES:
             if ((mode & TYPE) != 0 && (mode & (TYPEARG|NOPARAMS)) == TYPEARG) {
                 mode = TYPE;
@@ -922,92 +856,64 @@
                 return illegal();
         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
             if (typeArgs == null && (mode & EXPR) != 0) {
-                TokenKind tk = token.kind;
-                nextToken();
+                Token token = S.token();
+                S.nextToken();
                 mode = EXPR;
-                if (tk == SUB &&
-                    (token.kind == INTLITERAL || token.kind == LONGLITERAL) &&
-                    token.radix() == 10) {
+                if (token == SUB &&
+                    (S.token() == INTLITERAL || S.token() == LONGLITERAL) &&
+                    S.radix() == 10) {
                     mode = EXPR;
-                    t = literal(names.hyphen, pos);
+                    t = literal(names.hyphen);
                 } else {
                     t = term3();
-                    return F.at(pos).Unary(unoptag(tk), t);
+                    return F.at(pos).Unary(unoptag(token), t);
                 }
             } else return illegal();
             break;
         case LPAREN:
             if (typeArgs == null && (mode & EXPR) != 0) {
-                if (peekToken(FINAL) ||
-                        peekToken(RPAREN) ||
-                        peekToken(IDENTIFIER, COMMA) ||
-                        peekToken(IDENTIFIER, RPAREN, ARROW)) {
-                    //implicit n-ary lambda
-                    t = lambdaExpressionOrStatement(true, peekToken(FINAL), pos);
-                    break;
-                } else {
-                    nextToken();
-                    mode = EXPR | TYPE | NOPARAMS;
-                    t = term3();
-                    if ((mode & TYPE) != 0 && token.kind == LT) {
-                        // Could be a cast to a parameterized type
-                        JCTree.Tag op = JCTree.Tag.LT;
-                        int pos1 = token.pos;
-                        nextToken();
-                        mode &= (EXPR | TYPE);
-                        mode |= TYPEARG;
-                        JCExpression t1 = term3();
-                        if ((mode & TYPE) != 0 &&
-                            (token.kind == COMMA || token.kind == GT)) {
+                S.nextToken();
+                mode = EXPR | TYPE | NOPARAMS;
+                t = term3();
+                if ((mode & TYPE) != 0 && S.token() == LT) {
+                    // Could be a cast to a parameterized type
+                    int op = JCTree.LT;
+                    int pos1 = S.pos();
+                    S.nextToken();
+                    mode &= (EXPR | TYPE);
+                    mode |= TYPEARG;
+                    JCExpression t1 = term3();
+                    if ((mode & TYPE) != 0 &&
+                        (S.token() == COMMA || S.token() == GT)) {
+                        mode = TYPE;
+                        ListBuffer<JCExpression> args = new ListBuffer<JCExpression>();
+                        args.append(t1);
+                        while (S.token() == COMMA) {
+                            S.nextToken();
+                            args.append(typeArgument());
+                        }
+                        accept(GT);
+                        t = toP(F.at(pos1).TypeApply(t, args.toList()));
+                        checkGenerics();
+                        while (S.token() == DOT) {
+                            S.nextToken();
                             mode = TYPE;
-                            ListBuffer<JCExpression> args = new ListBuffer<JCExpression>();
-                            args.append(t1);
-                            while (token.kind == COMMA) {
-                                nextToken();
-                                args.append(typeArgument());
-                            }
-                            accept(GT);
-                            t = toP(F.at(pos1).TypeApply(t, args.toList()));
-                            checkGenerics();
-                            mode = EXPR | TYPE; //could be a lambda or a method ref or a cast to a type
-                            t = term3Rest(t, typeArgs);
-                            if (token.kind == IDENTIFIER || token.kind == ELLIPSIS) {
-                                //explicit lambda (w/ generic type)
-                                mode = EXPR;
-                                JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
-                                if (token.kind == ELLIPSIS) {
-                                    mods.flags = Flags.VARARGS;
-                                    t = to(F.at(token.pos).TypeArray(t));
-                                    nextToken();
-                                }
-                                t = lambdaExpressionOrStatement(variableDeclaratorId(mods, t), pos);
-                                break;
-                            }
-                        } else if ((mode & EXPR) != 0) {
-                            mode = EXPR;
-                            JCExpression e = term2Rest(t1, TreeInfo.shiftPrec);
-                            t = F.at(pos1).Binary(op, t, e);
-                            t = termRest(term1Rest(term2Rest(t, TreeInfo.orPrec)));
-                        } else {
-                            accept(GT);
+                            t = toP(F.at(S.pos()).Select(t, ident()));
+                            t = typeArgumentsOpt(t);
                         }
-                    } else if ((mode & TYPE) != 0 &&
-                            (token.kind == IDENTIFIER || token.kind == ELLIPSIS)) {
-                        //explicit lambda (w/ non-generic type)
+                        t = bracketsOpt(toP(t));
+                    } else if ((mode & EXPR) != 0) {
                         mode = EXPR;
-                        JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
-                        if (token.kind == ELLIPSIS) {
-                            mods.flags = Flags.VARARGS;
-                            t = to(F.at(token.pos).TypeArray(t));
-                            nextToken();
-                        }
-                        t = lambdaExpressionOrStatement(variableDeclaratorId(mods, t), pos);
-                        break;
-                    } else {
+                        JCExpression e = term2Rest(t1, TreeInfo.shiftPrec);
+                        t = F.at(pos1).Binary(op, t, e);
                         t = termRest(term1Rest(term2Rest(t, TreeInfo.orPrec)));
+                    } else {
+                        accept(GT);
                     }
                 }
-
+                else {
+                    t = termRest(term1Rest(term2Rest(t, TreeInfo.orPrec)));
+                }
                 accept(RPAREN);
                 lastmode = mode;
                 mode = EXPR;
@@ -1015,30 +921,28 @@
                     JCExpression t1 = term3();
                     return F.at(pos).TypeCast(t, t1);
                 } else if ((lastmode & TYPE) != 0) {
-                    switch (token.kind) {
+                    switch (S.token()) {
                     /*case PLUSPLUS: case SUBSUB: */
                     case BANG: case TILDE:
                     case LPAREN: case THIS: case SUPER:
                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
                     case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
                     case TRUE: case FALSE: case NULL:
-                        case NEW: case IDENTIFIER: case ASSERT: case ENUM:
+                    case NEW: case IDENTIFIER: case ASSERT: case ENUM:
                     case BYTE: case SHORT: case CHAR: case INT:
                     case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
                         JCExpression t1 = term3();
                         return F.at(pos).TypeCast(t, t1);
                     }
                 }
-            } else {
-                return illegal();
-            }
+            } else return illegal();
             t = toP(F.at(pos).Parens(t));
             break;
         case THIS:
             if ((mode & EXPR) != 0) {
                 mode = EXPR;
                 t = to(F.at(pos).Ident(names._this));
-                nextToken();
+                S.nextToken();
                 if (typeArgs == null)
                     t = argumentsOpt(null, t);
                 else
@@ -1066,116 +970,83 @@
             if (typeArgs != null) return illegal();
             if ((mode & EXPR) != 0) {
                 mode = EXPR;
-                nextToken();
-                if (token.kind == LT) typeArgs = typeArguments(false);
+                S.nextToken();
+                if (S.token() == LT) typeArgs = typeArguments(false);
                 t = creator(pos, typeArgs);
                 typeArgs = null;
             } else return illegal();
             break;
         case IDENTIFIER: case ASSERT: case ENUM:
             if (typeArgs != null) return illegal();
-            if ((mode & EXPR) != 0 && peekToken(ARROW)) {
-                t = lambdaExpressionOrStatement(false, false, pos);
-            } else {
-                t = toP(F.at(token.pos).Ident(ident()));
-                loop: while (true) {
-                    pos = token.pos;
-                    switch (token.kind) {
-                    case LBRACKET:
-                        nextToken();
-                        if (token.kind == RBRACKET) {
-                            nextToken();
-                            t = bracketsOpt(t);
-                            t = toP(F.at(pos).TypeArray(t));
-                            t = bracketsSuffix(t);
-                        } else {
-                            if ((mode & EXPR) != 0) {
-                                mode = EXPR;
-                                JCExpression t1 = term();
-                                t = to(F.at(pos).Indexed(t, t1));
-                            }
-                            accept(RBRACKET);
-                        }
-                        break loop;
-                    case LPAREN:
+            t = toP(F.at(S.pos()).Ident(ident()));
+            loop: while (true) {
+                pos = S.pos();
+                switch (S.token()) {
+                case LBRACKET:
+                    S.nextToken();
+                    if (S.token() == RBRACKET) {
+                        S.nextToken();
+                        t = bracketsOpt(t);
+                        t = toP(F.at(pos).TypeArray(t));
+                        t = bracketsSuffix(t);
+                    } else {
                         if ((mode & EXPR) != 0) {
                             mode = EXPR;
-                            t = arguments(typeArgs, t);
-                            typeArgs = null;
+                            JCExpression t1 = term();
+                            t = to(F.at(pos).Indexed(t, t1));
                         }
-                        break loop;
-                    case DOT:
-                        nextToken();
-                        int oldmode = mode;
-                        mode &= ~NOPARAMS;
-                        typeArgs = typeArgumentsOpt(EXPR);
-                        mode = oldmode;
-                        if ((mode & EXPR) != 0) {
-                            switch (token.kind) {
-                            case CLASS:
-                                if (typeArgs != null) return illegal();
-                                mode = EXPR;
-                                t = to(F.at(pos).Select(t, names._class));
-                                nextToken();
-                                break loop;
-                            case THIS:
-                                if (typeArgs != null) return illegal();
-                                mode = EXPR;
-                                t = to(F.at(pos).Select(t, names._this));
-                                nextToken();
-                                break loop;
-                            case SUPER:
-                                mode = EXPR;
-                                t = to(F.at(pos).Select(t, names._super));
-                                t = superSuffix(typeArgs, t);
-                                typeArgs = null;
-                                break loop;
-                            case NEW:
-                                if (typeArgs != null) return illegal();
-                                mode = EXPR;
-                                int pos1 = token.pos;
-                                nextToken();
-                                if (token.kind == LT) typeArgs = typeArguments(false);
-                                t = innerCreator(pos1, typeArgs, t);
-                                typeArgs = null;
-                                break loop;
-                            }
-                        }
-                        // typeArgs saved for next loop iteration.
-                        t = toP(F.at(pos).Select(t, ident()));
-                        break;
-                    case LT:
-                        if ((mode & TYPE) == 0 && isUnboundMemberRef()) {
-                            //this is an unbound method reference whose qualifier
-                            //is a generic type i.e. A<S>#m
-                            int pos1 = token.pos;
-                            accept(LT);
-                            ListBuffer<JCExpression> args = new ListBuffer<JCExpression>();
-                            args.append(typeArgument());
-                            while (token.kind == COMMA) {
-                                nextToken();
-                                args.append(typeArgument());
-                            }
-                            accept(GT);
-                            t = toP(F.at(pos1).TypeApply(t, args.toList()));
-                            checkGenerics();
-                            while (token.kind == DOT) {
-                                nextToken();
-                                mode = TYPE;
-                                t = toP(F.at(token.pos).Select(t, ident()));
-                                t = typeArgumentsOpt(t);
-                            }
-                            if (token.kind != HASH) {
-                                //method reference expected here
-                                t = illegal();
-                            }
+                        accept(RBRACKET);
+                    }
+                    break loop;
+                case LPAREN:
+                    if ((mode & EXPR) != 0) {
+                        mode = EXPR;
+                        t = arguments(typeArgs, t);
+                        typeArgs = null;
+                    }
+                    break loop;
+                case DOT:
+                    S.nextToken();
+                    int oldmode = mode;
+                    mode &= ~NOPARAMS;
+                    typeArgs = typeArgumentsOpt(EXPR);
+                    mode = oldmode;
+                    if ((mode & EXPR) != 0) {
+                        switch (S.token()) {
+                        case CLASS:
+                            if (typeArgs != null) return illegal();
+                            mode = EXPR;
+                            t = to(F.at(pos).Select(t, names._class));
+                            S.nextToken();
+                            break loop;
+                        case THIS:
+                            if (typeArgs != null) return illegal();
                             mode = EXPR;
-                            return term3Rest(t, typeArgs);
+                            t = to(F.at(pos).Select(t, names._this));
+                            S.nextToken();
+                            break loop;
+                        case SUPER:
+                            mode = EXPR;
+                            t = to(F.at(pos).Select(t, names._super));
+                            t = superSuffix(typeArgs, t);
+                            typeArgs = null;
+                            break loop;
+                        case NEW:
+                            if (typeArgs != null) return illegal();
+                            mode = EXPR;
+                            int pos1 = S.pos();
+                            S.nextToken();
+                            if (S.token() == LT) typeArgs = typeArguments(false);
+                            t = innerCreator(pos1, typeArgs, t);
+                            typeArgs = null;
+                            break loop;
                         }
-                        break loop;
-                    default:
-                        break loop;
                     }
+                    // typeArgs saved for next loop iteration.
+                    t = toP(F.at(pos).Select(t, ident()));
+                    break;
+                default:
+                    break loop;
                 }
             }
             if (typeArgs != null) illegal();
@@ -1189,8 +1060,8 @@
         case VOID:
             if (typeArgs != null) illegal();
             if ((mode & EXPR) != 0) {
-                nextToken();
-                if (token.kind == DOT) {
+                S.nextToken();
+                if (S.token() == DOT) {
                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTags.VOID));
                     t = bracketsSuffix(ti);
                 } else {
@@ -1201,7 +1072,7 @@
                 // a void type (like other primitive types) to the next phase.
                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTags.VOID));
-                nextToken();
+                S.nextToken();
                 return ti;
                 //return illegal();
             }
@@ -1209,20 +1080,16 @@
         default:
             return illegal();
         }
-        return term3Rest(t, typeArgs);
-    }
-
-    JCExpression term3Rest(JCExpression t, List<JCExpression> typeArgs) {
         if (typeArgs != null) illegal();
         while (true) {
-            int pos1 = token.pos;
-            if (token.kind == LBRACKET) {
-                nextToken();
+            int pos1 = S.pos();
+            if (S.token() == LBRACKET) {
+                S.nextToken();
                 if ((mode & TYPE) != 0) {
                     int oldmode = mode;
                     mode = TYPE;
-                    if (token.kind == RBRACKET) {
-                        nextToken();
+                    if (S.token() == RBRACKET) {
+                        S.nextToken();
                         t = bracketsOpt(t);
                         t = toP(F.at(pos1).TypeArray(t));
                         return t;
@@ -1235,21 +1102,21 @@
                     t = to(F.at(pos1).Indexed(t, t1));
                 }
                 accept(RBRACKET);
-            } else if (token.kind == DOT) {
-                nextToken();
+            } else if (S.token() == DOT) {
+                S.nextToken();
                 typeArgs = typeArgumentsOpt(EXPR);
-                if (token.kind == SUPER && (mode & EXPR) != 0) {
+                if (S.token() == SUPER && (mode & EXPR) != 0) {
                     mode = EXPR;
                     t = to(F.at(pos1).Select(t, names._super));
-                    nextToken();
+                    S.nextToken();
                     t = arguments(typeArgs, t);
                     typeArgs = null;
-                } else if (token.kind == NEW && (mode & EXPR) != 0) {
+                } else if (S.token() == NEW && (mode & EXPR) != 0) {
                     if (typeArgs != null) return illegal();
                     mode = EXPR;
-                    int pos2 = token.pos;
-                    nextToken();
-                    if (token.kind == LT) typeArgs = typeArguments(false);
+                    int pos2 = S.pos();
+                    S.nextToken();
+                    if (S.token() == LT) typeArgs = typeArguments(false);
                     t = innerCreator(pos2, typeArgs, t);
                     typeArgs = null;
                 } else {
@@ -1257,116 +1124,29 @@
                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
                     typeArgs = null;
                 }
-            } else if ((mode & EXPR) != 0 && token.kind == HASH) {
-                mode = EXPR;
-                if (typeArgs != null) return illegal();
-                accept(HASH);
-                t = memberReferenceSuffix(pos1, t);
             } else {
                 break;
             }
         }
-        while ((token.kind == PLUSPLUS || token.kind == SUBSUB) && (mode & EXPR) != 0) {
+        while ((S.token() == PLUSPLUS || S.token() == SUBSUB) && (mode & EXPR) != 0) {
             mode = EXPR;
-            t = to(F.at(token.pos).Unary(
-                  token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
-            nextToken();
+            t = to(F.at(S.pos()).Unary(
+                  S.token() == PLUSPLUS ? JCTree.POSTINC : JCTree.POSTDEC, t));
+            S.nextToken();
         }
         return toP(t);
     }
 
-    /**
-     * If we see an identifier followed by a '&lt;' it could be an unbound
-     * method reference or a binary expression. To disambiguate, look for a
-     * matching '&gt;' and see if the subsequent terminal is either '.' or '#'.
-     */
-    @SuppressWarnings("fallthrough")
-    boolean isUnboundMemberRef() {
-        int pos = 0, depth = 0;
-        for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
-            switch (t.kind) {
-                case IDENTIFIER: case QUES: case EXTENDS: case SUPER:
-                case DOT: case RBRACKET: case LBRACKET: case COMMA:
-                case BYTE: case SHORT: case INT: case LONG: case FLOAT:
-                case DOUBLE: case BOOLEAN: case CHAR:
-                    break;
-                case LT:
-                    depth++; break;
-                case GTGTGT:
-                    depth--;
-                case GTGT:
-                    depth--;
-                case GT:
-                    depth--;
-                    if (depth == 0) {
-                        return
-                            S.token(pos + 1).kind == TokenKind.DOT ||
-                            S.token(pos + 1).kind == TokenKind.HASH;
-                    }
-                    break;
-                default:
-                    return false;
-            }
-        }
-    }
-
-    JCExpression lambdaExpressionOrStatement(JCVariableDecl firstParam, int pos) {
-        ListBuffer<JCVariableDecl> params = new ListBuffer<JCVariableDecl>();
-        params.append(firstParam);
-        JCVariableDecl lastParam = firstParam;
-        while ((lastParam.mods.flags & Flags.VARARGS) == 0 && token.kind == COMMA) {
-            nextToken();
-            params.append(lastParam = formalParameter());
-        }
-        accept(RPAREN);
-        return lambdaExpressionOrStatementRest(params.toList(), pos);
-    }
-
-    JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
-        List<JCVariableDecl> params = explicitParams ?
-                formalParameters() :
-                implicitParameters(hasParens);
-
-        return lambdaExpressionOrStatementRest(params, pos);
-    }
-
-    JCExpression lambdaExpressionOrStatementRest(List<JCVariableDecl> args, int pos) {
-        if (token.kind != ARROW) {
-            //better error recovery
-            return F.at(pos).Erroneous(args);
-        }
-
-        checkLambda();
-        accept(ARROW);
-
-        return token.kind == LBRACE ?
-            lambdaStatement(args, pos, pos) :
-            lambdaExpression(args, pos);
-    }
-
-    JCExpression lambdaStatement(List<JCVariableDecl> args, int pos, int pos2) {
-        JCBlock block = block(pos2, 0);
-        return toP(F.at(pos).Lambda(args, block));
-    }
-
-    JCExpression lambdaExpression(List<JCVariableDecl> args, int pos) {
-        JCTree expr = parseExpression();
-        return toP(F.at(pos).Lambda(args, expr));
-    }
-
     /** SuperSuffix = Arguments | "." [TypeArguments] Ident [Arguments]
      */
     JCExpression superSuffix(List<JCExpression> typeArgs, JCExpression t) {
-        nextToken();
-        if (token.kind == LPAREN || typeArgs != null) {
+        S.nextToken();
+        if (S.token() == LPAREN || typeArgs != null) {
             t = arguments(typeArgs, t);
-        } else if (token.kind == HASH) {
-            if (typeArgs != null) return illegal();
-            t = memberReferenceSuffix(t);
         } else {
-            int pos = token.pos;
+            int pos = S.pos();
             accept(DOT);
-            typeArgs = (token.kind == LT) ? typeArguments(false) : null;
+            typeArgs = (S.token() == LT) ? typeArguments(false) : null;
             t = toP(F.at(pos).Select(t, ident()));
             t = argumentsOpt(typeArgs, t);
         }
@@ -1376,15 +1156,15 @@
     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
      */
     JCPrimitiveTypeTree basicType() {
-        JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
-        nextToken();
+        JCPrimitiveTypeTree t = to(F.at(S.pos()).TypeIdent(typetag(S.token())));
+        S.nextToken();
         return t;
     }
 
     /** ArgumentsOpt = [ Arguments ]
      */
     JCExpression argumentsOpt(List<JCExpression> typeArgs, JCExpression t) {
-        if ((mode & EXPR) != 0 && token.kind == LPAREN || typeArgs != null) {
+        if ((mode & EXPR) != 0 && S.token() == LPAREN || typeArgs != null) {
             mode = EXPR;
             return arguments(typeArgs, t);
         } else {
@@ -1396,24 +1176,24 @@
      */
     List<JCExpression> arguments() {
         ListBuffer<JCExpression> args = lb();
-        if (token.kind == LPAREN) {
-            nextToken();
-            if (token.kind != RPAREN) {
+        if (S.token() == LPAREN) {
+            S.nextToken();
+            if (S.token() != RPAREN) {
                 args.append(parseExpression());
-                while (token.kind == COMMA) {
-                    nextToken();
+                while (S.token() == COMMA) {
+                    S.nextToken();
                     args.append(parseExpression());
                 }
             }
             accept(RPAREN);
         } else {
-            syntaxError(token.pos, "expected", LPAREN);
+            syntaxError(S.pos(), "expected", LPAREN);
         }
         return args.toList();
     }
 
     JCMethodInvocation arguments(List<JCExpression> typeArgs, JCExpression t) {
-        int pos = token.pos;
+        int pos = S.pos();
         List<JCExpression> args = arguments();
         return toP(F.at(pos).Apply(typeArgs, t, args));
     }
@@ -1421,7 +1201,7 @@
     /**  TypeArgumentsOpt = [ TypeArguments ]
      */
     JCExpression typeArgumentsOpt(JCExpression t) {
-        if (token.kind == LT &&
+        if (S.token() == LT &&
             (mode & TYPE) != 0 &&
             (mode & NOPARAMS) == 0) {
             mode = TYPE;
@@ -1436,7 +1216,7 @@
     }
 
     List<JCExpression> typeArgumentsOpt(int useMode) {
-        if (token.kind == LT) {
+        if (S.token() == LT) {
             checkGenerics();
             if ((mode & useMode) == 0 ||
                 (mode & NOPARAMS) != 0) {
@@ -1451,37 +1231,45 @@
     /**  TypeArguments  = "<" TypeArgument {"," TypeArgument} ">"
      */
     List<JCExpression> typeArguments(boolean diamondAllowed) {
-        if (token.kind == LT) {
-            nextToken();
-            if (token.kind == GT && diamondAllowed) {
+        if (S.token() == LT) {
+            S.nextToken();
+            if (S.token() == GT && diamondAllowed) {
                 checkDiamond();
                 mode |= DIAMOND;
-                nextToken();
+                S.nextToken();
                 return List.nil();
             } else {
                 ListBuffer<JCExpression> args = ListBuffer.lb();
                 args.append(((mode & EXPR) == 0) ? typeArgument() : parseType());
-                while (token.kind == COMMA) {
-                    nextToken();
+                while (S.token() == COMMA) {
+                    S.nextToken();
                     args.append(((mode & EXPR) == 0) ? typeArgument() : parseType());
                 }
-                switch (token.kind) {
-
-                case GTGTGTEQ: case GTGTEQ: case GTEQ:
-                case GTGTGT: case GTGT:
-                    token = S.split();
+                switch (S.token()) {
+                case GTGTGTEQ:
+                    S.token(GTGTEQ);
+                    break;
+                case GTGTEQ:
+                    S.token(GTEQ);
                     break;
-                case GT:
-                    nextToken();
+                case GTEQ:
+                    S.token(EQ);
+                    break;
+                case GTGTGT:
+                    S.token(GTGT);
+                    break;
+                case GTGT:
+                    S.token(GT);
                     break;
                 default:
-                    args.append(syntaxError(token.pos, "expected", GT));
+                    accept(GT);
                     break;
                 }
                 return args.toList();
             }
         } else {
-            return List.<JCExpression>of(syntaxError(token.pos, "expected", LT));
+            syntaxError(S.pos(), "expected", LT);
+            return List.nil();
         }
     }
 
@@ -1491,27 +1279,27 @@
      *               | "?" SUPER Type
      */
     JCExpression typeArgument() {
-        if (token.kind != QUES) return parseType();
-        int pos = token.pos;
-        nextToken();
-        if (token.kind == EXTENDS) {
+        if (S.token() != QUES) return parseType();
+        int pos = S.pos();
+        S.nextToken();
+        if (S.token() == EXTENDS) {
             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
-            nextToken();
+            S.nextToken();
             JCExpression bound = parseType();
             return F.at(pos).Wildcard(t, bound);
-        } else if (token.kind == SUPER) {
+        } else if (S.token() == SUPER) {
             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
-            nextToken();
+            S.nextToken();
             JCExpression bound = parseType();
             return F.at(pos).Wildcard(t, bound);
-        } else if (token.kind == IDENTIFIER) {
+        } else if (S.token() == IDENTIFIER) {
             //error recovery
+            reportSyntaxError(S.prevEndPos(), "expected3",
+                    GT, EXTENDS, SUPER);
             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
-            JCIdent id = toP(F.at(token.pos).Ident(ident()));
-            JCErroneous err = F.at(pos).Erroneous(List.<JCTree>of(wc, id));
-            reportSyntaxError(err, "expected3", GT, EXTENDS, SUPER);
-            return err;
+            JCIdent id = toP(F.at(S.pos()).Ident(ident()));
+            return F.at(pos).Erroneous(List.<JCTree>of(wc, id));
         } else {
             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
             return toP(F.at(pos).Wildcard(t, null));
@@ -1519,7 +1307,7 @@
     }
 
     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
-        int pos = token.pos;
+        int pos = S.pos();
         List<JCExpression> args = typeArguments(diamondAllowed);
         return toP(F.at(pos).TypeApply(t, args));
     }
@@ -1527,9 +1315,9 @@
     /** BracketsOpt = {"[" "]"}
      */
     private JCExpression bracketsOpt(JCExpression t) {
-        if (token.kind == LBRACKET) {
-            int pos = token.pos;
-            nextToken();
+        if (S.token() == LBRACKET) {
+            int pos = S.pos();
+            S.nextToken();
             t = bracketsOptCont(t, pos);
             F.at(pos);
         }
@@ -1546,17 +1334,17 @@
      *  BracketsSuffixType =
      */
     JCExpression bracketsSuffix(JCExpression t) {
-        if ((mode & EXPR) != 0 && token.kind == DOT) {
+        if ((mode & EXPR) != 0 && S.token() == DOT) {
             mode = EXPR;
-            int pos = token.pos;
-            nextToken();
+            int pos = S.pos();
+            S.nextToken();
             accept(CLASS);
-            if (token.pos == endPosTable.errorEndPos) {
+            if (S.pos() == errorEndPos) {
                 // error recovery
                 Name name = null;
-                if (token.kind == IDENTIFIER) {
-                    name = token.name();
-                    nextToken();
+                if (S.token() == IDENTIFIER) {
+                    name = S.name();
+                    S.nextToken();
                 } else {
                     name = names.error;
                 }
@@ -1567,45 +1355,15 @@
         } else if ((mode & TYPE) != 0) {
             mode = TYPE;
         } else {
-            syntaxError(token.pos, "dot.class.expected");
+            syntaxError(S.pos(), "dot.class.expected");
         }
         return t;
     }
 
-    /**
-     * MemberReferenceSuffix = "#" [TypeArguments] Ident
-     *                       | "#" [TypeArguments] "new"
-     */
-    JCExpression memberReferenceSuffix(JCExpression t) {
-        int pos1 = token.pos;
-        accept(HASH);
-        return memberReferenceSuffix(pos1, t);
-    }
-
-    JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
-        checkMethodReferences();
-        mode = EXPR;
-        List<JCExpression> typeArgs = null;
-        if (token.kind == LT) {
-            typeArgs = typeArguments(false);
-        }
-        Name refName = null;
-        ReferenceMode refMode = null;
-        if (token.kind == NEW) {
-            refMode = ReferenceMode.NEW;
-            refName = names.init;
-            nextToken();
-        } else {
-            refMode = ReferenceMode.INVOKE;
-            refName = ident();
-        }
-        return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
-    }
-
     /** Creator = Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
      */
     JCExpression creator(int newpos, List<JCExpression> typeArgs) {
-        switch (token.kind) {
+        switch (S.token()) {
         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
         case DOUBLE: case BOOLEAN:
             if (typeArgs == null)
@@ -1617,36 +1375,29 @@
         int oldmode = mode;
         mode = TYPE;
         boolean diamondFound = false;
-        int lastTypeargsPos = -1;
-        if (token.kind == LT) {
+        if (S.token() == LT) {
             checkGenerics();
-            lastTypeargsPos = token.pos;
             t = typeArguments(t, true);
             diamondFound = (mode & DIAMOND) != 0;
         }
-        while (token.kind == DOT) {
+        while (S.token() == DOT) {
             if (diamondFound) {
                 //cannot select after a diamond
-                illegal();
+                illegal(S.pos());
             }
-            int pos = token.pos;
-            nextToken();
+            int pos = S.pos();
+            S.nextToken();
             t = toP(F.at(pos).Select(t, ident()));
-            if (token.kind == LT) {
-                lastTypeargsPos = token.pos;
+            if (S.token() == LT) {
                 checkGenerics();
                 t = typeArguments(t, true);
                 diamondFound = (mode & DIAMOND) != 0;
             }
         }
         mode = oldmode;
-        if (token.kind == LBRACKET) {
+        if (S.token() == LBRACKET) {
             JCExpression e = arrayCreatorRest(newpos, t);
-            if (diamondFound) {
-                reportSyntaxError(lastTypeargsPos, "cannot.create.array.with.diamond");
-                return toP(F.at(newpos).Erroneous(List.of(e)));
-            }
-            else if (typeArgs != null) {
+            if (typeArgs != null) {
                 int pos = newpos;
                 if (!typeArgs.isEmpty() && typeArgs.head.pos != Position.NOPOS) {
                     // note: this should always happen but we should
@@ -1654,17 +1405,16 @@
                     // modified to improve error recovery.
                     pos = typeArgs.head.pos;
                 }
-                setErrorEndPos(S.prevToken().endPos);
-                JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
-                reportSyntaxError(err, "cannot.create.array.with.type.arguments");
-                return toP(err);
+                setErrorEndPos(S.prevEndPos());
+                reportSyntaxError(pos, "cannot.create.array.with.type.arguments");
+                return toP(F.at(newpos).Erroneous(typeArgs.prepend(e)));
             }
             return e;
-        } else if (token.kind == LPAREN) {
+        } else if (S.token() == LPAREN) {
             return classCreatorRest(newpos, null, typeArgs, t);
         } else {
-            setErrorEndPos(token.pos);
-            reportSyntaxError(token.pos, "expected2", LPAREN, LBRACKET);
+            reportSyntaxError(S.pos(), "expected2",
+                               LPAREN, LBRACKET);
             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.<JCExpression>nil(), null));
             return toP(F.at(newpos).Erroneous(List.<JCTree>of(t)));
         }
@@ -1673,8 +1423,8 @@
     /** InnerCreator = Ident [TypeArguments] ClassCreatorRest
      */
     JCExpression innerCreator(int newpos, List<JCExpression> typeArgs, JCExpression encl) {
-        JCExpression t = toP(F.at(token.pos).Ident(ident()));
-        if (token.kind == LT) {
+        JCExpression t = toP(F.at(S.pos()).Ident(ident()));
+        if (S.token() == LT) {
             int oldmode = mode;
             checkGenerics();
             t = typeArguments(t, true);
@@ -1688,23 +1438,22 @@
      */
     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
         accept(LBRACKET);
-        if (token.kind == RBRACKET) {
+        if (S.token() == RBRACKET) {
             accept(RBRACKET);
             elemtype = bracketsOpt(elemtype);
-            if (token.kind == LBRACE) {
+            if (S.token() == LBRACE) {
                 return arrayInitializer(newpos, elemtype);
             } else {
-                JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.<JCExpression>nil(), null));
-                return syntaxError(token.pos, List.<JCTree>of(t), "array.dimension.missing");
+                return syntaxError(S.pos(), "array.dimension.missing");
             }
         } else {
             ListBuffer<JCExpression> dims = new ListBuffer<JCExpression>();
             dims.append(parseExpression());
             accept(RBRACKET);
-            while (token.kind == LBRACKET) {
-                int pos = token.pos;
-                nextToken();
-                if (token.kind == RBRACKET) {
+            while (S.token() == LBRACKET) {
+                int pos = S.pos();
+                S.nextToken();
+                if (S.token() == RBRACKET) {
                     elemtype = bracketsOptCont(elemtype, pos);
                 } else {
                     dims.append(parseExpression());
@@ -1724,8 +1473,8 @@
     {
         List<JCExpression> args = arguments();
         JCClassDecl body = null;
-        if (token.kind == LBRACE) {
-            int pos = token.pos;
+        if (S.token() == LBRACE) {
+            int pos = S.pos();
             List<JCTree> defs = classOrInterfaceBody(names.empty, false);
             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
@@ -1738,13 +1487,13 @@
     JCExpression arrayInitializer(int newpos, JCExpression t) {
         accept(LBRACE);
         ListBuffer<JCExpression> elems = new ListBuffer<JCExpression>();
-        if (token.kind == COMMA) {
-            nextToken();
-        } else if (token.kind != RBRACE) {
+        if (S.token() == COMMA) {
+            S.nextToken();
+        } else if (S.token() != RBRACE) {
             elems.append(variableInitializer());
-            while (token.kind == COMMA) {
-                nextToken();
-                if (token.kind == RBRACE) break;
+            while (S.token() == COMMA) {
+                S.nextToken();
+                if (S.token() == RBRACE) break;
                 elems.append(variableInitializer());
             }
         }
@@ -1755,17 +1504,16 @@
     /** VariableInitializer = ArrayInitializer | Expression
      */
     public JCExpression variableInitializer() {
-        return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
+        return S.token() == LBRACE ? arrayInitializer(S.pos(), null) : parseExpression();
     }
 
     /** ParExpression = "(" Expression ")"
      */
     JCExpression parExpression() {
-        int pos = token.pos;
         accept(LPAREN);
         JCExpression t = parseExpression();
         accept(RPAREN);
-        return toP(F.at(pos).Parens(t));
+        return t;
     }
 
     /** Block = "{" BlockStatements "}"
@@ -1774,19 +1522,19 @@
         accept(LBRACE);
         List<JCStatement> stats = blockStatements();
         JCBlock t = F.at(pos).Block(flags, stats);
-        while (token.kind == CASE || token.kind == DEFAULT) {
-            syntaxError("orphaned", token.kind);
+        while (S.token() == CASE || S.token() == DEFAULT) {
+            syntaxError("orphaned", S.token());
             switchBlockStatementGroups();
         }
         // the Block node has a field "endpos" for first char of last token, which is
         // usually but not necessarily the last char of the last token.
-        t.endpos = token.pos;
+        t.endpos = S.pos();
         accept(RBRACE);
         return toP(t);
     }
 
     public JCBlock block() {
-        return block(token.pos, 0);
+        return block(S.pos(), 0);
     }
 
     /** BlockStatements = { BlockStatement }
@@ -1798,127 +1546,97 @@
      */
     @SuppressWarnings("fallthrough")
     List<JCStatement> blockStatements() {
-        //todo: skip to anchor on error(?)
+//todo: skip to anchor on error(?)
+        int lastErrPos = -1;
         ListBuffer<JCStatement> stats = new ListBuffer<JCStatement>();
         while (true) {
-            List<JCStatement> stat = blockStatement();
-            if (stat.isEmpty()) {
+            int pos = S.pos();
+            switch (S.token()) {
+            case RBRACE: case CASE: case DEFAULT: case EOF:
                 return stats.toList();
-            } else {
-                if (token.pos <= endPosTable.errorEndPos) {
-                    skip(false, true, true, true);
+            case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
+            case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
+            case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
+                stats.append(parseStatement());
+                break;
+            case MONKEYS_AT:
+            case FINAL: {
+                String dc = S.docComment();
+                JCModifiers mods = modifiersOpt();
+                if (S.token() == INTERFACE ||
+                    S.token() == CLASS ||
+                    allowEnums && S.token() == ENUM) {
+                    stats.append(classOrInterfaceOrEnumDeclaration(mods, dc));
+                } else {
+                    JCExpression t = parseType();
+                    stats.appendList(variableDeclarators(mods, t,
+                                                         new ListBuffer<JCStatement>()));
+                    // A "LocalVariableDeclarationStatement" subsumes the terminating semicolon
+                    storeEnd(stats.elems.last(), S.endPos());
+                    accept(SEMI);
                 }
-                stats.addAll(stat);
-            }
-        }
-    }
-
-    /*
-     * This method parses a statement treating it as a block, relaxing the
-     * JLS restrictions, allows us to parse more faulty code, doing so
-     * enables us to provide better and accurate diagnostics to the user.
-     */
-    JCStatement parseStatementAsBlock() {
-        int pos = token.pos;
-        List<JCStatement> stats = blockStatement();
-        if (stats.isEmpty()) {
-            JCErroneous e = F.at(pos).Erroneous();
-            error(e, "illegal.start.of.stmt");
-            return F.at(pos).Exec(e);
-        } else {
-            JCStatement first = stats.head;
-            String error = null;
-            switch (first.getTag()) {
-            case CLASSDEF:
-                error = "class.not.allowed";
                 break;
-            case VARDEF:
-                error = "variable.not.allowed";
+            }
+            case ABSTRACT: case STRICTFP: {
+                String dc = S.docComment();
+                JCModifiers mods = modifiersOpt();
+                stats.append(classOrInterfaceOrEnumDeclaration(mods, dc));
                 break;
             }
-            if (error != null) {
-                error(first, error);
-                List<JCBlock> blist = List.of(F.at(first.pos).Block(0, stats));
-                return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
+            case INTERFACE:
+            case CLASS:
+                stats.append(classOrInterfaceOrEnumDeclaration(modifiersOpt(),
+                                                               S.docComment()));
+                break;
+            case ENUM:
+            case ASSERT:
+                if (allowEnums && S.token() == ENUM) {
+                    error(S.pos(), "local.enum");
+                    stats.
+                        append(classOrInterfaceOrEnumDeclaration(modifiersOpt(),
+                                                                 S.docComment()));
+                    break;
+                } else if (allowAsserts && S.token() == ASSERT) {
+                    stats.append(parseStatement());
+                    break;
+                }
+                /* fall through to default */
+            default:
+                Name name = S.name();
+                JCExpression t = term(EXPR | TYPE);
+                if (S.token() == COLON && t.getTag() == JCTree.IDENT) {
+                    S.nextToken();
+                    JCStatement stat = parseStatement();
+                    stats.append(F.at(pos).Labelled(name, stat));
+                } else if ((lastmode & TYPE) != 0 &&
+                           (S.token() == IDENTIFIER ||
+                            S.token() == ASSERT ||
+                            S.token() == ENUM)) {
+                    pos = S.pos();
+                    JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
+                    F.at(pos);
+                    stats.appendList(variableDeclarators(mods, t,
+                                                         new ListBuffer<JCStatement>()));
+                    // A "LocalVariableDeclarationStatement" subsumes the terminating semicolon
+                    storeEnd(stats.elems.last(), S.endPos());
+                    accept(SEMI);
+                } else {
+                    // This Exec is an "ExpressionStatement"; it subsumes the terminating semicolon
+                    stats.append(to(F.at(pos).Exec(checkExprStat(t))));
+                    accept(SEMI);
+                }
             }
-            return first;
-        }
-    }
 
-    @SuppressWarnings("fallthrough")
-    List<JCStatement> blockStatement() {
-        //todo: skip to anchor on error(?)
-        int pos = token.pos;
-        switch (token.kind) {
-        case RBRACE: case CASE: case DEFAULT: case EOF:
-            return List.nil();
-        case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
-        case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
-        case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
-            return List.of(parseStatement());
-        case MONKEYS_AT:
-        case FINAL: {
-            String dc = token.comment(CommentStyle.JAVADOC);
-            JCModifiers mods = modifiersOpt();
-            if (token.kind == INTERFACE ||
-                token.kind == CLASS ||
-                allowEnums && token.kind == ENUM) {
-                return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));
-            } else {
-                JCExpression t = parseType();
-                ListBuffer<JCStatement> stats =
-                        variableDeclarators(mods, t, new ListBuffer<JCStatement>());
-                // A "LocalVariableDeclarationStatement" subsumes the terminating semicolon
-                storeEnd(stats.elems.last(), token.endPos);
-                accept(SEMI);
-                return stats.toList();
-            }
-        }
-        case ABSTRACT: case STRICTFP: {
-            String dc = token.comment(CommentStyle.JAVADOC);
-            JCModifiers mods = modifiersOpt();
-            return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));
-        }
-        case INTERFACE:
-        case CLASS:
-            String dc = token.comment(CommentStyle.JAVADOC);
-            return List.of(classOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
-        case ENUM:
-        case ASSERT:
-            if (allowEnums && token.kind == ENUM) {
-                error(token.pos, "local.enum");
-                dc = token.comment(CommentStyle.JAVADOC);
-                return List.of(classOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
-            } else if (allowAsserts && token.kind == ASSERT) {
-                return List.of(parseStatement());
-            }
-            /* fall through to default */
-        default:
-            Token prevToken = token;
-            JCExpression t = term(EXPR | TYPE);
-            if (token.kind == COLON && t.hasTag(IDENT)) {
-                nextToken();
-                JCStatement stat = parseStatement();
-                return List.<JCStatement>of(F.at(pos).Labelled(prevToken.name(), stat));
-            } else if ((lastmode & TYPE) != 0 &&
-                       (token.kind == IDENTIFIER ||
-                        token.kind == ASSERT ||
-                        token.kind == ENUM)) {
-                pos = token.pos;
-                JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
-                F.at(pos);
-                ListBuffer<JCStatement> stats =
-                        variableDeclarators(mods, t, new ListBuffer<JCStatement>());
-                // A "LocalVariableDeclarationStatement" subsumes the terminating semicolon
-                storeEnd(stats.elems.last(), token.endPos);
-                accept(SEMI);
+            // error recovery
+            if (S.pos() == lastErrPos)
                 return stats.toList();
-            } else {
-                // This Exec is an "ExpressionStatement"; it subsumes the terminating semicolon
-                JCExpressionStatement expr = to(F.at(pos).Exec(checkExprStat(t)));
-                accept(SEMI);
-                return List.<JCStatement>of(expr);
+            if (S.pos() <= errorEndPos) {
+                skip(false, true, true, true);
+                lastErrPos = S.pos();
             }
+
+            // ensure no dangling /** @deprecated */ active
+            S.resetDeprecatedFlag();
         }
     }
 
@@ -1944,55 +1662,55 @@
      */
     @SuppressWarnings("fallthrough")
     public JCStatement parseStatement() {
-        int pos = token.pos;
-        switch (token.kind) {
+        int pos = S.pos();
+        switch (S.token()) {
         case LBRACE:
             return block();
         case IF: {
-            nextToken();
+            S.nextToken();
             JCExpression cond = parExpression();
-            JCStatement thenpart = parseStatementAsBlock();
+            JCStatement thenpart = parseStatement();
             JCStatement elsepart = null;
-            if (token.kind == ELSE) {
-                nextToken();
-                elsepart = parseStatementAsBlock();
+            if (S.token() == ELSE) {
+                S.nextToken();
+                elsepart = parseStatement();
             }
             return F.at(pos).If(cond, thenpart, elsepart);
         }
         case FOR: {
-            nextToken();
+            S.nextToken();
             accept(LPAREN);
-            List<JCStatement> inits = token.kind == SEMI ? List.<JCStatement>nil() : forInit();
+            List<JCStatement> inits = S.token() == SEMI ? List.<JCStatement>nil() : forInit();
             if (inits.length() == 1 &&
-                inits.head.hasTag(VARDEF) &&
+                inits.head.getTag() == JCTree.VARDEF &&
                 ((JCVariableDecl) inits.head).init == null &&
-                token.kind == COLON) {
+                S.token() == COLON) {
                 checkForeach();
                 JCVariableDecl var = (JCVariableDecl)inits.head;
                 accept(COLON);
                 JCExpression expr = parseExpression();
                 accept(RPAREN);
-                JCStatement body = parseStatementAsBlock();
+                JCStatement body = parseStatement();
                 return F.at(pos).ForeachLoop(var, expr, body);
             } else {
                 accept(SEMI);
-                JCExpression cond = token.kind == SEMI ? null : parseExpression();
+                JCExpression cond = S.token() == SEMI ? null : parseExpression();
                 accept(SEMI);
-                List<JCExpressionStatement> steps = token.kind == RPAREN ? List.<JCExpressionStatement>nil() : forUpdate();
+                List<JCExpressionStatement> steps = S.token() == RPAREN ? List.<JCExpressionStatement>nil() : forUpdate();
                 accept(RPAREN);
-                JCStatement body = parseStatementAsBlock();
+                JCStatement body = parseStatement();
                 return F.at(pos).ForLoop(inits, cond, steps, body);
             }
         }
         case WHILE: {
-            nextToken();
+            S.nextToken();
             JCExpression cond = parExpression();
-            JCStatement body = parseStatementAsBlock();
+            JCStatement body = parseStatement();
             return F.at(pos).WhileLoop(cond, body);
         }
         case DO: {
-            nextToken();
-            JCStatement body = parseStatementAsBlock();
+            S.nextToken();
+            JCStatement body = parseStatement();
             accept(WHILE);
             JCExpression cond = parExpression();
             JCDoWhileLoop t = to(F.at(pos).DoLoop(body, cond));
@@ -2000,21 +1718,21 @@
             return t;
         }
         case TRY: {
-            nextToken();
+            S.nextToken();
             List<JCTree> resources = List.<JCTree>nil();
-            if (token.kind == LPAREN) {
+            if (S.token() == LPAREN) {
                 checkTryWithResources();
-                nextToken();
+                S.nextToken();
                 resources = resources();
                 accept(RPAREN);
             }
             JCBlock body = block();
             ListBuffer<JCCatch> catchers = new ListBuffer<JCCatch>();
             JCBlock finalizer = null;
-            if (token.kind == CATCH || token.kind == FINALLY) {
-                while (token.kind == CATCH) catchers.append(catchClause());
-                if (token.kind == FINALLY) {
-                    nextToken();
+            if (S.token() == CATCH || S.token() == FINALLY) {
+                while (S.token() == CATCH) catchers.append(catchClause());
+                if (S.token() == FINALLY) {
+                    S.nextToken();
                     finalizer = block();
                 }
             } else {
@@ -2027,7 +1745,7 @@
             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
         }
         case SWITCH: {
-            nextToken();
+            S.nextToken();
             JCExpression selector = parExpression();
             accept(LBRACE);
             List<JCCase> cases = switchBlockStatementGroups();
@@ -2036,41 +1754,41 @@
             return t;
         }
         case SYNCHRONIZED: {
-            nextToken();
+            S.nextToken();
             JCExpression lock = parExpression();
             JCBlock body = block();
             return F.at(pos).Synchronized(lock, body);
         }
         case RETURN: {
-            nextToken();
-            JCExpression result = token.kind == SEMI ? null : parseExpression();
+            S.nextToken();
+            JCExpression result = S.token() == SEMI ? null : parseExpression();
             JCReturn t = to(F.at(pos).Return(result));
             accept(SEMI);
             return t;
         }
         case THROW: {
-            nextToken();
+            S.nextToken();
             JCExpression exc = parseExpression();
             JCThrow t = to(F.at(pos).Throw(exc));
             accept(SEMI);
             return t;
         }
         case BREAK: {
-            nextToken();
-            Name label = (token.kind == IDENTIFIER || token.kind == ASSERT || token.kind == ENUM) ? ident() : null;
+            S.nextToken();
+            Name label = (S.token() == IDENTIFIER || S.token() == ASSERT || S.token() == ENUM) ? ident() : null;
             JCBreak t = to(F.at(pos).Break(label));
             accept(SEMI);
             return t;
         }
         case CONTINUE: {
-            nextToken();
-            Name label = (token.kind == IDENTIFIER || token.kind == ASSERT || token.kind == ENUM) ? ident() : null;
+            S.nextToken();
+            Name label = (S.token() == IDENTIFIER || S.token() == ASSERT || S.token() == ENUM) ? ident() : null;
             JCContinue t =  to(F.at(pos).Continue(label));
             accept(SEMI);
             return t;
         }
         case SEMI:
-            nextToken();
+            S.nextToken();
             return toP(F.at(pos).Skip());
         case ELSE:
             return toP(F.Exec(syntaxError("else.without.if")));
@@ -2079,12 +1797,12 @@
         case CATCH:
             return toP(F.Exec(syntaxError("catch.without.try")));
         case ASSERT: {
-            if (allowAsserts && token.kind == ASSERT) {
-                nextToken();
+            if (allowAsserts && S.token() == ASSERT) {
+                S.nextToken();
                 JCExpression assertion = parseExpression();
                 JCExpression message = null;
-                if (token.kind == COLON) {
-                    nextToken();
+                if (S.token() == COLON) {
+                    S.nextToken();
                     message = parseExpression();
                 }
                 JCAssert t = to(F.at(pos).Assert(assertion, message));
@@ -2095,12 +1813,12 @@
         }
         case ENUM:
         default:
-            Token prevToken = token;
+            Name name = S.name();
             JCExpression expr = parseExpression();
-            if (token.kind == COLON && expr.hasTag(IDENT)) {
-                nextToken();
+            if (S.token() == COLON && expr.getTag() == JCTree.IDENT) {
+                S.nextToken();
                 JCStatement stat = parseStatement();
-                return F.at(pos).Labelled(prevToken.name(), stat);
+                return F.at(pos).Labelled(name, stat);
             } else {
                 // This Exec is an "ExpressionStatement"; it subsumes the terminating semicolon
                 JCExpressionStatement stat = to(F.at(pos).Exec(checkExprStat(expr)));
@@ -2112,8 +1830,8 @@
 
     /** CatchClause     = CATCH "(" FormalParameter ")" Block
      */
-    protected JCCatch catchClause() {
-        int pos = token.pos;
+    JCCatch catchClause() {
+        int pos = S.pos();
         accept(CATCH);
         accept(LPAREN);
         JCModifiers mods = optFinal(Flags.PARAMETER);
@@ -2130,9 +1848,9 @@
     List<JCExpression> catchTypes() {
         ListBuffer<JCExpression> catchTypes = ListBuffer.lb();
         catchTypes.add(parseType());
-        while (token.kind == BAR) {
+        while (S.token() == BAR) {
             checkMulticatch();
-            nextToken();
+            S.nextToken();
             catchTypes.add(qualident());
         }
         return catchTypes.toList();
@@ -2145,33 +1863,33 @@
     List<JCCase> switchBlockStatementGroups() {
         ListBuffer<JCCase> cases = new ListBuffer<JCCase>();
         while (true) {
-            int pos = token.pos;
-            switch (token.kind) {
+            int pos = S.pos();
+            switch (S.token()) {
             case CASE: {
-                nextToken();
+                S.nextToken();
                 JCExpression pat = parseExpression();
                 accept(COLON);
                 List<JCStatement> stats = blockStatements();
                 JCCase c = F.at(pos).Case(pat, stats);
                 if (stats.isEmpty())
-                    storeEnd(c, S.prevToken().endPos);
+                    storeEnd(c, S.prevEndPos());
                 cases.append(c);
                 break;
             }
             case DEFAULT: {
-                nextToken();
+                S.nextToken();
                 accept(COLON);
                 List<JCStatement> stats = blockStatements();
                 JCCase c = F.at(pos).Case(null, stats);
                 if (stats.isEmpty())
-                    storeEnd(c, S.prevToken().endPos);
+                    storeEnd(c, S.prevEndPos());
                 cases.append(c);
                 break;
             }
             case RBRACE: case EOF:
                 return cases.toList();
             default:
-                nextToken(); // to ensure progress
+                S.nextToken(); // to ensure progress
                 syntaxError(pos, "expected3",
                     CASE, DEFAULT, RBRACE);
             }
@@ -2185,9 +1903,9 @@
                                                                     T stats) {
         // This Exec is a "StatementExpression"; it subsumes no terminating token
         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
-        while (token.kind == COMMA) {
-            nextToken();
-            pos = token.pos;
+        while (S.token() == COMMA) {
+            S.nextToken();
+            pos = S.pos();
             JCExpression t = parseExpression();
             // This Exec is a "StatementExpression"; it subsumes no terminating token
             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
@@ -2200,13 +1918,13 @@
      */
     List<JCStatement> forInit() {
         ListBuffer<JCStatement> stats = lb();
-        int pos = token.pos;
-        if (token.kind == FINAL || token.kind == MONKEYS_AT) {
+        int pos = S.pos();
+        if (S.token() == FINAL || S.token() == MONKEYS_AT) {
             return variableDeclarators(optFinal(0), parseType(), stats).toList();
         } else {
             JCExpression t = term(EXPR | TYPE);
             if ((lastmode & TYPE) != 0 &&
-                (token.kind == IDENTIFIER || token.kind == ASSERT || token.kind == ENUM))
+                (S.token() == IDENTIFIER || S.token() == ASSERT || S.token() == ENUM))
                 return variableDeclarators(modifiersOpt(), t, stats).toList();
             else
                 return moreStatementExpressions(pos, t, stats).toList();
@@ -2216,7 +1934,7 @@
     /** ForUpdate = StatementExpression MoreStatementExpressions
      */
     List<JCExpressionStatement> forUpdate() {
-        return moreStatementExpressions(token.pos,
+        return moreStatementExpressions(S.pos(),
                                         parseExpression(),
                                         new ListBuffer<JCExpressionStatement>()).toList();
     }
@@ -2224,11 +1942,11 @@
     /** AnnotationsOpt = { '@' Annotation }
      */
     List<JCAnnotation> annotationsOpt() {
-        if (token.kind != MONKEYS_AT) return List.nil(); // optimization
+        if (S.token() != MONKEYS_AT) return List.nil(); // optimization
         ListBuffer<JCAnnotation> buf = new ListBuffer<JCAnnotation>();
-        while (token.kind == MONKEYS_AT) {
-            int pos = token.pos;
-            nextToken();
+        while (S.token() == MONKEYS_AT) {
+            int pos = S.pos();
+            S.nextToken();
             buf.append(annotation(pos));
         }
         return buf.toList();
@@ -2242,26 +1960,27 @@
     JCModifiers modifiersOpt() {
         return modifiersOpt(null);
     }
-    protected JCModifiers modifiersOpt(JCModifiers partial) {
+    JCModifiers modifiersOpt(JCModifiers partial) {
         long flags;
         ListBuffer<JCAnnotation> annotations = new ListBuffer<JCAnnotation>();
         int pos;
         if (partial == null) {
             flags = 0;
-            pos = token.pos;
+            pos = S.pos();
         } else {
             flags = partial.flags;
             annotations.appendList(partial.annotations);
             pos = partial.pos;
         }
-        if (token.deprecatedFlag()) {
+        if (S.deprecatedFlag()) {
             flags |= Flags.DEPRECATED;
+            S.resetDeprecatedFlag();
         }
         int lastPos = Position.NOPOS;
     loop:
         while (true) {
             long flag;
-            switch (token.kind) {
+            switch (S.token()) {
             case PRIVATE     : flag = Flags.PRIVATE; break;
             case PROTECTED   : flag = Flags.PROTECTED; break;
             case PUBLIC      : flag = Flags.PUBLIC; break;
@@ -2274,15 +1993,14 @@
             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
             case STRICTFP    : flag = Flags.STRICTFP; break;
             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
-            case ERROR       : flag = 0; nextToken(); break;
             default: break loop;
             }
-            if ((flags & flag) != 0) error(token.pos, "repeated.modifier");
-            lastPos = token.pos;
-            nextToken();
+            if ((flags & flag) != 0) error(S.pos(), "repeated.modifier");
+            lastPos = S.pos();
+            S.nextToken();
             if (flag == Flags.ANNOTATION) {
                 checkAnnotations();
-                if (token.kind != INTERFACE) {
+                if (S.token() != INTERFACE) {
                     JCAnnotation ann = annotation(lastPos);
                     // if first modifier is an annotation, set pos to annotation's.
                     if (flags == 0 && annotations.isEmpty())
@@ -2294,7 +2012,7 @@
             }
             flags |= flag;
         }
-        switch (token.kind) {
+        switch (S.token()) {
         case ENUM: flags |= Flags.ENUM; break;
         case INTERFACE: flags |= Flags.INTERFACE; break;
         default: break;
@@ -2307,7 +2025,7 @@
 
         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
         if (pos != Position.NOPOS)
-            storeEnd(mods, S.prevToken().endPos);
+            storeEnd(mods, S.prevEndPos());
         return mods;
     }
 
@@ -2320,22 +2038,22 @@
         JCTree ident = qualident();
         List<JCExpression> fieldValues = annotationFieldValuesOpt();
         JCAnnotation ann = F.at(pos).Annotation(ident, fieldValues);
-        storeEnd(ann, S.prevToken().endPos);
+        storeEnd(ann, S.prevEndPos());
         return ann;
     }
 
     List<JCExpression> annotationFieldValuesOpt() {
-        return (token.kind == LPAREN) ? annotationFieldValues() : List.<JCExpression>nil();
+        return (S.token() == LPAREN) ? annotationFieldValues() : List.<JCExpression>nil();
     }
 
     /** AnnotationFieldValues   = "(" [ AnnotationFieldValue { "," AnnotationFieldValue } ] ")" */
     List<JCExpression> annotationFieldValues() {
         accept(LPAREN);
         ListBuffer<JCExpression> buf = new ListBuffer<JCExpression>();
-        if (token.kind != RPAREN) {
+        if (S.token() != RPAREN) {
             buf.append(annotationFieldValue());
-            while (token.kind == COMMA) {
-                nextToken();
+            while (S.token() == COMMA) {
+                S.nextToken();
                 buf.append(annotationFieldValue());
             }
         }
@@ -2347,11 +2065,11 @@
      *                          | Identifier "=" AnnotationValue
      */
     JCExpression annotationFieldValue() {
-        if (token.kind == IDENTIFIER) {
+        if (S.token() == IDENTIFIER) {
             mode = EXPR;
             JCExpression t1 = term1();
-            if (t1.hasTag(IDENT) && token.kind == EQ) {
-                int pos = token.pos;
+            if (t1.getTag() == JCTree.IDENT && S.token() == EQ) {
+                int pos = S.pos();
                 accept(EQ);
                 JCExpression v = annotationValue();
                 return toP(F.at(pos).Assign(t1, v));
@@ -2368,20 +2086,20 @@
      */
     JCExpression annotationValue() {
         int pos;
-        switch (token.kind) {
+        switch (S.token()) {
         case MONKEYS_AT:
-            pos = token.pos;
-            nextToken();
+            pos = S.pos();
+            S.nextToken();
             return annotation(pos);
         case LBRACE:
-            pos = token.pos;
+            pos = S.pos();
             accept(LBRACE);
             ListBuffer<JCExpression> buf = new ListBuffer<JCExpression>();
-            if (token.kind != RBRACE) {
+            if (S.token() != RBRACE) {
                 buf.append(annotationValue());
-                while (token.kind == COMMA) {
-                    nextToken();
-                    if (token.kind == RBRACE) break;
+                while (S.token() == COMMA) {
+                    S.nextToken();
+                    if (S.token() == RBRACE) break;
                     buf.append(annotationValue());
                 }
             }
@@ -2399,7 +2117,7 @@
                                                                          JCExpression type,
                                                                          T vdefs)
     {
-        return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs);
+        return variableDeclaratorsRest(S.pos(), mods, type, ident(), false, null, vdefs);
     }
 
     /** VariableDeclaratorsRest = VariableDeclaratorRest { "," VariableDeclarator }
@@ -2417,10 +2135,10 @@
                                                                      T vdefs)
     {
         vdefs.append(variableDeclaratorRest(pos, mods, type, name, reqInit, dc));
-        while (token.kind == COMMA) {
+        while (S.token() == COMMA) {
             // All but last of multiple declarators subsume a comma
-            storeEnd((JCTree)vdefs.elems.last(), token.endPos);
-            nextToken();
+            storeEnd((JCTree)vdefs.elems.last(), S.endPos());
+            S.nextToken();
             vdefs.append(variableDeclarator(mods, type, reqInit, dc));
         }
         return vdefs;
@@ -2430,7 +2148,7 @@
      *  ConstantDeclarator = Ident ConstantDeclaratorRest
      */
     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, String dc) {
-        return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc);
+        return variableDeclaratorRest(S.pos(), mods, type, ident(), reqInit, dc);
     }
 
     /** VariableDeclaratorRest = BracketsOpt ["=" VariableInitializer]
@@ -2443,11 +2161,11 @@
                                   boolean reqInit, String dc) {
         type = bracketsOpt(type);
         JCExpression init = null;
-        if (token.kind == EQ) {
-            nextToken();
+        if (S.token() == EQ) {
+            S.nextToken();
             init = variableInitializer();
         }
-        else if (reqInit) syntaxError(token.pos, "expected", EQ);
+        else if (reqInit) syntaxError(S.pos(), "expected", EQ);
         JCVariableDecl result =
             toP(F.at(pos).VarDef(mods, name, type, init));
         attach(result, dc);
@@ -2457,11 +2175,11 @@
     /** VariableDeclaratorId = Ident BracketsOpt
      */
     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
-        int pos = token.pos;
+        int pos = S.pos();
         Name name = ident();
         if ((mods.flags & Flags.VARARGS) != 0 &&
-                token.kind == LBRACKET) {
-            log.error(token.pos, "varargs.and.old.array.syntax");
+                S.token() == LBRACKET) {
+            log.error(S.pos(), "varargs.and.old.array.syntax");
         }
         type = bracketsOpt(type);
         return toP(F.at(pos).VarDef(mods, name, type, null));
@@ -2472,12 +2190,12 @@
     List<JCTree> resources() {
         ListBuffer<JCTree> defs = new ListBuffer<JCTree>();
         defs.append(resource());
-        while (token.kind == SEMI) {
+        while (S.token() == SEMI) {
             // All but last of multiple declarators must subsume a semicolon
-            storeEnd(defs.elems.last(), token.endPos);
-            int semiColonPos = token.pos;
-            nextToken();
-            if (token.kind == RPAREN) { // Optional trailing semicolon
+            storeEnd(defs.elems.last(), S.endPos());
+            int semiColonPos = S.pos();
+            S.nextToken();
+            if (S.token() == RPAREN) { // Optional trailing semicolon
                                        // after last resource
                 break;
             }
@@ -2488,103 +2206,92 @@
 
     /** Resource = VariableModifiersOpt Type VariableDeclaratorId = Expression
      */
-    protected JCTree resource() {
-        JCModifiers optFinal = optFinal(Flags.FINAL);
-        JCExpression type = parseType();
-        int pos = token.pos;
-        Name ident = ident();
-        return variableDeclaratorRest(pos, optFinal, type, ident, true, null);
+    JCTree resource() {
+        return variableDeclaratorRest(S.pos(), optFinal(Flags.FINAL),
+                                      parseType(), ident(), true, null);
     }
 
     /** CompilationUnit = [ { "@" Annotation } PACKAGE Qualident ";"] {ImportDeclaration} {TypeDeclaration}
      */
     public JCTree.JCCompilationUnit parseCompilationUnit() {
-        Token firstToken = token;
+        int pos = S.pos();
         JCExpression pid = null;
+        String dc = S.docComment();
         JCModifiers mods = null;
-        boolean consumedToplevelDoc = false;
-        boolean seenImport = false;
-        boolean seenPackage = false;
         List<JCAnnotation> packageAnnotations = List.nil();
-        if (token.kind == MONKEYS_AT)
+        if (S.token() == MONKEYS_AT)
             mods = modifiersOpt();
 
-        if (token.kind == PACKAGE) {
-            seenPackage = true;
+        if (S.token() == PACKAGE) {
             if (mods != null) {
                 checkNoMods(mods.flags);
                 packageAnnotations = mods.annotations;
                 mods = null;
             }
-            nextToken();
+            S.nextToken();
             pid = qualident();
             accept(SEMI);
         }
         ListBuffer<JCTree> defs = new ListBuffer<JCTree>();
         boolean checkForImports = true;
-        boolean firstTypeDecl = true;
-        while (token.kind != EOF) {
-            if (token.pos <= endPosTable.errorEndPos) {
+        while (S.token() != EOF) {
+            if (S.pos() <= errorEndPos) {
                 // error recovery
                 skip(checkForImports, false, false, false);
-                if (token.kind == EOF)
+                if (S.token() == EOF)
                     break;
             }
-            if (checkForImports && mods == null && token.kind == IMPORT) {
-                seenImport = true;
+            if (checkForImports && mods == null && S.token() == IMPORT) {
                 defs.append(importDeclaration());
             } else {
-                String docComment = token.comment(CommentStyle.JAVADOC);
-                if (firstTypeDecl && !seenImport && !seenPackage) {
-                    docComment = firstToken.comment(CommentStyle.JAVADOC);
-                    consumedToplevelDoc = true;
+                JCTree def = typeDeclaration(mods);
+                if (keepDocComments && dc != null && docComments.get(def) == dc) {
+                    // If the first type declaration has consumed the first doc
+                    // comment, then don't use it for the top level comment as well.
+                    dc = null;
                 }
-                JCTree def = typeDeclaration(mods, docComment);
                 if (def instanceof JCExpressionStatement)
                     def = ((JCExpressionStatement)def).expr;
                 defs.append(def);
                 if (def instanceof JCClassDecl)
                     checkForImports = false;
                 mods = null;
-                firstTypeDecl = false;
             }
         }
-        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(packageAnnotations, pid, defs.toList());
-        if (!consumedToplevelDoc)
-            attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
+        JCTree.JCCompilationUnit toplevel = F.at(pos).TopLevel(packageAnnotations, pid, defs.toList());
+        attach(toplevel, dc);
         if (defs.elems.isEmpty())
-            storeEnd(toplevel, S.prevToken().endPos);
+            storeEnd(toplevel, S.prevEndPos());
         if (keepDocComments)
             toplevel.docComments = docComments;
         if (keepLineMap)
             toplevel.lineMap = S.getLineMap();
-        toplevel.endPositions = this.endPosTable;
         return toplevel;
     }
 
     /** ImportDeclaration = IMPORT [ STATIC ] Ident { "." Ident } [ "." "*" ] ";"
      */
     JCTree importDeclaration() {
-        int pos = token.pos;
-        nextToken();
+        int pos = S.pos();
+        S.nextToken();
         boolean importStatic = false;
-        if (token.kind == STATIC) {
+        if (S.token() == STATIC) {
             checkStaticImports();
             importStatic = true;
-            nextToken();
+            S.nextToken();
         }
-        JCExpression pid = toP(F.at(token.pos).Ident(ident()));
+        JCExpression pid = toP(F.at(S.pos()).Ident(ident()));
         do {
-            int pos1 = token.pos;
+            int pos1 = S.pos();
             accept(DOT);
-            if (token.kind == STAR) {
+            if (S.token() == STAR) {
                 pid = to(F.at(pos1).Select(pid, names.asterisk));
-                nextToken();
+                S.nextToken();
                 break;
             } else {
                 pid = toP(F.at(pos1).Select(pid, ident()));
             }
-        } while (token.kind == DOT);
+        } while (S.token() == DOT);
         accept(SEMI);
         return toP(F.at(pos).Import(pid, importStatic));
     }
@@ -2592,13 +2299,14 @@
     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
      *                  | ";"
      */
-    JCTree typeDeclaration(JCModifiers mods, String docComment) {
-        int pos = token.pos;
-        if (mods == null && token.kind == SEMI) {
-            nextToken();
+    JCTree typeDeclaration(JCModifiers mods) {
+        int pos = S.pos();
+        if (mods == null && S.token() == SEMI) {
+            S.nextToken();
             return toP(F.at(pos).Skip());
         } else {
-            return classOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
+            String dc = S.docComment();
+            return classOrInterfaceOrEnumDeclaration(modifiersOpt(mods), dc);
         }
     }
 
@@ -2608,19 +2316,19 @@
      *  @param dc       The documentation comment for the class, or null.
      */
     JCStatement classOrInterfaceOrEnumDeclaration(JCModifiers mods, String dc) {
-        if (token.kind == CLASS) {
+        if (S.token() == CLASS) {
             return classDeclaration(mods, dc);
-        } else if (token.kind == INTERFACE) {
+        } else if (S.token() == INTERFACE) {
             return interfaceDeclaration(mods, dc);
         } else if (allowEnums) {
-            if (token.kind == ENUM) {
+            if (S.token() == ENUM) {
                 return enumDeclaration(mods, dc);
             } else {
-                int pos = token.pos;
+                int pos = S.pos();
                 List<JCTree> errs;
-                if (token.kind == IDENTIFIER) {
+                if (S.token() == IDENTIFIER) {
                     errs = List.<JCTree>of(mods, toP(F.at(pos).Ident(ident())));
-                    setErrorEndPos(token.pos);
+                    setErrorEndPos(S.pos());
                 } else {
                     errs = List.<JCTree>of(mods);
                 }
@@ -2628,16 +2336,16 @@
                                               CLASS, INTERFACE, ENUM)));
             }
         } else {
-            if (token.kind == ENUM) {
-                error(token.pos, "enums.not.supported.in.source", source.name);
+            if (S.token() == ENUM) {
+                error(S.pos(), "enums.not.supported.in.source", source.name);
                 allowEnums = true;
                 return enumDeclaration(mods, dc);
             }
-            int pos = token.pos;
+            int pos = S.pos();
             List<JCTree> errs;
-            if (token.kind == IDENTIFIER) {
+            if (S.token() == IDENTIFIER) {
                 errs = List.<JCTree>of(mods, toP(F.at(pos).Ident(ident())));
-                setErrorEndPos(token.pos);
+                setErrorEndPos(S.pos());
             } else {
                 errs = List.<JCTree>of(mods);
             }
@@ -2651,21 +2359,21 @@
      *  @param mods    The modifiers starting the class declaration
      *  @param dc       The documentation comment for the class, or null.
      */
-    protected JCClassDecl classDeclaration(JCModifiers mods, String dc) {
-        int pos = token.pos;
+    JCClassDecl classDeclaration(JCModifiers mods, String dc) {
+        int pos = S.pos();
         accept(CLASS);
         Name name = ident();
 
         List<JCTypeParameter> typarams = typeParametersOpt();
 
         JCExpression extending = null;
-        if (token.kind == EXTENDS) {
-            nextToken();
+        if (S.token() == EXTENDS) {
+            S.nextToken();
             extending = parseType();
         }
         List<JCExpression> implementing = List.nil();
-        if (token.kind == IMPLEMENTS) {
-            nextToken();
+        if (S.token() == IMPLEMENTS) {
+            S.nextToken();
             implementing = typeList();
         }
         List<JCTree> defs = classOrInterfaceBody(name, false);
@@ -2680,16 +2388,16 @@
      *  @param mods    The modifiers starting the interface declaration
      *  @param dc       The documentation comment for the interface, or null.
      */
-    protected JCClassDecl interfaceDeclaration(JCModifiers mods, String dc) {
-        int pos = token.pos;
+    JCClassDecl interfaceDeclaration(JCModifiers mods, String dc) {
+        int pos = S.pos();
         accept(INTERFACE);
         Name name = ident();
 
         List<JCTypeParameter> typarams = typeParametersOpt();
 
         List<JCExpression> extending = List.nil();
-        if (token.kind == EXTENDS) {
-            nextToken();
+        if (S.token() == EXTENDS) {
+            S.nextToken();
             extending = typeList();
         }
         List<JCTree> defs = classOrInterfaceBody(name, true);
@@ -2703,14 +2411,14 @@
      *  @param mods    The modifiers starting the enum declaration
      *  @param dc       The documentation comment for the enum, or null.
      */
-    protected JCClassDecl enumDeclaration(JCModifiers mods, String dc) {
-        int pos = token.pos;
+    JCClassDecl enumDeclaration(JCModifiers mods, String dc) {
+        int pos = S.pos();
         accept(ENUM);
         Name name = ident();
 
         List<JCExpression> implementing = List.nil();
-        if (token.kind == IMPLEMENTS) {
-            nextToken();
+        if (S.token() == IMPLEMENTS) {
+            S.nextToken();
             implementing = typeList();
         }
 
@@ -2729,27 +2437,27 @@
     List<JCTree> enumBody(Name enumName) {
         accept(LBRACE);
         ListBuffer<JCTree> defs = new ListBuffer<JCTree>();
-        if (token.kind == COMMA) {
-            nextToken();
-        } else if (token.kind != RBRACE && token.kind != SEMI) {
+        if (S.token() == COMMA) {
+            S.nextToken();
+        } else if (S.token() != RBRACE && S.token() != SEMI) {
             defs.append(enumeratorDeclaration(enumName));
-            while (token.kind == COMMA) {
-                nextToken();
-                if (token.kind == RBRACE || token.kind == SEMI) break;
+            while (S.token() == COMMA) {
+                S.nextToken();
+                if (S.token() == RBRACE || S.token() == SEMI) break;
                 defs.append(enumeratorDeclaration(enumName));
             }
-            if (token.kind != SEMI && token.kind != RBRACE) {
-                defs.append(syntaxError(token.pos, "expected3",
+            if (S.token() != SEMI && S.token() != RBRACE) {
+                defs.append(syntaxError(S.pos(), "expected3",
                                 COMMA, RBRACE, SEMI));
-                nextToken();
+                S.nextToken();
             }
         }
-        if (token.kind == SEMI) {
-            nextToken();
-            while (token.kind != RBRACE && token.kind != EOF) {
+        if (S.token() == SEMI) {
+            S.nextToken();
+            while (S.token() != RBRACE && S.token() != EOF) {
                 defs.appendList(classOrInterfaceBodyDeclaration(enumName,
                                                                 false));
-                if (token.pos <= endPosTable.errorEndPos) {
+                if (S.pos() <= errorEndPos) {
                     // error recovery
                    skip(false, true, true, false);
                 }
@@ -2762,22 +2470,23 @@
     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ "{" ClassBody "}" ]
      */
     JCTree enumeratorDeclaration(Name enumName) {
-        String dc = token.comment(CommentStyle.JAVADOC);
+        String dc = S.docComment();
         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
-        if (token.deprecatedFlag()) {
+        if (S.deprecatedFlag()) {
             flags |= Flags.DEPRECATED;
+            S.resetDeprecatedFlag();
         }
-        int pos = token.pos;
+        int pos = S.pos();
         List<JCAnnotation> annotations = annotationsOpt();
         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
         List<JCExpression> typeArgs = typeArgumentsOpt();
-        int identPos = token.pos;
+        int identPos = S.pos();
         Name name = ident();
-        int createPos = token.pos;
-        List<JCExpression> args = (token.kind == LPAREN)
+        int createPos = S.pos();
+        List<JCExpression> args = (S.token() == LPAREN)
             ? arguments() : List.<JCExpression>nil();
         JCClassDecl body = null;
-        if (token.kind == LBRACE) {
+        if (S.token() == LBRACE) {
             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM | Flags.STATIC);
             List<JCTree> defs = classOrInterfaceBody(names.empty, false);
             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
@@ -2787,7 +2496,7 @@
         JCIdent ident = F.at(identPos).Ident(enumName);
         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
         if (createPos != identPos)
-            storeEnd(create, S.prevToken().endPos);
+            storeEnd(create, S.prevEndPos());
         ident = F.at(identPos).Ident(enumName);
         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
         attach(result, dc);
@@ -2799,8 +2508,8 @@
     List<JCExpression> typeList() {
         ListBuffer<JCExpression> ts = new ListBuffer<JCExpression>();
         ts.append(parseType());
-        while (token.kind == COMMA) {
-            nextToken();
+        while (S.token() == COMMA) {
+            S.nextToken();
             ts.append(parseType());
         }
         return ts.toList();
@@ -2811,16 +2520,16 @@
      */
     List<JCTree> classOrInterfaceBody(Name className, boolean isInterface) {
         accept(LBRACE);
-        if (token.pos <= endPosTable.errorEndPos) {
+        if (S.pos() <= errorEndPos) {
             // error recovery
             skip(false, true, false, false);
-            if (token.kind == LBRACE)
-                nextToken();
+            if (S.token() == LBRACE)
+                S.nextToken();
         }
         ListBuffer<JCTree> defs = new ListBuffer<JCTree>();
-        while (token.kind != RBRACE && token.kind != EOF) {
+        while (S.token() != RBRACE && S.token() != EOF) {
             defs.appendList(classOrInterfaceBodyDeclaration(className, isInterface));
-            if (token.pos <= endPosTable.errorEndPos) {
+            if (S.pos() <= errorEndPos) {
                // error recovery
                skip(false, true, true, false);
            }
@@ -2846,24 +2555,24 @@
      *    | ModifiersOpt Type Ident
      *      ( ConstantDeclaratorsRest | InterfaceMethodDeclaratorRest ";" )
      */
-    protected List<JCTree> classOrInterfaceBodyDeclaration(Name className, boolean isInterface) {
-        if (token.kind == SEMI) {
-            nextToken();
+    List<JCTree> classOrInterfaceBodyDeclaration(Name className, boolean isInterface) {
+        if (S.token() == SEMI) {
+            S.nextToken();
             return List.<JCTree>nil();
         } else {
-            String dc = token.comment(CommentStyle.JAVADOC);
-            int pos = token.pos;
+            String dc = S.docComment();
+            int pos = S.pos();
             JCModifiers mods = modifiersOpt();
-            if (token.kind == CLASS ||
-                token.kind == INTERFACE ||
-                allowEnums && token.kind == ENUM) {
+            if (S.token() == CLASS ||
+                S.token() == INTERFACE ||
+                allowEnums && S.token() == ENUM) {
                 return List.<JCTree>of(classOrInterfaceOrEnumDeclaration(mods, dc));
-            } else if (token.kind == LBRACE && !isInterface &&
+            } else if (S.token() == LBRACE && !isInterface &&
                        (mods.flags & Flags.StandardFlags & ~Flags.STATIC) == 0 &&
                        mods.annotations.isEmpty()) {
                 return List.<JCTree>of(block(pos, mods.flags));
             } else {
-                pos = token.pos;
+                pos = S.pos();
                 List<JCTypeParameter> typarams = typeParametersOpt();
                 // if there are type parameters but no modifiers, save the start
                 // position of the method in the modifiers.
@@ -2871,26 +2580,26 @@
                     mods.pos = pos;
                     storeEnd(mods, pos);
                 }
-                Token tk = token;
-                pos = token.pos;
+                Name name = S.name();
+                pos = S.pos();
                 JCExpression type;
-                boolean isVoid = token.kind == VOID;
+                boolean isVoid = S.token() == VOID;
                 if (isVoid) {
                     type = to(F.at(pos).TypeIdent(TypeTags.VOID));
-                    nextToken();
+                    S.nextToken();
                 } else {
                     type = parseType();
                 }
-                if (token.kind == LPAREN && !isInterface && type.hasTag(IDENT)) {
-                    if (isInterface || tk.name() != className)
+                if (S.token() == LPAREN && !isInterface && type.getTag() == JCTree.IDENT) {
+                    if (isInterface || name != className)
                         error(pos, "invalid.meth.decl.ret.type.req");
                     return List.of(methodDeclaratorRest(
                         pos, mods, null, names.init, typarams,
                         isInterface, true, dc));
                 } else {
-                    pos = token.pos;
-                    Name name = ident();
-                    if (token.kind == LPAREN) {
+                    pos = S.pos();
+                    name = ident();
+                    if (S.token() == LPAREN) {
                         return List.of(methodDeclaratorRest(
                             pos, mods, type, name, typarams,
                             isInterface, isVoid, dc));
@@ -2898,16 +2607,16 @@
                         List<JCTree> defs =
                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
                                                     new ListBuffer<JCTree>()).toList();
-                        storeEnd(defs.last(), token.endPos);
+                        storeEnd(defs.last(), S.endPos());
                         accept(SEMI);
                         return defs;
                     } else {
-                        pos = token.pos;
+                        pos = S.pos();
                         List<JCTree> err = isVoid
                             ? List.<JCTree>of(toP(F.at(pos).MethodDef(mods, name, type, typarams,
                                 List.<JCVariableDecl>nil(), List.<JCExpression>nil(), null, null)))
                             : null;
-                        return List.<JCTree>of(syntaxError(token.pos, err, "expected", LPAREN));
+                        return List.<JCTree>of(syntaxError(S.pos(), err, "expected", LPAREN));
                     }
                 }
             }
@@ -2925,7 +2634,7 @@
      *  ConstructorDeclaratorRest =
      *      "(" FormalParameterListOpt ")" [THROWS TypeList] MethodBody
      */
-    protected JCTree methodDeclaratorRest(int pos,
+    JCTree methodDeclaratorRest(int pos,
                               JCModifiers mods,
                               JCExpression type,
                               Name name,
@@ -2935,27 +2644,27 @@
         List<JCVariableDecl> params = formalParameters();
         if (!isVoid) type = bracketsOpt(type);
         List<JCExpression> thrown = List.nil();
-        if (token.kind == THROWS) {
-            nextToken();
+        if (S.token() == THROWS) {
+            S.nextToken();
             thrown = qualidentList();
         }
         JCBlock body = null;
         JCExpression defaultValue;
-        if (token.kind == LBRACE) {
+        if (S.token() == LBRACE) {
             body = block();
             defaultValue = null;
         } else {
-            if (token.kind == DEFAULT) {
+            if (S.token() == DEFAULT) {
                 accept(DEFAULT);
                 defaultValue = annotationValue();
             } else {
                 defaultValue = null;
             }
             accept(SEMI);
-            if (token.pos <= endPosTable.errorEndPos) {
+            if (S.pos() <= errorEndPos) {
                 // error recovery
                 skip(false, true, false, false);
-                if (token.kind == LBRACE) {
+                if (S.token() == LBRACE) {
                     body = block();
                 }
             }
@@ -2974,8 +2683,8 @@
     List<JCExpression> qualidentList() {
         ListBuffer<JCExpression> ts = new ListBuffer<JCExpression>();
         ts.append(qualident());
-        while (token.kind == COMMA) {
-            nextToken();
+        while (S.token() == COMMA) {
+            S.nextToken();
             ts.append(qualident());
         }
         return ts.toList();
@@ -2984,13 +2693,13 @@
     /** TypeParametersOpt = ["<" TypeParameter {"," TypeParameter} ">"]
      */
     List<JCTypeParameter> typeParametersOpt() {
-        if (token.kind == LT) {
+        if (S.token() == LT) {
             checkGenerics();
             ListBuffer<JCTypeParameter> typarams = new ListBuffer<JCTypeParameter>();
-            nextToken();
+            S.nextToken();
             typarams.append(typeParameter());
-            while (token.kind == COMMA) {
-                nextToken();
+            while (S.token() == COMMA) {
+                S.nextToken();
                 typarams.append(typeParameter());
             }
             accept(GT);
@@ -3005,14 +2714,14 @@
      *  TypeVariable = Ident
      */
     JCTypeParameter typeParameter() {
-        int pos = token.pos;
+        int pos = S.pos();
         Name name = ident();
         ListBuffer<JCExpression> bounds = new ListBuffer<JCExpression>();
-        if (token.kind == EXTENDS) {
-            nextToken();
+        if (S.token() == EXTENDS) {
+            S.nextToken();
             bounds.append(parseType());
-            while (token.kind == AMP) {
-                nextToken();
+            while (S.token() == AMP) {
+                S.nextToken();
                 bounds.append(parseType());
             }
         }
@@ -3027,10 +2736,10 @@
         ListBuffer<JCVariableDecl> params = new ListBuffer<JCVariableDecl>();
         JCVariableDecl lastParam = null;
         accept(LPAREN);
-        if (token.kind != RPAREN) {
+        if (S.token() != RPAREN) {
             params.append(lastParam = formalParameter());
-            while ((lastParam.mods.flags & Flags.VARARGS) == 0 && token.kind == COMMA) {
-                nextToken();
+            while ((lastParam.mods.flags & Flags.VARARGS) == 0 && S.token() == COMMA) {
+                S.nextToken();
                 params.append(lastParam = formalParameter());
             }
         }
@@ -3038,24 +2747,6 @@
         return params.toList();
     }
 
-    List<JCVariableDecl> implicitParameters(boolean hasParens) {
-        if (hasParens) {
-            accept(LPAREN);
-        }
-        ListBuffer<JCVariableDecl> params = new ListBuffer<JCVariableDecl>();
-        if (token.kind != RPAREN && token.kind != ARROW) {
-            params.append(implicitParameter());
-            while (token.kind == COMMA) {
-                nextToken();
-                params.append(implicitParameter());
-            }
-        }
-        if (hasParens) {
-            accept(RPAREN);
-        }
-        return params.toList();
-    }
-
     JCModifiers optFinal(long flags) {
         JCModifiers mods = modifiersOpt();
         checkNoMods(mods.flags & ~(Flags.FINAL | Flags.DEPRECATED));
@@ -3066,33 +2757,24 @@
     /** FormalParameter = { FINAL | '@' Annotation } Type VariableDeclaratorId
      *  LastFormalParameter = { FINAL | '@' Annotation } Type '...' Ident | FormalParameter
      */
-    protected JCVariableDecl formalParameter() {
+    JCVariableDecl formalParameter() {
         JCModifiers mods = optFinal(Flags.PARAMETER);
         JCExpression type = parseType();
-        if (token.kind == ELLIPSIS) {
+        if (S.token() == ELLIPSIS) {
             checkVarargs();
             mods.flags |= Flags.VARARGS;
-            type = to(F.at(token.pos).TypeArray(type));
-            nextToken();
+            type = to(F.at(S.pos()).TypeArray(type));
+            S.nextToken();
         }
         return variableDeclaratorId(mods, type);
     }
 
-    protected JCVariableDecl implicitParameter() {
-        JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
-        return variableDeclaratorId(mods, null);
-    }
-
 /* ---------- auxiliary methods -------------- */
 
     void error(int pos, String key, Object ... args) {
         log.error(DiagnosticFlag.SYNTAX, pos, key, args);
     }
 
-    void error(DiagnosticPosition pos, String key, Object ... args) {
-        log.error(DiagnosticFlag.SYNTAX, pos, key, args);
-    }
-
     void warning(int pos, String key, Object ... args) {
         log.warning(pos, key, args);
     }
@@ -3101,29 +2783,28 @@
      */
     protected JCExpression checkExprStat(JCExpression t) {
         switch(t.getTag()) {
-        case PREINC: case PREDEC:
-        case POSTINC: case POSTDEC:
-        case ASSIGN:
-        case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
-        case SL_ASG: case SR_ASG: case USR_ASG:
-        case PLUS_ASG: case MINUS_ASG:
-        case MUL_ASG: case DIV_ASG: case MOD_ASG:
-        case APPLY: case NEWCLASS:
-        case ERRONEOUS:
+        case JCTree.PREINC: case JCTree.PREDEC:
+        case JCTree.POSTINC: case JCTree.POSTDEC:
+        case JCTree.ASSIGN:
+        case JCTree.BITOR_ASG: case JCTree.BITXOR_ASG: case JCTree.BITAND_ASG:
+        case JCTree.SL_ASG: case JCTree.SR_ASG: case JCTree.USR_ASG:
+        case JCTree.PLUS_ASG: case JCTree.MINUS_ASG:
+        case JCTree.MUL_ASG: case JCTree.DIV_ASG: case JCTree.MOD_ASG:
+        case JCTree.APPLY: case JCTree.NEWCLASS:
+        case JCTree.ERRONEOUS:
             return t;
         default:
-            JCExpression ret = F.at(t.pos).Erroneous(List.<JCTree>of(t));
-            error(ret, "not.stmt");
-            return ret;
+            error(t.pos, "not.stmt");
+            return F.at(t.pos).Erroneous(List.<JCTree>of(t));
         }
     }
 
     /** Return precedence of operator represented by token,
      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
      */
-    static int prec(TokenKind token) {
-        JCTree.Tag oc = optag(token);
-        return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
+    static int prec(Token token) {
+        int oc = optag(token);
+        return (oc >= 0) ? TreeInfo.opPrec(oc) : -1;
     }
 
     /**
@@ -3139,103 +2820,103 @@
     }
 
     /** Return operation tag of binary operator represented by token,
-     *  No_TAG if token is not a binary operator.
+     *  -1 if token is not a binary operator.
      */
-    static JCTree.Tag optag(TokenKind token) {
+    static int optag(Token token) {
         switch (token) {
         case BARBAR:
-            return OR;
+            return JCTree.OR;
         case AMPAMP:
-            return AND;
+            return JCTree.AND;
         case BAR:
-            return BITOR;
+            return JCTree.BITOR;
         case BAREQ:
-            return BITOR_ASG;
+            return JCTree.BITOR_ASG;
         case CARET:
-            return BITXOR;
+            return JCTree.BITXOR;
         case CARETEQ:
-            return BITXOR_ASG;
+            return JCTree.BITXOR_ASG;
         case AMP:
-            return BITAND;
+            return JCTree.BITAND;
         case AMPEQ:
-            return BITAND_ASG;
+            return JCTree.BITAND_ASG;
         case EQEQ:
-            return JCTree.Tag.EQ;
+            return JCTree.EQ;
         case BANGEQ:
-            return NE;
+            return JCTree.NE;
         case LT:
-            return JCTree.Tag.LT;
+            return JCTree.LT;
         case GT:
-            return JCTree.Tag.GT;
+            return JCTree.GT;
         case LTEQ:
-            return LE;
+            return JCTree.LE;
         case GTEQ:
-            return GE;
+            return JCTree.GE;
         case LTLT:
-            return SL;
+            return JCTree.SL;
         case LTLTEQ:
-            return SL_ASG;
+            return JCTree.SL_ASG;
         case GTGT:
-            return SR;
+            return JCTree.SR;
         case GTGTEQ:
-            return SR_ASG;
+            return JCTree.SR_ASG;
         case GTGTGT:
-            return USR;
+            return JCTree.USR;
         case GTGTGTEQ:
-            return USR_ASG;
+            return JCTree.USR_ASG;
         case PLUS:
-            return JCTree.Tag.PLUS;
+            return JCTree.PLUS;
         case PLUSEQ:
-            return PLUS_ASG;
+            return JCTree.PLUS_ASG;
         case SUB:
-            return MINUS;
+            return JCTree.MINUS;
         case SUBEQ:
-            return MINUS_ASG;
+            return JCTree.MINUS_ASG;
         case STAR:
-            return MUL;
+            return JCTree.MUL;
         case STAREQ:
-            return MUL_ASG;
+            return JCTree.MUL_ASG;
         case SLASH:
-            return DIV;
+            return JCTree.DIV;
         case SLASHEQ:
-            return DIV_ASG;
+            return JCTree.DIV_ASG;
         case PERCENT:
-            return MOD;
+            return JCTree.MOD;
         case PERCENTEQ:
-            return MOD_ASG;
+            return JCTree.MOD_ASG;
         case INSTANCEOF:
-            return TYPETEST;
+            return JCTree.TYPETEST;
         default:
-            return NO_TAG;
+            return -1;
         }
     }
 
     /** Return operation tag of unary operator represented by token,
-     *  No_TAG if token is not a binary operator.
+     *  -1 if token is not a binary operator.
      */
-    static JCTree.Tag unoptag(TokenKind token) {
+    static int unoptag(Token token) {
         switch (token) {
         case PLUS:
-            return POS;
+            return JCTree.POS;
         case SUB:
-            return NEG;
+            return JCTree.NEG;
         case BANG:
-            return NOT;
+            return JCTree.NOT;
         case TILDE:
-            return COMPL;
+            return JCTree.COMPL;
         case PLUSPLUS:
-            return PREINC;
+            return JCTree.PREINC;
         case SUBSUB:
-            return PREDEC;
+            return JCTree.PREDEC;
         default:
-            return NO_TAG;
+            return -1;
         }
     }
 
     /** Return type tag of basic type represented by token,
      *  -1 if token is not a basic type identifier.
      */
-    static int typetag(TokenKind token) {
+    static int typetag(Token token) {
         switch (token) {
         case BYTE:
             return TypeTags.BYTE;
@@ -3260,170 +2941,50 @@
 
     void checkGenerics() {
         if (!allowGenerics) {
-            error(token.pos, "generics.not.supported.in.source", source.name);
+            error(S.pos(), "generics.not.supported.in.source", source.name);
             allowGenerics = true;
         }
     }
     void checkVarargs() {
         if (!allowVarargs) {
-            error(token.pos, "varargs.not.supported.in.source", source.name);
+            error(S.pos(), "varargs.not.supported.in.source", source.name);
             allowVarargs = true;
         }
     }
     void checkForeach() {
         if (!allowForeach) {
-            error(token.pos, "foreach.not.supported.in.source", source.name);
+            error(S.pos(), "foreach.not.supported.in.source", source.name);
             allowForeach = true;
         }
     }
     void checkStaticImports() {
         if (!allowStaticImport) {
-            error(token.pos, "static.import.not.supported.in.source", source.name);
+            error(S.pos(), "static.import.not.supported.in.source", source.name);
             allowStaticImport = true;
         }
     }
     void checkAnnotations() {
         if (!allowAnnotations) {
-            error(token.pos, "annotations.not.supported.in.source", source.name);
+            error(S.pos(), "annotations.not.supported.in.source", source.name);
             allowAnnotations = true;
         }
     }
     void checkDiamond() {
         if (!allowDiamond) {
-            error(token.pos, "diamond.not.supported.in.source", source.name);
+            error(S.pos(), "diamond.not.supported.in.source", source.name);
             allowDiamond = true;
         }
     }
     void checkMulticatch() {
         if (!allowMulticatch) {
-            error(token.pos, "multicatch.not.supported.in.source", source.name);
+            error(S.pos(), "multicatch.not.supported.in.source", source.name);
             allowMulticatch = true;
         }
     }
     void checkTryWithResources() {
         if (!allowTWR) {
-            error(token.pos, "try.with.resources.not.supported.in.source", source.name);
+            error(S.pos(), "try.with.resources.not.supported.in.source", source.name);
             allowTWR = true;
         }
     }
-    void checkLambda() {
-        if (!allowLambda) {
-            log.error(token.pos, "lambda.not.supported.in.source", source.name);
-            allowLambda = true;
-        }
-    }
-    void checkMethodReferences() {
-        if (!allowMethodReferences) {
-            log.error(token.pos, "method.references.not.supported.in.source", source.name);
-            allowMethodReferences = true;
-        }
-    }
-
-    /*
-     * a functional source tree and end position mappings
-     */
-    protected class SimpleEndPosTable extends AbstractEndPosTable {
-
-        private final Map<JCTree, Integer> endPosMap;
-
-        SimpleEndPosTable() {
-            endPosMap = new HashMap<JCTree, Integer>();
-        }
-
-        protected void storeEnd(JCTree tree, int endpos) {
-            endPosMap.put(tree, errorEndPos > endpos ? errorEndPos : endpos);
-        }
-
-        protected <T extends JCTree> T to(T t) {
-            storeEnd(t, token.endPos);
-            return t;
-        }
-
-        protected <T extends JCTree> T toP(T t) {
-            storeEnd(t, S.prevToken().endPos);
-            return t;
-        }
-
-        public int getEndPos(JCTree tree) {
-            Integer value = endPosMap.get(tree);
-            return (value == null) ? Position.NOPOS : value;
-        }
-
-        public int replaceTree(JCTree oldTree, JCTree newTree) {
-            Integer pos = endPosMap.remove(oldTree);
-            if (pos != null) {
-                endPosMap.put(newTree, pos);
-                return pos;
-            }
-            return Position.NOPOS;
-        }
-    }
-
-    /*
-     * a default skeletal implementation without any mapping overhead.
-     */
-    protected class EmptyEndPosTable extends AbstractEndPosTable {
-
-        protected void storeEnd(JCTree tree, int endpos) { /* empty */ }
-
-        protected <T extends JCTree> T to(T t) {
-            return t;
-        }
-
-        protected <T extends JCTree> T toP(T t) {
-            return t;
-        }
-
-        public int getEndPos(JCTree tree) {
-            return Position.NOPOS;
-        }
-
-        public int replaceTree(JCTree oldTree, JCTree newTree) {
-            return Position.NOPOS;
-        }
-
-    }
-
-    protected abstract class AbstractEndPosTable implements EndPosTable {
-
-        /**
-         * Store the last error position.
-         */
-        protected int errorEndPos;
-
-        /**
-         * Store ending position for a tree, the value of which is the greater
-         * of last error position and the given ending position.
-         * @param tree   The tree.
-         * @param endpos The ending position to associate with the tree.
-         */
-        protected abstract void storeEnd(JCTree tree, int endpos);
-
-        /**
-         * Store current token's ending position for a tree, the value of which
-         * will be the greater of last error position and the ending position of
-         * the current token.
-         * @param t The tree.
-         */
-        protected abstract <T extends JCTree> T to(T t);
-
-        /**
-         * Store current token's ending position for a tree, the value of which
-         * will be the greater of last error position and the ending position of
-         * the previous token.
-         * @param t The tree.
-         */
-        protected abstract <T extends JCTree> T toP(T t);
-
-        /**
-         * Set the error position during the parsing phases, the value of which
-         * will be set only if it is greater than the last stored error position.
-         * @param errPos The error position
-         */
-        protected void setErrorEndPos(int errPos) {
-            if (errPos > errorEndPos) {
-                errorEndPos = errPos;
-            }
-        }
-    }
 }
Only in javac/parser: JavadocTokenizer.java
Only in javac/parser: JavaTokenizer.java
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser: Keywords.java
diff -u -r javac/parser/Lexer.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/Lexer.java
--- javac/parser/Lexer.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/Lexer.java	2011-06-27 15:21:47.000000000 -0500
@@ -25,7 +25,7 @@
 
 package com.sun.tools.javac.parser;
 
-import com.sun.tools.javac.parser.Tokens.*;
+import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.Position.LineMap;
 
 /**
@@ -40,31 +40,22 @@
 public interface Lexer {
 
     /**
-     * Consume the next token.
+     * Has a @deprecated been encountered in last doc comment?
+     * This needs to be reset by client with resetDeprecatedFlag.
      */
-    void nextToken();
+    boolean deprecatedFlag();
 
-    /**
-     * Return current token.
-     */
-    Token token();
+    void resetDeprecatedFlag();
 
     /**
-     * Return token with given lookahead.
+     * Returns the documentation string of the current token.
      */
-    Token token(int lookahead);
+    String docComment();
 
     /**
-     * Return the last character position of the previous token.
+     * Return the last character position of the current token.
      */
-    Token prevToken();
-
-    /**
-     * Splits the current token in two and return the first (splitted) token.
-     * For instance '<<<' is splitted into two tokens '<' and '<<' respectively,
-     * and the latter is returned.
-     */
-    Token split();
+    int endPos();
 
     /**
      * Return the position where a lexical error occurred;
@@ -83,4 +74,69 @@
      * @return a LineMap
      */
     LineMap getLineMap();
+
+    /**
+     * Returns a copy of the input buffer, up to its inputLength.
+     * Unicode escape sequences are not translated.
+     */
+    char[] getRawCharacters();
+
+    /**
+     * Returns a copy of a character array subset of the input buffer.
+     * The returned array begins at the <code>beginIndex</code> and
+     * extends to the character at index <code>endIndex - 1</code>.
+     * Thus the length of the substring is <code>endIndex-beginIndex</code>.
+     * This behavior is like
+     * <code>String.substring(beginIndex, endIndex)</code>.
+     * Unicode escape sequences are not translated.
+     *
+     * @param beginIndex the beginning index, inclusive.
+     * @param endIndex the ending index, exclusive.
+     * @throws IndexOutOfBounds if either offset is outside of the
+     *         array bounds
+     */
+    char[] getRawCharacters(int beginIndex, int endIndex);
+
+    /**
+     * Return the name of an identifier or token for the current token.
+     */
+    Name name();
+
+    /**
+     * Read token.
+     */
+    void nextToken();
+
+    /**
+     * Return the current token's position: a 0-based
+     *  offset from beginning of the raw input stream
+     *  (before unicode translation)
+     */
+    int pos();
+
+    /**
+     * Return the last character position of the previous token.
+     */
+    int prevEndPos();
+
+    /**
+     * Return the radix of a numeric literal token.
+     */
+    int radix();
+
+    /**
+     * The value of a literal token, recorded as a string.
+     *  For integers, leading 0x and 'l' suffixes are suppressed.
+     */
+    String stringVal();
+
+    /**
+     * Return the current token, set by nextToken().
+     */
+    Token token();
+
+    /**
+     * Sets the current token.
+     */
+    void token(Token token);
 }
diff -u -r javac/parser/ParserFactory.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/ParserFactory.java
--- javac/parser/ParserFactory.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/ParserFactory.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -55,7 +55,7 @@
 
     final TreeMaker F;
     final Log log;
-    final Tokens tokens;
+    final Keywords keywords;
     final Source source;
     final Names names;
     final Options options;
@@ -67,7 +67,7 @@
         this.F = TreeMaker.instance(context);
         this.log = Log.instance(context);
         this.names = Names.instance(context);
-        this.tokens = Tokens.instance(context);
+        this.keywords = Keywords.instance(context);
         this.source = Source.instance(context);
         this.options = Options.instance(context);
         this.scannerFactory = ScannerFactory.instance(context);
@@ -75,6 +75,10 @@
 
     public Parser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap) {
         Lexer lexer = scannerFactory.newScanner(input, keepDocComments);
-        return new JavacParser(this, lexer, keepDocComments, keepLineMap, keepEndPos);
+        if (keepEndPos) {
+            return new EndPosParser(this, lexer, keepDocComments, keepLineMap);
+        } else {
+            return new JavacParser(this, lexer, keepDocComments, keepLineMap);
+        }
     }
 }
diff -u -r javac/parser/ScannerFactory.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/ScannerFactory.java
--- javac/parser/ScannerFactory.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/ScannerFactory.java	2011-06-27 15:21:47.000000000 -0500
@@ -57,7 +57,7 @@
     final Log log;
     final Names names;
     final Source source;
-    final Tokens tokens;
+    final Keywords keywords;
 
     /** Create a new scanner factory. */
     protected ScannerFactory(Context context) {
@@ -65,14 +65,14 @@
         this.log = Log.instance(context);
         this.names = Names.instance(context);
         this.source = Source.instance(context);
-        this.tokens = Tokens.instance(context);
+        this.keywords = Keywords.instance(context);
     }
 
     public Scanner newScanner(CharSequence input, boolean keepDocComments) {
         if (input instanceof CharBuffer) {
             CharBuffer buf = (CharBuffer) input;
             if (keepDocComments)
-                return new Scanner(this, new JavadocTokenizer(this, buf));
+                return new DocCommentScanner(this, buf);
             else
                 return new Scanner(this, buf);
         } else {
@@ -83,7 +83,7 @@
 
     public Scanner newScanner(char[] input, int inputLength, boolean keepDocComments) {
         if (keepDocComments)
-            return new Scanner(this, new JavadocTokenizer(this, input, inputLength));
+            return new DocCommentScanner(this, input, inputLength);
         else
             return new Scanner(this, input, inputLength);
     }
diff -u -r javac/parser/Scanner.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/Scanner.java
--- javac/parser/Scanner.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser/Scanner.java	2011-06-27 15:21:47.000000000 -0500
@@ -26,13 +26,14 @@
 package com.sun.tools.javac.parser;
 
 import java.nio.*;
-import java.util.List;
-import java.util.ArrayList;
 
-import com.sun.tools.javac.util.Position.LineMap;
-import com.sun.tools.javac.parser.JavaTokenizer.*;
+import com.sun.tools.javac.code.Source;
+import com.sun.tools.javac.file.JavacFileManager;
+import com.sun.tools.javac.util.*;
 
-import static com.sun.tools.javac.parser.Tokens.*;
+
+import static com.sun.tools.javac.parser.Token.*;
+import static com.sun.tools.javac.util.LayoutCharacters.*;
 
 /** The lexical analyzer maps an input stream consisting of
  *  ASCII characters and Unicode escapes into a token sequence.
@@ -44,21 +45,119 @@
  */
 public class Scanner implements Lexer {
 
-    private Tokens tokens;
+    private static boolean scannerDebug = false;
+
+    /* Output variables; set by nextToken():
+     */
 
     /** The token, set by nextToken().
      */
     private Token token;
 
-    /** The previous token, set by nextToken().
+    /** Allow hex floating-point literals.
+     */
+    private boolean allowHexFloats;
+
+    /** Allow binary literals.
+     */
+    private boolean allowBinaryLiterals;
+
+    /** Allow underscores in literals.
+     */
+    private boolean allowUnderscoresInLiterals;
+
+    /** The source language setting.
+     */
+    private Source source;
+
+    /** The token's position, 0-based offset from beginning of text.
+     */
+    private int pos;
+
+    /** Character position just after the last character of the token.
+     */
+    private int endPos;
+
+    /** The last character position of the previous token.
+     */
+    private int prevEndPos;
+
+    /** The position where a lexical error occurred;
+     */
+    private int errPos = Position.NOPOS;
+
+    /** The name of an identifier or token:
+     */
+    private Name name;
+
+    /** The radix of a numeric literal token.
+     */
+    private int radix;
+
+    /** Has a @deprecated been encountered in last doc comment?
+     *  this needs to be reset by client.
+     */
+    protected boolean deprecatedFlag = false;
+
+    /** A character buffer for literals.
+     */
+    private char[] sbuf = new char[128];
+    private int sp;
+
+    /** The input buffer, index of next chacter to be read,
+     *  index of one past last character in buffer.
+     */
+    private char[] buf;
+    private int bp;
+    private int buflen;
+    private int eofPos;
+
+    /** The current character.
+     */
+    private char ch;
+
+    /** The buffer index of the last converted unicode character
+     */
+    private int unicodeConversionBp = -1;
+
+    /** The log to be used for error reporting.
      */
-    private Token prevToken;
+    private final Log log;
+
+    /** The name table. */
+    private final Names names;
+
+    /** The keyword table. */
+    private final Keywords keywords;
+
+    /** Common code for constructors. */
+    private Scanner(ScannerFactory fac) {
+        log = fac.log;
+        names = fac.names;
+        keywords = fac.keywords;
+        source = fac.source;
+        allowBinaryLiterals = source.allowBinaryLiterals();
+        allowHexFloats = source.allowHexFloats();
+        allowUnderscoresInLiterals = source.allowUnderscoresInLiterals();
+    }
+
+    private static final boolean hexFloatsWork = hexFloatsWork();
+    private static boolean hexFloatsWork() {
+        try {
+            Float.valueOf("0x1.0p1");
+            return true;
+        } catch (NumberFormatException ex) {
+            return false;
+        }
+    }
 
-    /** Buffer of saved tokens (used during lookahead)
+    /** Create a scanner from the input buffer.  buffer must implement
+     *  array() and compact(), and remaining() must be less than limit().
      */
-    private List<Token> savedTokens = new ArrayList<Token>();
+    protected Scanner(ScannerFactory fac, CharBuffer buffer) {
+        this(fac, JavacFileManager.toArray(buffer), buffer.limit());
+    }
 
-    private JavaTokenizer tokenizer;
     /**
      * Create a scanner from the input array.  This method might
      * modify the array.  To avoid copying the input array, ensure
@@ -70,68 +169,964 @@
      * @param inputLength the size of the input.
      * Must be positive and less than or equal to input.length.
      */
-    protected Scanner(ScannerFactory fac, CharBuffer buf) {
-        this(fac, new JavaTokenizer(fac, buf));
+    protected Scanner(ScannerFactory fac, char[] input, int inputLength) {
+        this(fac);
+        eofPos = inputLength;
+        if (inputLength == input.length) {
+            if (input.length > 0 && Character.isWhitespace(input[input.length - 1])) {
+                inputLength--;
+            } else {
+                char[] newInput = new char[inputLength + 1];
+                System.arraycopy(input, 0, newInput, 0, input.length);
+                input = newInput;
+            }
+        }
+        buf = input;
+        buflen = inputLength;
+        buf[buflen] = EOI;
+        bp = -1;
+        scanChar();
     }
 
-    protected Scanner(ScannerFactory fac, char[] buf, int inputLength) {
-        this(fac, new JavaTokenizer(fac, buf, inputLength));
+    /** Report an error at the given position using the provided arguments.
+     */
+    private void lexError(int pos, String key, Object... args) {
+        log.error(pos, key, args);
+        token = ERROR;
+        errPos = pos;
     }
 
-    protected Scanner(ScannerFactory fac, JavaTokenizer tokenizer) {
-        this.tokenizer = tokenizer;
-        tokens = fac.tokens;
-        token = prevToken = DUMMY;
+    /** Report an error at the current token position using the provided
+     *  arguments.
+     */
+    private void lexError(String key, Object... args) {
+        lexError(pos, key, args);
     }
 
-    public Token token() {
-        return token(0);
+    /** Convert an ASCII digit from its base (8, 10, or 16)
+     *  to its value.
+     */
+    private int digit(int base) {
+        char c = ch;
+        int result = Character.digit(c, base);
+        if (result >= 0 && c > 0x7f) {
+            lexError(pos+1, "illegal.nonascii.digit");
+            ch = "0123456789abcdef".charAt(result);
+        }
+        return result;
+    }
+
+    /** Convert unicode escape; bp points to initial '\' character
+     *  (Spec 3.3).
+     */
+    private void convertUnicode() {
+        if (ch == '\\' && unicodeConversionBp != bp) {
+            bp++; ch = buf[bp];
+            if (ch == 'u') {
+                do {
+                    bp++; ch = buf[bp];
+                } while (ch == 'u');
+                int limit = bp + 3;
+                if (limit < buflen) {
+                    int d = digit(16);
+                    int code = d;
+                    while (bp < limit && d >= 0) {
+                        bp++; ch = buf[bp];
+                        d = digit(16);
+                        code = (code << 4) + d;
+                    }
+                    if (d >= 0) {
+                        ch = (char)code;
+                        unicodeConversionBp = bp;
+                        return;
+                    }
+                }
+                lexError(bp, "illegal.unicode.esc");
+            } else {
+                bp--;
+                ch = '\\';
+            }
+        }
+    }
+
+    /** Read next character.
+     */
+    private void scanChar() {
+        ch = buf[++bp];
+        if (ch == '\\') {
+            convertUnicode();
+        }
+    }
+
+    /** Read next character in comment, skipping over double '\' characters.
+     */
+    private void scanCommentChar() {
+        scanChar();
+        if (ch == '\\') {
+            if (buf[bp+1] == '\\' && unicodeConversionBp != bp) {
+                bp++;
+            } else {
+                convertUnicode();
+            }
+        }
+    }
+
+    /** Append a character to sbuf.
+     */
+    private void putChar(char ch) {
+        if (sp == sbuf.length) {
+            char[] newsbuf = new char[sbuf.length * 2];
+            System.arraycopy(sbuf, 0, newsbuf, 0, sbuf.length);
+            sbuf = newsbuf;
+        }
+        sbuf[sp++] = ch;
     }
 
-    public Token token(int lookahead) {
-        if (lookahead == 0) {
-            return token;
+    /** Read next character in character or string literal and copy into sbuf.
+     */
+    private void scanLitChar() {
+        if (ch == '\\') {
+            if (buf[bp+1] == '\\' && unicodeConversionBp != bp) {
+                bp++;
+                putChar('\\');
+                scanChar();
+            } else {
+                scanChar();
+                switch (ch) {
+                case '0': case '1': case '2': case '3':
+                case '4': case '5': case '6': case '7':
+                    char leadch = ch;
+                    int oct = digit(8);
+                    scanChar();
+                    if ('0' <= ch && ch <= '7') {
+                        oct = oct * 8 + digit(8);
+                        scanChar();
+                        if (leadch <= '3' && '0' <= ch && ch <= '7') {
+                            oct = oct * 8 + digit(8);
+                            scanChar();
+                        }
+                    }
+                    putChar((char)oct);
+                    break;
+                case 'b':
+                    putChar('\b'); scanChar(); break;
+                case 't':
+                    putChar('\t'); scanChar(); break;
+                case 'n':
+                    putChar('\n'); scanChar(); break;
+                case 'f':
+                    putChar('\f'); scanChar(); break;
+                case 'r':
+                    putChar('\r'); scanChar(); break;
+                case '\'':
+                    putChar('\''); scanChar(); break;
+                case '\"':
+                    putChar('\"'); scanChar(); break;
+                case '\\':
+                    putChar('\\'); scanChar(); break;
+                default:
+                    lexError(bp, "illegal.esc.char");
+                }
+            }
+        } else if (bp != buflen) {
+            putChar(ch); scanChar();
+        }
+    }
+
+    private void scanDigits(int digitRadix) {
+        char saveCh;
+        int savePos;
+        do {
+            if (ch != '_') {
+                putChar(ch);
+            } else {
+                if (!allowUnderscoresInLiterals) {
+                    lexError("unsupported.underscore.lit", source.name);
+                    allowUnderscoresInLiterals = true;
+                }
+            }
+            saveCh = ch;
+            savePos = bp;
+            scanChar();
+        } while (digit(digitRadix) >= 0 || ch == '_');
+        if (saveCh == '_')
+            lexError(savePos, "illegal.underscore");
+    }
+
+    /** Read fractional part of hexadecimal floating point number.
+     */
+    private void scanHexExponentAndSuffix() {
+        if (ch == 'p' || ch == 'P') {
+            putChar(ch);
+            scanChar();
+            skipIllegalUnderscores();
+            if (ch == '+' || ch == '-') {
+                putChar(ch);
+                scanChar();
+            }
+            skipIllegalUnderscores();
+            if ('0' <= ch && ch <= '9') {
+                scanDigits(10);
+                if (!allowHexFloats) {
+                    lexError("unsupported.fp.lit", source.name);
+                    allowHexFloats = true;
+                }
+                else if (!hexFloatsWork)
+                    lexError("unsupported.cross.fp.lit");
+            } else
+                lexError("malformed.fp.lit");
+        } else {
+            lexError("malformed.fp.lit");
+        }
+        if (ch == 'f' || ch == 'F') {
+            putChar(ch);
+            scanChar();
+            token = FLOATLITERAL;
         } else {
-            ensureLookahead(lookahead);
-            return savedTokens.get(lookahead - 1);
+            if (ch == 'd' || ch == 'D') {
+                putChar(ch);
+                scanChar();
+            }
+            token = DOUBLELITERAL;
         }
     }
-    //where
-        private void ensureLookahead(int lookahead) {
-            for (int i = savedTokens.size() ; i < lookahead ; i ++) {
-                savedTokens.add(tokenizer.readToken());
+
+    /** Read fractional part of floating point number.
+     */
+    private void scanFraction() {
+        skipIllegalUnderscores();
+        if ('0' <= ch && ch <= '9') {
+            scanDigits(10);
+        }
+        int sp1 = sp;
+        if (ch == 'e' || ch == 'E') {
+            putChar(ch);
+            scanChar();
+            skipIllegalUnderscores();
+            if (ch == '+' || ch == '-') {
+                putChar(ch);
+                scanChar();
             }
+            skipIllegalUnderscores();
+            if ('0' <= ch && ch <= '9') {
+                scanDigits(10);
+                return;
+            }
+            lexError("malformed.fp.lit");
+            sp = sp1;
         }
+    }
 
-    public Token prevToken() {
-        return prevToken;
+    /** Read fractional part and 'd' or 'f' suffix of floating point number.
+     */
+    private void scanFractionAndSuffix() {
+        this.radix = 10;
+        scanFraction();
+        if (ch == 'f' || ch == 'F') {
+            putChar(ch);
+            scanChar();
+            token = FLOATLITERAL;
+        } else {
+            if (ch == 'd' || ch == 'D') {
+                putChar(ch);
+                scanChar();
+            }
+            token = DOUBLELITERAL;
+        }
     }
 
-    public void nextToken() {
-        prevToken = token;
-        if (!savedTokens.isEmpty()) {
-            token = savedTokens.remove(0);
+    /** Read fractional part and 'd' or 'f' suffix of floating point number.
+     */
+    private void scanHexFractionAndSuffix(boolean seendigit) {
+        this.radix = 16;
+        Assert.check(ch == '.');
+        putChar(ch);
+        scanChar();
+        skipIllegalUnderscores();
+        if (digit(16) >= 0) {
+            seendigit = true;
+            scanDigits(16);
+        }
+        if (!seendigit)
+            lexError("invalid.hex.number");
+        else
+            scanHexExponentAndSuffix();
+    }
+
+    private void skipIllegalUnderscores() {
+        if (ch == '_') {
+            lexError(bp, "illegal.underscore");
+            while (ch == '_')
+                scanChar();
+        }
+    }
+
+    /** Read a number.
+     *  @param radix  The radix of the number; one of 2, j8, 10, 16.
+     */
+    private void scanNumber(int radix) {
+        this.radix = radix;
+        // for octal, allow base-10 digit in case it's a float literal
+        int digitRadix = (radix == 8 ? 10 : radix);
+        boolean seendigit = false;
+        if (digit(digitRadix) >= 0) {
+            seendigit = true;
+            scanDigits(digitRadix);
+        }
+        if (radix == 16 && ch == '.') {
+            scanHexFractionAndSuffix(seendigit);
+        } else if (seendigit && radix == 16 && (ch == 'p' || ch == 'P')) {
+            scanHexExponentAndSuffix();
+        } else if (digitRadix == 10 && ch == '.') {
+            putChar(ch);
+            scanChar();
+            scanFractionAndSuffix();
+        } else if (digitRadix == 10 &&
+                   (ch == 'e' || ch == 'E' ||
+                    ch == 'f' || ch == 'F' ||
+                    ch == 'd' || ch == 'D')) {
+            scanFractionAndSuffix();
         } else {
-            token = tokenizer.readToken();
+            if (ch == 'l' || ch == 'L') {
+                scanChar();
+                token = LONGLITERAL;
+            } else {
+                token = INTLITERAL;
+            }
+        }
+    }
+
+    /** Read an identifier.
+     */
+    private void scanIdent() {
+        boolean isJavaIdentifierPart;
+        char high;
+        do {
+            if (sp == sbuf.length) putChar(ch); else sbuf[sp++] = ch;
+            // optimization, was: putChar(ch);
+
+            scanChar();
+            switch (ch) {
+            case 'A': case 'B': case 'C': case 'D': case 'E':
+            case 'F': case 'G': case 'H': case 'I': case 'J':
+            case 'K': case 'L': case 'M': case 'N': case 'O':
+            case 'P': case 'Q': case 'R': case 'S': case 'T':
+            case 'U': case 'V': case 'W': case 'X': case 'Y':
+            case 'Z':
+            case 'a': case 'b': case 'c': case 'd': case 'e':
+            case 'f': case 'g': case 'h': case 'i': case 'j':
+            case 'k': case 'l': case 'm': case 'n': case 'o':
+            case 'p': case 'q': case 'r': case 's': case 't':
+            case 'u': case 'v': case 'w': case 'x': case 'y':
+            case 'z':
+            case '$': case '_':
+            case '0': case '1': case '2': case '3': case '4':
+            case '5': case '6': case '7': case '8': case '9':
+            case '\u0000': case '\u0001': case '\u0002': case '\u0003':
+            case '\u0004': case '\u0005': case '\u0006': case '\u0007':
+            case '\u0008': case '\u000E': case '\u000F': case '\u0010':
+            case '\u0011': case '\u0012': case '\u0013': case '\u0014':
+            case '\u0015': case '\u0016': case '\u0017':
+            case '\u0018': case '\u0019': case '\u001B':
+            case '\u007F':
+                break;
+            case '\u001A': // EOI is also a legal identifier part
+                if (bp >= buflen) {
+                    name = names.fromChars(sbuf, 0, sp);
+                    token = keywords.key(name);
+                    return;
+                }
+                break;
+            default:
+                if (ch < '\u0080') {
+                    // all ASCII range chars already handled, above
+                    isJavaIdentifierPart = false;
+                } else {
+                    high = scanSurrogates();
+                    if (high != 0) {
+                        if (sp == sbuf.length) {
+                            putChar(high);
+                        } else {
+                            sbuf[sp++] = high;
+                        }
+                        isJavaIdentifierPart = Character.isJavaIdentifierPart(
+                            Character.toCodePoint(high, ch));
+                    } else {
+                        isJavaIdentifierPart = Character.isJavaIdentifierPart(ch);
+                    }
+                }
+                if (!isJavaIdentifierPart) {
+                    name = names.fromChars(sbuf, 0, sp);
+                    token = keywords.key(name);
+                    return;
+                }
+            }
+        } while (true);
+    }
+
+    /** Are surrogates supported?
+     */
+    final static boolean surrogatesSupported = surrogatesSupported();
+    private static boolean surrogatesSupported() {
+        try {
+            Character.isHighSurrogate('a');
+            return true;
+        } catch (NoSuchMethodError ex) {
+            return false;
+        }
+    }
+
+    /** Scan surrogate pairs.  If 'ch' is a high surrogate and
+     *  the next character is a low surrogate, then put the low
+     *  surrogate in 'ch', and return the high surrogate.
+     *  otherwise, just return 0.
+     */
+    private char scanSurrogates() {
+        if (surrogatesSupported && Character.isHighSurrogate(ch)) {
+            char high = ch;
+
+            scanChar();
+
+            if (Character.isLowSurrogate(ch)) {
+                return high;
+            }
+
+            ch = high;
+        }
+
+        return 0;
+    }
+
+    /** Return true if ch can be part of an operator.
+     */
+    private boolean isSpecial(char ch) {
+        switch (ch) {
+        case '!': case '%': case '&': case '*': case '?':
+        case '+': case '-': case ':': case '<': case '=':
+        case '>': case '^': case '|': case '~':
+        case '@':
+            return true;
+        default:
+            return false;
+        }
+    }
+
+    /** Read longest possible sequence of special characters and convert
+     *  to token.
+     */
+    private void scanOperator() {
+        while (true) {
+            putChar(ch);
+            Name newname = names.fromChars(sbuf, 0, sp);
+            if (keywords.key(newname) == IDENTIFIER) {
+                sp--;
+                break;
+            }
+            name = newname;
+            token = keywords.key(newname);
+            scanChar();
+            if (!isSpecial(ch)) break;
+        }
+    }
+
+    /**
+     * Scan a documention comment; determine if a deprecated tag is present.
+     * Called once the initial /, * have been skipped, positioned at the second *
+     * (which is treated as the beginning of the first line).
+     * Stops positioned at the closing '/'.
+     */
+    @SuppressWarnings("fallthrough")
+    private void scanDocComment() {
+        boolean deprecatedPrefix = false;
+
+        forEachLine:
+        while (bp < buflen) {
+
+            // Skip optional WhiteSpace at beginning of line
+            while (bp < buflen && (ch == ' ' || ch == '\t' || ch == FF)) {
+                scanCommentChar();
+            }
+
+            // Skip optional consecutive Stars
+            while (bp < buflen && ch == '*') {
+                scanCommentChar();
+                if (ch == '/') {
+                    return;
+                }
+            }
+
+            // Skip optional WhiteSpace after Stars
+            while (bp < buflen && (ch == ' ' || ch == '\t' || ch == FF)) {
+                scanCommentChar();
+            }
+
+            deprecatedPrefix = false;
+            // At beginning of line in the JavaDoc sense.
+            if (bp < buflen && ch == '@' && !deprecatedFlag) {
+                scanCommentChar();
+                if (bp < buflen && ch == 'd') {
+                    scanCommentChar();
+                    if (bp < buflen && ch == 'e') {
+                        scanCommentChar();
+                        if (bp < buflen && ch == 'p') {
+                            scanCommentChar();
+                            if (bp < buflen && ch == 'r') {
+                                scanCommentChar();
+                                if (bp < buflen && ch == 'e') {
+                                    scanCommentChar();
+                                    if (bp < buflen && ch == 'c') {
+                                        scanCommentChar();
+                                        if (bp < buflen && ch == 'a') {
+                                            scanCommentChar();
+                                            if (bp < buflen && ch == 't') {
+                                                scanCommentChar();
+                                                if (bp < buflen && ch == 'e') {
+                                                    scanCommentChar();
+                                                    if (bp < buflen && ch == 'd') {
+                                                        deprecatedPrefix = true;
+                                                        scanCommentChar();
+                                                    }}}}}}}}}}}
+            if (deprecatedPrefix && bp < buflen) {
+                if (Character.isWhitespace(ch)) {
+                    deprecatedFlag = true;
+                } else if (ch == '*') {
+                    scanCommentChar();
+                    if (ch == '/') {
+                        deprecatedFlag = true;
+                        return;
+                    }
+                }
+            }
+
+            // Skip rest of line
+            while (bp < buflen) {
+                switch (ch) {
+                case '*':
+                    scanCommentChar();
+                    if (ch == '/') {
+                        return;
+                    }
+                    break;
+                case CR: // (Spec 3.4)
+                    scanCommentChar();
+                    if (ch != LF) {
+                        continue forEachLine;
+                    }
+                    /* fall through to LF case */
+                case LF: // (Spec 3.4)
+                    scanCommentChar();
+                    continue forEachLine;
+                default:
+                    scanCommentChar();
+                }
+            } // rest of line
+        } // forEachLine
+        return;
+    }
+
+    /** The value of a literal token, recorded as a string.
+     *  For integers, leading 0x and 'l' suffixes are suppressed.
+     */
+    public String stringVal() {
+        return new String(sbuf, 0, sp);
+    }
+
+    /** Read token.
+     */
+    public void nextToken() {
+
+        try {
+            prevEndPos = endPos;
+            sp = 0;
+
+            while (true) {
+                pos = bp;
+                switch (ch) {
+                case ' ': // (Spec 3.6)
+                case '\t': // (Spec 3.6)
+                case FF: // (Spec 3.6)
+                    do {
+                        scanChar();
+                    } while (ch == ' ' || ch == '\t' || ch == FF);
+                    endPos = bp;
+                    processWhiteSpace();
+                    break;
+                case LF: // (Spec 3.4)
+                    scanChar();
+                    endPos = bp;
+                    processLineTerminator();
+                    break;
+                case CR: // (Spec 3.4)
+                    scanChar();
+                    if (ch == LF) {
+                        scanChar();
+                    }
+                    endPos = bp;
+                    processLineTerminator();
+                    break;
+                case 'A': case 'B': case 'C': case 'D': case 'E':
+                case 'F': case 'G': case 'H': case 'I': case 'J':
+                case 'K': case 'L': case 'M': case 'N': case 'O':
+                case 'P': case 'Q': case 'R': case 'S': case 'T':
+                case 'U': case 'V': case 'W': case 'X': case 'Y':
+                case 'Z':
+                case 'a': case 'b': case 'c': case 'd': case 'e':
+                case 'f': case 'g': case 'h': case 'i': case 'j':
+                case 'k': case 'l': case 'm': case 'n': case 'o':
+                case 'p': case 'q': case 'r': case 's': case 't':
+                case 'u': case 'v': case 'w': case 'x': case 'y':
+                case 'z':
+                case '$': case '_':
+                    scanIdent();
+                    return;
+                case '0':
+                    scanChar();
+                    if (ch == 'x' || ch == 'X') {
+                        scanChar();
+                        skipIllegalUnderscores();
+                        if (ch == '.') {
+                            scanHexFractionAndSuffix(false);
+                        } else if (digit(16) < 0) {
+                            lexError("invalid.hex.number");
+                        } else {
+                            scanNumber(16);
+                        }
+                    } else if (ch == 'b' || ch == 'B') {
+                        if (!allowBinaryLiterals) {
+                            lexError("unsupported.binary.lit", source.name);
+                            allowBinaryLiterals = true;
+                        }
+                        scanChar();
+                        skipIllegalUnderscores();
+                        if (digit(2) < 0) {
+                            lexError("invalid.binary.number");
+                        } else {
+                            scanNumber(2);
+                        }
+                    } else {
+                        putChar('0');
+                        if (ch == '_') {
+                            int savePos = bp;
+                            do {
+                                scanChar();
+                            } while (ch == '_');
+                            if (digit(10) < 0) {
+                                lexError(savePos, "illegal.underscore");
+                            }
+                        }
+                        scanNumber(8);
+                    }
+                    return;
+                case '1': case '2': case '3': case '4':
+                case '5': case '6': case '7': case '8': case '9':
+                    scanNumber(10);
+                    return;
+                case '.':
+                    scanChar();
+                    if ('0' <= ch && ch <= '9') {
+                        putChar('.');
+                        scanFractionAndSuffix();
+                    } else if (ch == '.') {
+                        putChar('.'); putChar('.');
+                        scanChar();
+                        if (ch == '.') {
+                            scanChar();
+                            putChar('.');
+                            token = ELLIPSIS;
+                        } else {
+                            lexError("malformed.fp.lit");
+                        }
+                    } else {
+                        token = DOT;
+                    }
+                    return;
+                case ',':
+                    scanChar(); token = COMMA; return;
+                case ';':
+                    scanChar(); token = SEMI; return;
+                case '(':
+                    scanChar(); token = LPAREN; return;
+                case ')':
+                    scanChar(); token = RPAREN; return;
+                case '[':
+                    scanChar(); token = LBRACKET; return;
+                case ']':
+                    scanChar(); token = RBRACKET; return;
+                case '{':
+                    scanChar(); token = LBRACE; return;
+                case '}':
+                    scanChar(); token = RBRACE; return;
+                case '/':
+                    scanChar();
+                    if (ch == '/') {
+                        do {
+                            scanCommentChar();
+                        } while (ch != CR && ch != LF && bp < buflen);
+                        if (bp < buflen) {
+                            endPos = bp;
+                            processComment(CommentStyle.LINE);
+                        }
+                        break;
+                    } else if (ch == '*') {
+                        scanChar();
+                        CommentStyle style;
+                        if (ch == '*') {
+                            style = CommentStyle.JAVADOC;
+                            scanDocComment();
+                        } else {
+                            style = CommentStyle.BLOCK;
+                            while (bp < buflen) {
+                                if (ch == '*') {
+                                    scanChar();
+                                    if (ch == '/') break;
+                                } else {
+                                    scanCommentChar();
+                                }
+                            }
+                        }
+                        if (ch == '/') {
+                            scanChar();
+                            endPos = bp;
+                            processComment(style);
+                            break;
+                        } else {
+                            lexError("unclosed.comment");
+                            return;
+                        }
+                    } else if (ch == '=') {
+                        name = names.slashequals;
+                        token = SLASHEQ;
+                        scanChar();
+                    } else {
+                        name = names.slash;
+                        token = SLASH;
+                    }
+                    return;
+                case '\'':
+                    scanChar();
+                    if (ch == '\'') {
+                        lexError("empty.char.lit");
+                    } else {
+                        if (ch == CR || ch == LF)
+                            lexError(pos, "illegal.line.end.in.char.lit");
+                        scanLitChar();
+                        if (ch == '\'') {
+                            scanChar();
+                            token = CHARLITERAL;
+                        } else {
+                            lexError(pos, "unclosed.char.lit");
+                        }
+                    }
+                    return;
+                case '\"':
+                    scanChar();
+                    while (ch != '\"' && ch != CR && ch != LF && bp < buflen)
+                        scanLitChar();
+                    if (ch == '\"') {
+                        token = STRINGLITERAL;
+                        scanChar();
+                    } else {
+                        lexError(pos, "unclosed.str.lit");
+                    }
+                    return;
+                default:
+                    if (isSpecial(ch)) {
+                        scanOperator();
+                    } else {
+                        boolean isJavaIdentifierStart;
+                        if (ch < '\u0080') {
+                            // all ASCII range chars already handled, above
+                            isJavaIdentifierStart = false;
+                        } else {
+                            char high = scanSurrogates();
+                            if (high != 0) {
+                                if (sp == sbuf.length) {
+                                    putChar(high);
+                                } else {
+                                    sbuf[sp++] = high;
+                                }
+
+                                isJavaIdentifierStart = Character.isJavaIdentifierStart(
+                                    Character.toCodePoint(high, ch));
+                            } else {
+                                isJavaIdentifierStart = Character.isJavaIdentifierStart(ch);
+                            }
+                        }
+                        if (isJavaIdentifierStart) {
+                            scanIdent();
+                        } else if (bp == buflen || ch == EOI && bp+1 == buflen) { // JLS 3.5
+                            token = EOF;
+                            pos = bp = eofPos;
+                        } else {
+                            lexError("illegal.char", String.valueOf((int)ch));
+                            scanChar();
+                        }
+                    }
+                    return;
+                }
+            }
+        } finally {
+            endPos = bp;
+            if (scannerDebug)
+                System.out.println("nextToken(" + pos
+                                   + "," + endPos + ")=|" +
+                                   new String(getRawCharacters(pos, endPos))
+                                   + "|");
         }
     }
 
-    public Token split() {
-        Token[] splitTokens = token.split(tokens);
-        prevToken = splitTokens[0];
-        token = splitTokens[1];
+    /** Return the current token, set by nextToken().
+     */
+    public Token token() {
         return token;
     }
 
-    public LineMap getLineMap() {
-        return tokenizer.getLineMap();
+    /** Sets the current token.
+     */
+    public void token(Token token) {
+        this.token = token;
+    }
+
+    /** Return the current token's position: a 0-based
+     *  offset from beginning of the raw input stream
+     *  (before unicode translation)
+     */
+    public int pos() {
+        return pos;
     }
 
+    /** Return the last character position of the current token.
+     */
+    public int endPos() {
+        return endPos;
+    }
+
+    /** Return the last character position of the previous token.
+     */
+    public int prevEndPos() {
+        return prevEndPos;
+    }
+
+    /** Return the position where a lexical error occurred;
+     */
     public int errPos() {
-        return tokenizer.errPos();
+        return errPos;
     }
 
+    /** Set the position where a lexical error occurred;
+     */
     public void errPos(int pos) {
-        tokenizer.errPos(pos);
+        errPos = pos;
+    }
+
+    /** Return the name of an identifier or token for the current token.
+     */
+    public Name name() {
+        return name;
+    }
+
+    /** Return the radix of a numeric literal token.
+     */
+    public int radix() {
+        return radix;
+    }
+
+    /** Has a @deprecated been encountered in last doc comment?
+     *  This needs to be reset by client with resetDeprecatedFlag.
+     */
+    public boolean deprecatedFlag() {
+        return deprecatedFlag;
+    }
+
+    public void resetDeprecatedFlag() {
+        deprecatedFlag = false;
+    }
+
+    /**
+     * Returns the documentation string of the current token.
+     */
+    public String docComment() {
+        return null;
+    }
+
+    /**
+     * Returns a copy of the input buffer, up to its inputLength.
+     * Unicode escape sequences are not translated.
+     */
+    public char[] getRawCharacters() {
+        char[] chars = new char[buflen];
+        System.arraycopy(buf, 0, chars, 0, buflen);
+        return chars;
+    }
+
+    /**
+     * Returns a copy of a character array subset of the input buffer.
+     * The returned array begins at the <code>beginIndex</code> and
+     * extends to the character at index <code>endIndex - 1</code>.
+     * Thus the length of the substring is <code>endIndex-beginIndex</code>.
+     * This behavior is like
+     * <code>String.substring(beginIndex, endIndex)</code>.
+     * Unicode escape sequences are not translated.
+     *
+     * @param beginIndex the beginning index, inclusive.
+     * @param endIndex the ending index, exclusive.
+     * @throws IndexOutOfBounds if either offset is outside of the
+     *         array bounds
+     */
+    public char[] getRawCharacters(int beginIndex, int endIndex) {
+        int length = endIndex - beginIndex;
+        char[] chars = new char[length];
+        System.arraycopy(buf, beginIndex, chars, 0, length);
+        return chars;
+    }
+
+    public enum CommentStyle {
+        LINE,
+        BLOCK,
+        JAVADOC,
+    }
+
+    /**
+     * Called when a complete comment has been scanned. pos and endPos
+     * will mark the comment boundary.
+     */
+    protected void processComment(CommentStyle style) {
+        if (scannerDebug)
+            System.out.println("processComment(" + pos
+                               + "," + endPos + "," + style + ")=|"
+                               + new String(getRawCharacters(pos, endPos))
+                               + "|");
     }
+
+    /**
+     * Called when a complete whitespace run has been scanned. pos and endPos
+     * will mark the whitespace boundary.
+     */
+    protected void processWhiteSpace() {
+        if (scannerDebug)
+            System.out.println("processWhitespace(" + pos
+                               + "," + endPos + ")=|" +
+                               new String(getRawCharacters(pos, endPos))
+                               + "|");
+    }
+
+    /**
+     * Called when a line terminator has been processed.
+     */
+    protected void processLineTerminator() {
+        if (scannerDebug)
+            System.out.println("processTerminator(" + pos
+                               + "," + endPos + ")=|" +
+                               new String(getRawCharacters(pos, endPos))
+                               + "|");
+    }
+
+    /** Build a map for translating between line numbers and
+     * positions in the input.
+     *
+     * @return a LineMap */
+    public Position.LineMap getLineMap() {
+        return Position.makeLineMap(buf, buflen, false);
+    }
+
 }
Only in /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/parser: Token.java
Only in javac/parser: Tokens.java
Only in javac/parser: UnicodeReader.java
diff -u -r javac/processing/JavacFiler.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/processing/JavacFiler.java
--- javac/processing/JavacFiler.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/processing/JavacFiler.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -455,24 +455,9 @@
         // TODO: Only support reading resources in selected output
         // locations?  Only allow reading of non-source, non-class
         // files from the supported input locations?
-
-        // In the following, getFileForInput is the "obvious" method
-        // to use, but it does not have the "obvious" semantics for
-        // SOURCE_OUTPUT and CLASS_OUTPUT. Conversely, getFileForOutput
-        // does not have the correct semantics for any "path" location
-        // with more than one component. So, for now, we use a hybrid
-        // invocation.
-        FileObject fileObject;
-        if (location.isOutputLocation()) {
-            fileObject = fileManager.getFileForOutput(location,
-                    pkg.toString(),
-                    relativeName.toString(),
-                    null);
-        } else {
-            fileObject = fileManager.getFileForInput(location,
+        FileObject fileObject = fileManager.getFileForInput(location,
                     pkg.toString(),
                     relativeName.toString());
-        }
         if (fileObject == null) {
             String name = (pkg.length() == 0)
                     ? relativeName.toString() : (pkg + "/" + relativeName);
diff -u -r javac/processing/JavacProcessingEnvironment.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/processing/JavacProcessingEnvironment.java
--- javac/processing/JavacProcessingEnvironment.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/processing/JavacProcessingEnvironment.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,33 +25,34 @@
 
 package com.sun.tools.javac.processing;
 
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.regex.*;
+
+import java.net.URL;
 import java.io.Closeable;
 import java.io.File;
 import java.io.PrintWriter;
+import java.io.IOException;
 import java.io.StringWriter;
 import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.*;
-import java.util.regex.*;
 
 import javax.annotation.processing.*;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.PackageElement;
 import javax.lang.model.util.*;
-import javax.tools.DiagnosticListener;
 import javax.tools.JavaFileManager;
-import javax.tools.JavaFileObject;
 import javax.tools.StandardJavaFileManager;
-import static javax.tools.StandardLocation.*;
+import javax.tools.JavaFileObject;
+import javax.tools.DiagnosticListener;
 
-import com.sun.source.util.JavacTask;
 import com.sun.source.util.TaskEvent;
+import com.sun.source.util.TaskListener;
 import com.sun.tools.javac.api.JavacTaskImpl;
 import com.sun.tools.javac.api.JavacTrees;
-import com.sun.tools.javac.api.MultiTaskListener;
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.code.Symbol.*;
 import com.sun.tools.javac.file.FSInfo;
@@ -70,16 +71,19 @@
 import com.sun.tools.javac.util.ClientCodeException;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.Convert;
+import com.sun.tools.javac.util.FatalError;
 import com.sun.tools.javac.util.JCDiagnostic;
-import com.sun.tools.javac.util.JavacMessages;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.Log;
+import com.sun.tools.javac.util.JavacMessages;
 import com.sun.tools.javac.util.Name;
 import com.sun.tools.javac.util.Names;
 import com.sun.tools.javac.util.Options;
-import static com.sun.tools.javac.code.Lint.LintCategory.PROCESSING;
-import static com.sun.tools.javac.main.Option.*;
+
+import static javax.tools.StandardLocation.*;
 import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;
+import static com.sun.tools.javac.main.OptionName.*;
+import static com.sun.tools.javac.code.Lint.LintCategory.PROCESSING;
 
 /**
  * Objects of this class hold and manage the state needed to support
@@ -153,8 +157,6 @@
      */
     private JavacMessages messages;
 
-    private MultiTaskListener taskListener;
-
     private Context context;
 
     public JavacProcessingEnvironment(Context context, Iterable<? extends Processor> processors) {
@@ -183,7 +185,6 @@
         processorOptions = initProcessorOptions(context);
         unmatchedProcessorOptions = initUnmatchedProcessorOptions();
         messages = JavacMessages.instance(context);
-        taskListener = MultiTaskListener.instance(context);
         initProcessorIterator(context, processors);
     }
 
@@ -224,11 +225,6 @@
                     ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)
                     : fileManager.getClassLoader(CLASS_PATH);
 
-                if (processorClassLoader != null && processorClassLoader instanceof Closeable) {
-                    JavaCompiler compiler = JavaCompiler.instance(context);
-                    compiler.closeables = compiler.closeables.prepend((Closeable) processorClassLoader);
-                }
-
                 /*
                  * If the "-processor" option is used, search the appropriate
                  * path for the named class.  Otherwise, use a service
@@ -299,24 +295,59 @@
 
     /**
      * Use a service loader appropriate for the platform to provide an
-     * iterator over annotations processors; fails if a loader is
-     * needed but unavailable.
+     * iterator over annotations processors.  If
+     * java.util.ServiceLoader is present use it, otherwise, use
+     * sun.misc.Service, otherwise fail if a loader is needed.
      */
     private class ServiceIterator implements Iterator<Processor> {
-        private Iterator<Processor> iterator;
+        // The to-be-wrapped iterator.
+        private Iterator<?> iterator;
         private Log log;
-        private ServiceLoader<Processor> loader;
+        private Class<?> loaderClass;
+        private boolean jusl;
+        private Object loader;
 
         ServiceIterator(ClassLoader classLoader, Log log) {
+            String loadMethodName;
+
             this.log = log;
             try {
                 try {
-                    loader = ServiceLoader.load(Processor.class, classLoader);
-                    this.iterator = loader.iterator();
-                } catch (Exception e) {
-                    // Fail softly if a loader is not actually needed.
-                    this.iterator = handleServiceLoaderUnavailability("proc.no.service", null);
+                    loaderClass = Class.forName("java.util.ServiceLoader");
+                    loadMethodName = "load";
+                    jusl = true;
+                } catch (ClassNotFoundException cnfe) {
+                    try {
+                        loaderClass = Class.forName("sun.misc.Service");
+                        loadMethodName = "providers";
+                        jusl = false;
+                    } catch (ClassNotFoundException cnfe2) {
+                        // Fail softly if a loader is not actually needed.
+                        this.iterator = handleServiceLoaderUnavailability("proc.no.service",
+                                                                          null);
+                        return;
+                    }
                 }
+
+                // java.util.ServiceLoader.load or sun.misc.Service.providers
+                Method loadMethod = loaderClass.getMethod(loadMethodName,
+                                                          Class.class,
+                                                          ClassLoader.class);
+
+                Object result = loadMethod.invoke(null,
+                                                  Processor.class,
+                                                  classLoader);
+
+                // For java.util.ServiceLoader, we have to call another
+                // method to get the iterator.
+                if (jusl) {
+                    loader = result; // Store ServiceLoader to call reload later
+                    Method m = loaderClass.getMethod("iterator");
+                    result = m.invoke(result); // serviceLoader.iterator();
+                }
+
+                // The result should now be an iterator.
+                this.iterator = (Iterator<?>) result;
             } catch (Throwable t) {
                 log.error("proc.service.problem");
                 throw new Abort(t);
@@ -326,21 +357,25 @@
         public boolean hasNext() {
             try {
                 return iterator.hasNext();
-            } catch(ServiceConfigurationError sce) {
-                log.error("proc.bad.config.file", sce.getLocalizedMessage());
-                throw new Abort(sce);
             } catch (Throwable t) {
+                if ("ServiceConfigurationError".
+                    equals(t.getClass().getSimpleName())) {
+                    log.error("proc.bad.config.file", t.getLocalizedMessage());
+                }
                 throw new Abort(t);
             }
         }
 
         public Processor next() {
             try {
-                return iterator.next();
-            } catch (ServiceConfigurationError sce) {
-                log.error("proc.bad.config.file", sce.getLocalizedMessage());
-                throw new Abort(sce);
+                return (Processor)(iterator.next());
             } catch (Throwable t) {
+                if ("ServiceConfigurationError".
+                    equals(t.getClass().getSimpleName())) {
+                    log.error("proc.bad.config.file", t.getLocalizedMessage());
+                } else {
+                    log.error("proc.processor.constructor.error", t.getLocalizedMessage());
+                }
                 throw new Abort(t);
             }
         }
@@ -350,9 +385,11 @@
         }
 
         public void close() {
-            if (loader != null) {
+            if (jusl) {
                 try {
-                    loader.reload();
+                    // Call java.util.ServiceLoader.reload
+                    Method reloadMethod = loaderClass.getMethod("reload");
+                    reloadMethod.invoke(loader);
                 } catch(Exception e) {
                     ; // Ignore problems during a call to reload.
                 }
@@ -687,7 +724,7 @@
                 ps.removeSupportedOptions(unmatchedProcessorOptions);
 
                 if (printProcessorInfo || verbose) {
-                    log.printLines("x.print.processor.info",
+                    log.printNoteLines("x.print.processor.info",
                             ps.processor.getClass().getName(),
                             matchedNames.toString(),
                             processingResult);
@@ -724,7 +761,7 @@
      * Leave class public for external testing purposes.
      */
     public static class ComputeAnnotationSet extends
-        ElementScanner8<Set<TypeElement>, Set<TypeElement>> {
+        ElementScanner7<Set<TypeElement>, Set<TypeElement>> {
         final Elements elements;
 
         public ComputeAnnotationSet(Elements elements) {
@@ -975,7 +1012,8 @@
         void run(boolean lastRound, boolean errorStatus) {
             printRoundInfo(lastRound);
 
-            if (!taskListener.isEmpty())
+            TaskListener taskListener = context.get(TaskListener.class);
+            if (taskListener != null)
                 taskListener.started(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING_ROUND));
 
             try {
@@ -991,7 +1029,7 @@
                     discoverAndRunProcs(context, annotationsPresent, topLevelClasses, packageInfoFiles);
                 }
             } finally {
-                if (!taskListener.isEmpty())
+                if (taskListener != null)
                     taskListener.finished(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING_ROUND));
             }
 
@@ -1012,7 +1050,7 @@
             if (printRounds || verbose) {
                 List<ClassSymbol> tlc = lastRound ? List.<ClassSymbol>nil() : topLevelClasses;
                 Set<TypeElement> ap = lastRound ? Collections.<TypeElement>emptySet() : annotationsPresent;
-                log.printLines("x.print.rounds",
+                log.printNoteLines("x.print.rounds",
                         number,
                         "{" + tlc.toString(", ") + "}",
                         ap,
@@ -1031,10 +1069,12 @@
             Assert.checkNonNull(options);
             next.put(Options.optionsKey, options);
 
+            PrintWriter out = context.get(Log.outKey);
+            Assert.checkNonNull(out);
+            next.put(Log.outKey, out);
             Locale locale = context.get(Locale.class);
             if (locale != null)
                 next.put(Locale.class, locale);
-
             Assert.checkNonNull(messages);
             next.put(JavacMessages.messagesKey, messages);
 
@@ -1049,9 +1089,9 @@
             if (dl != null)
                 next.put(DiagnosticListener.class, dl);
 
-            MultiTaskListener mtl = context.get(MultiTaskListener.taskListenerKey);
-            if (mtl != null)
-                next.put(MultiTaskListener.taskListenerKey, mtl);
+            TaskListener tl = context.get(TaskListener.class);
+            if (tl != null)
+                next.put(TaskListener.class, tl);
 
             FSInfo fsInfo = context.get(FSInfo.class);
             if (fsInfo != null)
@@ -1068,12 +1108,9 @@
             Assert.checkNonNull(names);
             next.put(Names.namesKey, names);
 
-            Tokens tokens = Tokens.instance(context);
-            Assert.checkNonNull(tokens);
-            next.put(Tokens.tokensKey, tokens);
-
-            // propogate the log's writers directly, instead of going through context
-            Log.instance(next).setWriters(log);
+            Keywords keywords = Keywords.instance(context);
+            Assert.checkNonNull(keywords);
+            next.put(Keywords.keywordsKey, keywords);
 
             JavaCompiler oldCompiler = JavaCompiler.instance(context);
             JavaCompiler nextCompiler = JavaCompiler.instance(next);
@@ -1084,9 +1121,9 @@
             elementUtils.setContext(next);
             typeUtils.setContext(next);
 
-            JavacTaskImpl task = (JavacTaskImpl) context.get(JavacTask.class);
+            JavacTaskImpl task = context.get(JavacTaskImpl.class);
             if (task != null) {
-                next.put(JavacTask.class, task);
+                next.put(JavacTaskImpl.class, task);
                 task.updateContext(next);
             }
 
@@ -1108,6 +1145,8 @@
                                      List<JCCompilationUnit> roots,
                                      List<ClassSymbol> classSymbols,
                                      Iterable<? extends PackageSymbol> pckSymbols) {
+
+        TaskListener taskListener = context.get(TaskListener.class);
         log = Log.instance(context);
 
         Set<PackageSymbol> specifiedPackages = new LinkedHashSet<PackageSymbol>();
@@ -1178,7 +1217,7 @@
         // Free resources
         this.close();
 
-        if (!taskListener.isEmpty())
+        if (taskListener != null)
             taskListener.finished(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING));
 
         if (errorStatus) {
@@ -1213,13 +1252,21 @@
         if (discoveredProcs != null) // Make calling close idempotent
             discoveredProcs.close();
         discoveredProcs = null;
+        if (processorClassLoader != null && processorClassLoader instanceof Closeable) {
+            try {
+                ((Closeable) processorClassLoader).close();
+            } catch (IOException e) {
+                JCDiagnostic msg = diags.fragment("fatal.err.cant.close.loader");
+                throw new FatalError(msg, e);
+            }
+        }
     }
 
     private List<ClassSymbol> getTopLevelClasses(List<? extends JCCompilationUnit> units) {
         List<ClassSymbol> classes = List.nil();
         for (JCCompilationUnit unit : units) {
             for (JCTree node : unit.defs) {
-                if (node.hasTag(JCTree.Tag.CLASSDEF)) {
+                if (node.getTag() == JCTree.CLASSDEF) {
                     ClassSymbol sym = ((JCClassDecl) node).sym;
                     Assert.checkNonNull(sym);
                     classes = classes.prepend(sym);
diff -u -r javac/processing/JavacRoundEnvironment.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/processing/JavacRoundEnvironment.java
--- javac/processing/JavacRoundEnvironment.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/processing/JavacRoundEnvironment.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -125,7 +125,7 @@
         else
             throw new AssertionError("Bad implementation type for " + tm);
 
-        ElementScanner8<Set<Element>, DeclaredType> scanner =
+        ElementScanner7<Set<Element>, DeclaredType> scanner =
             new AnnotationSetScanner(result, typeUtil);
 
         for (Element element : rootElements)
@@ -136,7 +136,7 @@
 
     // Could be written as a local class inside getElementsAnnotatedWith
     private class AnnotationSetScanner extends
-        ElementScanner8<Set<Element>, DeclaredType> {
+        ElementScanner7<Set<Element>, DeclaredType> {
         // Insertion-order preserving set
         Set<Element> annotatedElements = new LinkedHashSet<Element>();
         Types typeUtil;
diff -u -r javac/processing/PrintingProcessor.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java
--- javac/processing/PrintingProcessor.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -48,7 +48,8 @@
  * deletion without notice.</b>
  */
 @SupportedAnnotationTypes("*")
-@SupportedSourceVersion(SourceVersion.RELEASE_8)
+// TODO: Change to version 7 based visitors when available
+@SupportedSourceVersion(SourceVersion.RELEASE_7)
 public class PrintingProcessor extends AbstractProcessor {
     PrintWriter writer;
 
@@ -82,7 +83,7 @@
      * Used for the -Xprint option and called by Elements.printElements
      */
     public static class PrintingElementVisitor
-        extends SimpleElementVisitor8<PrintingElementVisitor, Boolean> {
+        extends SimpleElementVisitor7<PrintingElementVisitor, Boolean> {
         int indentation; // Indentation level;
         final PrintWriter writer;
         final Elements elementUtils;
diff -u -r javac/resources/compiler.properties /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/resources/compiler.properties
--- javac/resources/compiler.properties	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/resources/compiler.properties	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -68,13 +68,9 @@
 compiler.err.already.annotated=\
     {0} {1} has already been annotated
 
-# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol
+# 0: symbol, 1: symbol
 compiler.err.already.defined=\
-    {0} {1} is already defined in {2} {3}
-
-# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol kind, 4: symbol
-compiler.err.already.defined.in.clinit=\
-    {0} {1} is already defined in {2} of {3} {4}
+    {0} is already defined in {1}
 
 # 0: string
 compiler.err.already.defined.single.import=\
@@ -134,6 +130,12 @@
 compiler.err.array.req.but.found=\
     array required, but {0} found
 
+compiler.err.assignment.from.super-bound=\
+    assigning from wildcard {0}
+
+compiler.err.assignment.to.extends-bound=\
+    assigning to wildcard {0}
+
 compiler.err.attribute.value.must.be.constant=\
     attribute value must be constant
 
@@ -196,9 +198,6 @@
 compiler.err.clash.with.pkg.of.same.name=\
     {0} {1} clashes with package of same name
 
-compiler.err.class.not.allowed=\
-    class, interface or enum declaration not allowed here
-
 compiler.err.const.expr.req=\
     constant expression required
 
@@ -220,6 +219,9 @@
 compiler.err.no.superclass=\
     {0} has no superclass
 
+compiler.err.wrong.target.for.polymorphic.signature.definition=\
+    MethodHandle API building requires -target 7 runtimes or better; current is -target {0}
+
 # 0: symbol, 1: type, 2: symbol, 3: type, 4: unused
 compiler.err.concrete.inheritance.conflict=\
     methods {0} from {1} and {2} from {3} are inherited with the same signature
@@ -378,9 +380,6 @@
 compiler.err.illegal.underscore=\
     illegal underscore
 
-compiler.err.illegal.dot=\
-    illegal ''.''
-
 # 0: symbol
 compiler.err.illegal.qual.not.icls=\
     illegal qualifier; {0} is not an inner class
@@ -388,9 +387,6 @@
 compiler.err.illegal.start.of.expr=\
     illegal start of expression
 
-compiler.err.illegal.start.of.stmt=\
-    illegal start of statement
-
 compiler.err.illegal.start.of.type=\
     illegal start of type
 
@@ -452,9 +448,6 @@
 compiler.err.varargs.and.old.array.syntax=\
     legacy array notation not allowed on variable-arity parameter
 
-compiler.err.variable.not.allowed=\
-    variable declaration not allowed here
-
 # 0: name
 compiler.err.label.already.in.use=\
     label {0} already in use
@@ -469,9 +462,6 @@
 compiler.err.cannot.create.array.with.type.arguments=\
     cannot create array with type arguments
 
-compiler.err.cannot.create.array.with.diamond=\
-    cannot create array with ''<>''
-
 #
 # limits.  We don't give the limits in the diagnostic because we expect
 # them to change, yet we want to use the same diagnostic.  These are all
@@ -647,7 +637,8 @@
     Class names, ''{0}'', are only accepted if annotation processing is explicitly requested
 
 compiler.err.proc.no.service=\
-    A ServiceLoader was not usable and is required for annotation processing.
+    A service loader class could not be found.\n\
+    Either java.util.ServiceLoader or sun.misc.Service must be available.
 
 compiler.err.proc.processor.bad.option.name=\
     Bad option name ''{0}'' provided by processor ''{1}''
@@ -656,6 +647,9 @@
 compiler.err.proc.processor.cant.instantiate=\
     Could not instantiate an instance of processor ''{0}''
 
+compiler.err.proc.processor.constructor.error=\
+    Exception thrown while constructing Processor object: {0}
+
 # 0: string
 compiler.err.proc.processor.not.found=\
     Annotation processor ''{0}'' not found
@@ -779,23 +773,25 @@
 compiler.err.undef.label=\
     undefined label: {0}
 
-# 0: list of type, 1: message segment
-compiler.misc.invalid.inferred.types=\
-    invalid inferred types for {0}\n\
+compiler.err.undetermined.type=\
+    cannot infer type arguments for {0}
+
+# 0: type, 1: message segment
+compiler.err.undetermined.type.1=\
+    cannot infer type arguments for {0};\n\
     reason: {1}
 
+# 0: list of type, 1: message segment
+compiler.err.invalid.inferred.types=\
+    invalid inferred types for {0}; {1}
+
 # 0: message segment, 1: unused
 compiler.err.cant.apply.diamond=\
     cannot infer type arguments for {0}
 
-# 0: message segment or type, 1: message segment
+# 0: message segment, 1: message segment
 compiler.err.cant.apply.diamond.1=\
-    cannot infer type arguments for {0}\n\
-    reason: {1}
-
-# 0: message segment or type, 1: message segment
-compiler.misc.cant.apply.diamond.1=\
-    cannot infer type arguments for {0}\n\
+    cannot infer type arguments for {0};\n\
     reason: {1}
 
 compiler.err.unreachable.stmt=\
@@ -855,7 +851,7 @@
 compiler.misc.varargs.trustme.on.virtual.varargs=\
     Instance method {0} is not final.
 
-# 0: type, 1: symbol kind, 2: symbol
+# 0: type, 1: kind, 2: symbol
 compiler.misc.inaccessible.varargs.type=\
     formal varargs element type {0} is not accessible from {1} {2}
 
@@ -896,8 +892,8 @@
 compiler.misc.fatal.err.cant.locate.ctor=\
     Fatal Error: Unable to find constructor for {0}
 
-compiler.misc.fatal.err.cant.close=\
-    Fatal Error: Cannot close compiler resources
+compiler.misc.fatal.err.cant.close.loader=\
+    Fatal Error: Cannot close class loader for annotation processors
 
 #####
 
@@ -1501,15 +1497,11 @@
 
 #####
 
-# 0: type, 1: type
+# 0: message segment, 1: type, 2: type
 compiler.err.prob.found.req=\
-    incompatible types\n\
-    required: {1}\n\
-    found: {0}
-
-# 0: message segment
-compiler.err.prob.found.req.1=\
-    incompatible types: {0}
+    {0}\n\
+    required: {2}\n\
+    found:    {1}
 
 # 0: message segment, 1: type, 2: type
 compiler.warn.prob.found.req=\
@@ -1517,9 +1509,22 @@
     required: {2}\n\
     found:    {1}
 
-# 0: type, 1: type
+compiler.err.prob.found.req.1=\
+    {0} {3}\n\
+    required: {2}\n\
+    found:    {1}
+
+## The following are all possible strings for the first argument ({0}) of the
+## above strings.
+compiler.misc.incompatible.types=\
+    incompatible types
+
+# 0: message segment
+compiler.misc.incompatible.types.1=\
+    incompatible types; {0}
+
 compiler.misc.inconvertible.types=\
-    {0} cannot be converted to {1}
+    inconvertible types
 
 compiler.misc.possible.loss.of.precision=\
     possible loss of precision
@@ -1534,15 +1539,19 @@
 compiler.misc.unchecked.cast.to.type=\
     unchecked cast
 
+compiler.misc.assignment.from.super-bound=\
+    assignment from super-bound type {0}
+
+compiler.misc.assignment.to.extends-bound=\
+    assignment to extends-bound type {0}
+
 # compiler.err.star.expected=\
 #     ''*'' expected
 # compiler.err.no.elem.type=\
 #     \[\*\] cannot have a type
 
-# 0: type
 compiler.misc.try.not.applicable.to.type=\
-    try-with-resources not applicable to variable type {0}\n\
-    (expected a variable of type java.lang.AutoCloseable)
+    try-with-resources not applicable to variable type
 
 #####
 
@@ -1577,11 +1586,11 @@
 
 ## The following are all possible strings for the last argument of all those
 ## diagnostics whose key ends in ".1"
-
-# 0: type, 1: message segment
 compiler.misc.undetermined.type=\
-    cannot infer type arguments for {0}\n\
-    reason: {1}
+    undetermined type
+
+compiler.misc.type.variable.has.undetermined.type=\
+    type variable {0} has undetermined type
 
 # 0: type, 1: list of type
 compiler.misc.no.unique.maximal.instance.exists=\
@@ -1590,10 +1599,6 @@
 compiler.misc.no.unique.minimal.instance.exists=\
     no unique minimal instance exists for type variable {0} with lower bounds {1}
 
-# 0: type, 1: list of type
-compiler.misc.incompatible.upper.bounds=\
-    inference variable {0} has incompatible upper bounds {1}
-
 # 0: list of type, 1: type, 2: type
 compiler.misc.infer.no.conforming.instance.exists=\
     no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}
@@ -1605,27 +1610,11 @@
 compiler.misc.infer.arg.length.mismatch=\
     cannot instantiate from arguments because actual and formal argument lists differ in length
 
-# 0: list of type, 1: type, 2: type
-compiler.misc.infer.varargs.argument.mismatch=\
-    no instance(s) of type variable(s) {0} exist so that argument type {1} conforms to vararg element type {2}
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.upper.bounds=\
-    inferred type does not conform to upper bound(s)\n\
-    inferred: {0}\n\
-    upper bound(s): {1}
-
 # 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.lower.bounds=\
-    inferred type does not conform to lower bound(s)\n\
+compiler.misc.inferred.do.not.conform.to.bounds=\
+    inferred type does not conform to declared bound(s)\n\
     inferred: {0}\n\
-    lower bound(s): {1}
-
-# 0: type, 1: list of type
-compiler.misc.inferred.do.not.conform.to.eq.bounds=\
-    inferred type does not conform to equality constraint(s)\n\
-    inferred: {0}\n\
-    equality constraints(s): {1}
+    bound(s): {1}
 
 # 0: symbol
 compiler.misc.diamond=\
@@ -1635,7 +1624,6 @@
 compiler.misc.diamond.non.generic=\
     cannot use ''<>'' with non-generic class {0}
 
-# 0: unused
 compiler.misc.diamond.and.explicit.params=\
     cannot use ''<>'' with explicit type parameters for constructor
 
@@ -1717,7 +1705,7 @@
 ## The second argument {1} is the location name
 ## The third argument {2} is the location type (only when {1} is a variable name)
 
-# 0: symbol kind, 1: type or symbol, 2: unused
+# 0: symbol kind, 1: symbol, 2: unused
 compiler.misc.location=\
     {0} {1}
 
@@ -1766,12 +1754,6 @@
 compiler.misc.kindname.package=\
     package
 
-compiler.misc.kindname.static.init=\
-    static initializer
-
-compiler.misc.kindname.instance.init=\
-    instance initializer
-
 #####
 
 compiler.misc.no.args=\
@@ -1852,7 +1834,6 @@
 compiler.misc.varargs.clash.with=\
     {0} in {1} overrides {2} in {3}
 
-# 0: unused
 compiler.misc.diamond.and.anon.class=\
     cannot use ''<>'' with anonymous inner classes
 
@@ -1949,65 +1930,6 @@
     strings in switch are not supported in -source {0}\n\
     (use -source 7 or higher to enable strings in switch)
 
-# 0: string
-compiler.err.lambda.not.supported.in.source=\
-    lambda expressions are not supported in -source {0}\n\
-    (use -source 8 or higher to enable lambda expressions)
-
-# 0: string
-compiler.err.method.references.not.supported.in.source=\
-    method references are not supported in -source {0}\n\
-    (use -source 8 or higher to enable method references)
-
-########################################
-# Diagnostics for verbose resolution
-# used by Resolve (debug only)
-########################################
-
-# 0: number, 1: symbol, 2: unused
-compiler.misc.applicable.method.found=\
-    #{0} applicable method found: {1}
-
-# 0: number, 1: symbol, 2: message segment
-compiler.misc.applicable.method.found.1=\
-    #{0} applicable method found: {1}\n\
-    ({2})
-
-# 0: number, 1: symbol, 2: message segment
-compiler.misc.not.applicable.method.found=\
-    #{0} not applicable method found: {1}\n\
-    ({2})
-
-# 0: type
-compiler.misc.full.inst.sig=\
-    fully instantiated to: {0}
-
-# 0: type
-compiler.misc.partial.inst.sig=\
-    partially instantiated to: {0}
-
-# 0: name, 1: symbol, 2: number, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
-compiler.note.verbose.resolve.multi=\
-    resolving method {0} in type {1} to candidate {2}\n\
-    phase: {3}\n\
-    with actuals: {4}\n\
-    with type-args: {5}\n\
-    candidates:
-
-# 0: name, 1: symbol, 2: unused, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
-compiler.note.verbose.resolve.multi.1=\
-    erroneous resolution for method {0} in type {1}\n\
-    phase: {3}\n\
-    with actuals: {4}\n\
-    with type-args: {5}\n\
-    candidates:
-
-# 0: symbol, 1: type, 2: type
-compiler.note.deferred.method.inst=\
-    Deferred instantiation of method {0}\n\
-    instantiated signature: {1}\n\
-    target-type: {2}
-
 ########################################
 # Diagnostics for where clause implementation
 # used by the RichDiagnosticFormatter.
@@ -2051,16 +1973,9 @@
 
 # compact where clause for type variable: contains the kindname ({2}) and location ({3})
 # in which the typevar has been declared
-# 0: type, 1: list of type, 2: symbol kind, 3: symbol
 compiler.misc.where.typevar.1=\
     {0} declared in {2} {3}
 
-# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
-# Since a fresh type-variable is synthetic - there's no location/kindname here.
-# 0: type, 1: list of type
-compiler.misc.where.fresh.typevar=\
-    {0} extends {1}
-
 # where clause for type variable: contains all the upper bound(s) ('extends {1}')
 # of this intersection type
 # 0: type, 1: list of type
diff -u -r javac/resources/javac.properties /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/resources/javac.properties
--- javac/resources/javac.properties	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/resources/javac.properties	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -61,8 +61,6 @@
     Specify where to place generated class files
 javac.opt.sourceDest=\
     Specify where to place generated source files
-javac.opt.headerDest=\
-    Specify where to place generated native header files
 javac.opt.J=\
     Pass <flag> directly to the runtime system
 javac.opt.encoding=\
diff -u -r javac/tree/JCTree.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/JCTree.java
--- javac/tree/JCTree.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/JCTree.java	2011-06-27 15:21:47.000000000 -0500
@@ -39,13 +39,9 @@
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.code.Scope.*;
 import com.sun.tools.javac.code.Symbol.*;
-import com.sun.tools.javac.parser.EndPosTable;
 import com.sun.source.tree.*;
-import com.sun.source.tree.LambdaExpressionTree.BodyKind;
-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
 
 import static com.sun.tools.javac.code.BoundKind.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
 
 /**
  * Root class for abstract syntax tree nodes. It provides definitions
@@ -83,297 +79,253 @@
 public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
 
     /* Tree tag values, identifying kinds of trees */
-    public enum Tag{
-        /** For methods that return an invalid tag if a given condition is not met
-         */
-        NO_TAG,
-
-        /** Toplevel nodes, of type TopLevel, representing entire source files.
-        */
-        TOPLEVEL,
-
-        /** Import clauses, of type Import.
-         */
-        IMPORT,
-
-        /** Class definitions, of type ClassDef.
-         */
-        CLASSDEF,
-
-        /** Method definitions, of type MethodDef.
-         */
-        METHODDEF,
-
-        /** Variable definitions, of type VarDef.
-         */
-        VARDEF,
-
-        /** The no-op statement ";", of type Skip
-         */
-        SKIP,
-
-        /** Blocks, of type Block.
-         */
-        BLOCK,
-
-        /** Do-while loops, of type DoLoop.
-         */
-        DOLOOP,
-
-        /** While-loops, of type WhileLoop.
-         */
-        WHILELOOP,
-
-        /** For-loops, of type ForLoop.
-         */
-        FORLOOP,
-
-        /** Foreach-loops, of type ForeachLoop.
-         */
-        FOREACHLOOP,
-
-        /** Labelled statements, of type Labelled.
-         */
-        LABELLED,
-
-        /** Switch statements, of type Switch.
-         */
-        SWITCH,
-
-        /** Case parts in switch statements, of type Case.
-         */
-        CASE,
-
-        /** Synchronized statements, of type Synchonized.
-         */
-        SYNCHRONIZED,
-
-        /** Try statements, of type Try.
-         */
-        TRY,
-
-        /** Catch clauses in try statements, of type Catch.
-         */
-        CATCH,
-
-        /** Conditional expressions, of type Conditional.
-         */
-        CONDEXPR,
-
-        /** Conditional statements, of type If.
-         */
-        IF,
-
-        /** Expression statements, of type Exec.
-         */
-        EXEC,
-
-        /** Break statements, of type Break.
-         */
-        BREAK,
-
-        /** Continue statements, of type Continue.
-         */
-        CONTINUE,
-
-        /** Return statements, of type Return.
-         */
-        RETURN,
-
-        /** Throw statements, of type Throw.
-         */
-        THROW,
-
-        /** Assert statements, of type Assert.
-         */
-        ASSERT,
-
-        /** Method invocation expressions, of type Apply.
-         */
-        APPLY,
-
-        /** Class instance creation expressions, of type NewClass.
-         */
-        NEWCLASS,
-
-        /** Array creation expressions, of type NewArray.
-         */
-        NEWARRAY,
-
-        /** Lambda expression, of type Lambda.
-         */
-        LAMBDA,
-
-        /** Parenthesized subexpressions, of type Parens.
-         */
-        PARENS,
-
-        /** Assignment expressions, of type Assign.
-         */
-        ASSIGN,
-
-        /** Type cast expressions, of type TypeCast.
-         */
-        TYPECAST,
-
-        /** Type test expressions, of type TypeTest.
-         */
-        TYPETEST,
-
-        /** Indexed array expressions, of type Indexed.
-         */
-        INDEXED,
-
-        /** Selections, of type Select.
-         */
-        SELECT,
-
-        /** Member references, of type Reference.
-         */
-        REFERENCE,
-
-        /** Simple identifiers, of type Ident.
-         */
-        IDENT,
-
-        /** Literals, of type Literal.
-         */
-        LITERAL,
-
-        /** Basic type identifiers, of type TypeIdent.
-         */
-        TYPEIDENT,
-
-        /** Array types, of type TypeArray.
-         */
-        TYPEARRAY,
-
-        /** Parameterized types, of type TypeApply.
-         */
-        TYPEAPPLY,
-
-        /** Union types, of type TypeUnion
-         */
-        TYPEUNION,
-
-        /** Formal type parameters, of type TypeParameter.
-         */
-        TYPEPARAMETER,
-
-        /** Type argument.
-         */
-        WILDCARD,
-
-        /** Bound kind: extends, super, exact, or unbound
-         */
-        TYPEBOUNDKIND,
-
-        /** metadata: Annotation.
-         */
-        ANNOTATION,
-
-        /** metadata: Modifiers
-         */
-        MODIFIERS,
-
-        ANNOTATED_TYPE,
-
-        /** Error trees, of type Erroneous.
-         */
-        ERRONEOUS,
-
-        /** Unary operators, of type Unary.
-         */
-        POS,                             // +
-        NEG,                             // -
-        NOT,                             // !
-        COMPL,                           // ~
-        PREINC,                          // ++ _
-        PREDEC,                          // -- _
-        POSTINC,                         // _ ++
-        POSTDEC,                         // _ --
-
-        /** unary operator for null reference checks, only used internally.
-         */
-        NULLCHK,
-
-        /** Binary operators, of type Binary.
-         */
-        OR,                              // ||
-        AND,                             // &&
-        BITOR,                           // |
-        BITXOR,                          // ^
-        BITAND,                          // &
-        EQ,                              // ==
-        NE,                              // !=
-        LT,                              // <
-        GT,                              // >
-        LE,                              // <=
-        GE,                              // >=
-        SL,                              // <<
-        SR,                              // >>
-        USR,                             // >>>
-        PLUS,                            // +
-        MINUS,                           // -
-        MUL,                             // *
-        DIV,                             // /
-        MOD,                             // %
-
-        /** Assignment operators, of type Assignop.
-         */
-        BITOR_ASG(BITOR),                // |=
-        BITXOR_ASG(BITXOR),              // ^=
-        BITAND_ASG(BITAND),              // &=
-
-        SL_ASG(SL),                      // <<=
-        SR_ASG(SR),                      // >>=
-        USR_ASG(USR),                    // >>>=
-        PLUS_ASG(PLUS),                  // +=
-        MINUS_ASG(MINUS),                // -=
-        MUL_ASG(MUL),                    // *=
-        DIV_ASG(DIV),                    // /=
-        MOD_ASG(MOD),                    // %=
-
-        /** A synthetic let expression, of type LetExpr.
-         */
-        LETEXPR;                         // ala scheme
-
-        private Tag noAssignTag;
-
-        private static int numberOfOperators = MOD.ordinal() - POS.ordinal() + 1;
-
-        private Tag(Tag noAssignTag) {
-            this.noAssignTag = noAssignTag;
-        }
-
-        private Tag() { }
-
-        public static int getNumberOfOperators() {
-            return numberOfOperators;
-        }
-
-        public Tag noAssignOp() {
-            if (noAssignTag != null)
-                return noAssignTag;
-            throw new AssertionError("noAssignOp() method is not available for non assignment tags");
-        }
-
-        public boolean isPostUnaryOp() {
-            return (this == POSTINC || this == POSTDEC);
-        }
-
-        public boolean isIncOrDecUnaryOp() {
-            return (this == PREINC || this == PREDEC || this == POSTINC || this == POSTDEC);
-        }
 
-        public boolean isAssignop() {
-            return noAssignTag != null;
-        }
+    /** Toplevel nodes, of type TopLevel, representing entire source files.
+     */
+    public static final int  TOPLEVEL = 1;
 
-        public int operatorIndex() {
-            return (this.ordinal() - POS.ordinal());
-        }
-    }
+    /** Import clauses, of type Import.
+     */
+    public static final int IMPORT = TOPLEVEL + 1;
+
+    /** Class definitions, of type ClassDef.
+     */
+    public static final int CLASSDEF = IMPORT + 1;
+
+    /** Method definitions, of type MethodDef.
+     */
+    public static final int METHODDEF = CLASSDEF + 1;
+
+    /** Variable definitions, of type VarDef.
+     */
+    public static final int VARDEF = METHODDEF + 1;
+
+    /** The no-op statement ";", of type Skip
+     */
+    public static final int SKIP = VARDEF + 1;
+
+    /** Blocks, of type Block.
+     */
+    public static final int BLOCK = SKIP + 1;
+
+    /** Do-while loops, of type DoLoop.
+     */
+    public static final int DOLOOP = BLOCK + 1;
+
+    /** While-loops, of type WhileLoop.
+     */
+    public static final int WHILELOOP = DOLOOP + 1;
+
+    /** For-loops, of type ForLoop.
+     */
+    public static final int FORLOOP = WHILELOOP + 1;
+
+    /** Foreach-loops, of type ForeachLoop.
+     */
+    public static final int FOREACHLOOP = FORLOOP + 1;
+
+    /** Labelled statements, of type Labelled.
+     */
+    public static final int LABELLED = FOREACHLOOP + 1;
+
+    /** Switch statements, of type Switch.
+     */
+    public static final int SWITCH = LABELLED + 1;
+
+    /** Case parts in switch statements, of type Case.
+     */
+    public static final int CASE = SWITCH + 1;
+
+    /** Synchronized statements, of type Synchonized.
+     */
+    public static final int SYNCHRONIZED = CASE + 1;
+
+    /** Try statements, of type Try.
+     */
+    public static final int TRY = SYNCHRONIZED + 1;
+
+    /** Catch clauses in try statements, of type Catch.
+     */
+    public static final int CATCH = TRY + 1;
+
+    /** Conditional expressions, of type Conditional.
+     */
+    public static final int CONDEXPR = CATCH + 1;
+
+    /** Conditional statements, of type If.
+     */
+    public static final int IF = CONDEXPR + 1;
+
+    /** Expression statements, of type Exec.
+     */
+    public static final int EXEC = IF + 1;
+
+    /** Break statements, of type Break.
+     */
+    public static final int BREAK = EXEC + 1;
+
+    /** Continue statements, of type Continue.
+     */
+    public static final int CONTINUE = BREAK + 1;
+
+    /** Return statements, of type Return.
+     */
+    public static final int RETURN = CONTINUE + 1;
+
+    /** Throw statements, of type Throw.
+     */
+    public static final int THROW = RETURN + 1;
+
+    /** Assert statements, of type Assert.
+     */
+    public static final int ASSERT = THROW + 1;
+
+    /** Method invocation expressions, of type Apply.
+     */
+    public static final int APPLY = ASSERT + 1;
+
+    /** Class instance creation expressions, of type NewClass.
+     */
+    public static final int NEWCLASS = APPLY + 1;
+
+    /** Array creation expressions, of type NewArray.
+     */
+    public static final int NEWARRAY = NEWCLASS + 1;
+
+    /** Parenthesized subexpressions, of type Parens.
+     */
+    public static final int PARENS = NEWARRAY + 1;
+
+    /** Assignment expressions, of type Assign.
+     */
+    public static final int ASSIGN = PARENS + 1;
+
+    /** Type cast expressions, of type TypeCast.
+     */
+    public static final int TYPECAST = ASSIGN + 1;
+
+    /** Type test expressions, of type TypeTest.
+     */
+    public static final int TYPETEST = TYPECAST + 1;
+
+    /** Indexed array expressions, of type Indexed.
+     */
+    public static final int INDEXED = TYPETEST + 1;
+
+    /** Selections, of type Select.
+     */
+    public static final int SELECT = INDEXED + 1;
+
+    /** Simple identifiers, of type Ident.
+     */
+    public static final int IDENT = SELECT + 1;
+
+    /** Literals, of type Literal.
+     */
+    public static final int LITERAL = IDENT + 1;
+
+    /** Basic type identifiers, of type TypeIdent.
+     */
+    public static final int TYPEIDENT = LITERAL + 1;
+
+    /** Array types, of type TypeArray.
+     */
+    public static final int TYPEARRAY = TYPEIDENT + 1;
+
+    /** Parameterized types, of type TypeApply.
+     */
+    public static final int TYPEAPPLY = TYPEARRAY + 1;
+
+    /** Union types, of type TypeUnion
+     */
+    public static final int TYPEUNION = TYPEAPPLY + 1;
+
+    /** Formal type parameters, of type TypeParameter.
+     */
+    public static final int TYPEPARAMETER = TYPEUNION + 1;
+
+    /** Type argument.
+     */
+    public static final int WILDCARD = TYPEPARAMETER + 1;
+
+    /** Bound kind: extends, super, exact, or unbound
+     */
+    public static final int TYPEBOUNDKIND = WILDCARD + 1;
+
+    /** metadata: Annotation.
+     */
+    public static final int ANNOTATION = TYPEBOUNDKIND + 1;
+
+    /** metadata: Modifiers
+     */
+    public static final int MODIFIERS = ANNOTATION + 1;
+
+    public static final int ANNOTATED_TYPE = MODIFIERS + 1;
+
+    /** Error trees, of type Erroneous.
+     */
+    public static final int ERRONEOUS = ANNOTATED_TYPE + 1;
+
+    /** Unary operators, of type Unary.
+     */
+    public static final int POS = ERRONEOUS + 1;             // +
+    public static final int NEG = POS + 1;                   // -
+    public static final int NOT = NEG + 1;                   // !
+    public static final int COMPL = NOT + 1;                 // ~
+    public static final int PREINC = COMPL + 1;              // ++ _
+    public static final int PREDEC = PREINC + 1;             // -- _
+    public static final int POSTINC = PREDEC + 1;            // _ ++
+    public static final int POSTDEC = POSTINC + 1;           // _ --
+
+    /** unary operator for null reference checks, only used internally.
+     */
+    public static final int NULLCHK = POSTDEC + 1;
+
+    /** Binary operators, of type Binary.
+     */
+    public static final int OR = NULLCHK + 1;                // ||
+    public static final int AND = OR + 1;                    // &&
+    public static final int BITOR = AND + 1;                 // |
+    public static final int BITXOR = BITOR + 1;              // ^
+    public static final int BITAND = BITXOR + 1;             // &
+    public static final int EQ = BITAND + 1;                 // ==
+    public static final int NE = EQ + 1;                     // !=
+    public static final int LT = NE + 1;                     // <
+    public static final int GT = LT + 1;                     // >
+    public static final int LE = GT + 1;                     // <=
+    public static final int GE = LE + 1;                     // >=
+    public static final int SL = GE + 1;                     // <<
+    public static final int SR = SL + 1;                     // >>
+    public static final int USR = SR + 1;                    // >>>
+    public static final int PLUS = USR + 1;                  // +
+    public static final int MINUS = PLUS + 1;                // -
+    public static final int MUL = MINUS + 1;                 // *
+    public static final int DIV = MUL + 1;                   // /
+    public static final int MOD = DIV + 1;                   // %
+
+    /** Assignment operators, of type Assignop.
+     */
+    public static final int BITOR_ASG = MOD + 1;             // |=
+    public static final int BITXOR_ASG = BITOR_ASG + 1;      // ^=
+    public static final int BITAND_ASG = BITXOR_ASG + 1;     // &=
+
+    public static final int SL_ASG = SL + BITOR_ASG - BITOR; // <<=
+    public static final int SR_ASG = SL_ASG + 1;             // >>=
+    public static final int USR_ASG = SR_ASG + 1;            // >>>=
+    public static final int PLUS_ASG = USR_ASG + 1;          // +=
+    public static final int MINUS_ASG = PLUS_ASG + 1;        // -=
+    public static final int MUL_ASG = MINUS_ASG + 1;         // *=
+    public static final int DIV_ASG = MUL_ASG + 1;           // /=
+    public static final int MOD_ASG = DIV_ASG + 1;           // %=
+
+    /** A synthetic let expression, of type LetExpr.
+     */
+    public static final int LETEXPR = MOD_ASG + 1;           // ala scheme
+
+
+    /** The offset between assignment operators and normal operators.
+     */
+    public static final int ASGOffset = BITOR_ASG - BITOR;
 
     /* The (encoded) position in the source file. @see util.Position.
      */
@@ -385,13 +337,7 @@
 
     /* The tag of this node -- one of the constants declared above.
      */
-    public abstract Tag getTag();
-
-    /* Returns true if the tag of this node is equals to tag.
-     */
-    public boolean hasTag(Tag tag) {
-        return tag == getTag();
-    }
+    public abstract int getTag();
 
     /** Convert a tree to a pretty-printed string. */
     @Override
@@ -461,7 +407,7 @@
     }
 
     // for default DiagnosticPosition
-    public int getEndPosition(EndPosTable endPosTable) {
+    public int getEndPosition(Map<JCTree, Integer> endPosTable) {
         return TreeInfo.getEndPos(this, endPosTable);
     }
 
@@ -478,7 +424,7 @@
      * @param docComments      A hashtable that stores all documentation comments
      *                         indexed by the tree nodes they refer to.
      *                         defined only if option -s is set.
-     * @param endPositions     An object encapsulating ending positions of source
+     * @param endPositions     A hashtable that stores ending positions of source
      *                         ranges indexed by the tree nodes they belong to.
      *                         Defined only if option -Xjcov is set.
      */
@@ -490,9 +436,10 @@
         public PackageSymbol packge;
         public ImportScope namedImportScope;
         public StarImportScope starImportScope;
+        public long flags;
         public Position.LineMap lineMap = null;
         public Map<JCTree, String> docComments = null;
-        public EndPosTable endPositions = null;
+        public Map<JCTree, Integer> endPositions = null;
         protected JCCompilationUnit(List<JCAnnotation> packageAnnotations,
                         JCExpression pid,
                         List<JCTree> defs,
@@ -518,9 +465,10 @@
         public List<JCImport> getImports() {
             ListBuffer<JCImport> imports = new ListBuffer<JCImport>();
             for (JCTree tree : defs) {
-                if (tree.hasTag(IMPORT))
+                int tag = tree.getTag();
+                if (tag == IMPORT)
                     imports.append((JCImport)tree);
-                else if (!tree.hasTag(SKIP))
+                else if (tag != SKIP)
                     break;
             }
             return imports.toList();
@@ -535,7 +483,7 @@
         public List<JCTree> getTypeDecls() {
             List<JCTree> typeDefs;
             for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)
-                if (!typeDefs.head.hasTag(IMPORT))
+                if (typeDefs.head.getTag() != IMPORT)
                     break;
             return typeDefs;
         }
@@ -545,7 +493,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TOPLEVEL;
         }
     }
@@ -574,7 +522,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return IMPORT;
         }
     }
@@ -671,7 +619,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return CLASSDEF;
         }
     }
@@ -743,7 +691,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return METHODDEF;
         }
   }
@@ -789,7 +737,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return VARDEF;
         }
     }
@@ -810,7 +758,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return SKIP;
         }
     }
@@ -843,7 +791,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return BLOCK;
         }
     }
@@ -870,7 +818,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return DOLOOP;
         }
     }
@@ -897,7 +845,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return WHILELOOP;
         }
     }
@@ -938,7 +886,7 @@
         }
 
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return FORLOOP;
         }
     }
@@ -967,7 +915,7 @@
             return v.visitEnhancedForLoop(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return FOREACHLOOP;
         }
     }
@@ -992,7 +940,7 @@
             return v.visitLabeledStatement(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return LABELLED;
         }
     }
@@ -1018,7 +966,7 @@
             return v.visitSwitch(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return SWITCH;
         }
     }
@@ -1044,7 +992,7 @@
             return v.visitCase(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return CASE;
         }
     }
@@ -1070,7 +1018,7 @@
             return v.visitSynchronized(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return SYNCHRONIZED;
         }
     }
@@ -1083,7 +1031,6 @@
         public List<JCCatch> catchers;
         public JCBlock finalizer;
         public List<JCTree> resources;
-        public boolean finallyCanCompleteNormally;
         protected JCTry(List<JCTree> resources,
                         JCBlock body,
                         List<JCCatch> catchers,
@@ -1111,7 +1058,7 @@
             return resources;
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TRY;
         }
     }
@@ -1137,7 +1084,7 @@
             return v.visitCatch(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return CATCH;
         }
     }
@@ -1169,7 +1116,7 @@
             return v.visitConditionalExpression(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return CONDEXPR;
         }
     }
@@ -1201,7 +1148,7 @@
             return v.visitIf(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return IF;
         }
     }
@@ -1226,24 +1173,9 @@
             return v.visitExpressionStatement(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return EXEC;
         }
-
-        /** Convert a expression-statement tree to a pretty-printed string. */
-        @Override
-        public String toString() {
-            StringWriter s = new StringWriter();
-            try {
-                new Pretty(s, false).printStat(this);
-            }
-            catch (IOException e) {
-                // should never happen, because StringWriter is defined
-                // never to throw any IOExceptions
-                throw new AssertionError(e);
-            }
-            return s.toString();
-        }
     }
 
     /**
@@ -1266,7 +1198,7 @@
             return v.visitBreak(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return BREAK;
         }
     }
@@ -1291,7 +1223,7 @@
             return v.visitContinue(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return CONTINUE;
         }
     }
@@ -1314,7 +1246,7 @@
             return v.visitReturn(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return RETURN;
         }
     }
@@ -1337,7 +1269,7 @@
             return v.visitThrow(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return THROW;
         }
     }
@@ -1363,7 +1295,7 @@
             return v.visitAssert(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return ASSERT;
         }
     }
@@ -1406,7 +1338,7 @@
             return this;
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return(APPLY);
         }
     }
@@ -1456,7 +1388,7 @@
             return v.visitNewClass(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return NEWCLASS;
         }
     }
@@ -1492,62 +1424,12 @@
             return v.visitNewArray(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return NEWARRAY;
         }
     }
 
     /**
-     * A lambda expression.
-     */
-    public static class JCLambda extends JCExpression implements LambdaExpressionTree {
-
-        public List<JCVariableDecl> params;
-        public JCTree body;
-        public Type targetType;
-        public boolean canCompleteNormally = true;
-        public List<Type> inferredThrownTypes;
-
-        public JCLambda(List<JCVariableDecl> params,
-                        JCTree body) {
-            this.params = params;
-            this.body = body;
-        }
-        @Override
-        public Tag getTag() {
-            return LAMBDA;
-        }
-        @Override
-        public void accept(Visitor v) {
-            v.visitLambda(this);
-        }
-        @Override
-        public <R, D> R accept(TreeVisitor<R, D> v, D d) {
-            return v.visitLambdaExpression(this, d);
-        }
-        public Kind getKind() {
-            return Kind.LAMBDA_EXPRESSION;
-        }
-        public JCTree getBody() {
-            return body;
-        }
-        public java.util.List<? extends VariableTree> getParameters() {
-            return params;
-        }
-        @Override
-        public JCLambda setType(Type type) {
-            super.setType(type);
-            return this;
-        }
-        @Override
-        public BodyKind getBodyKind() {
-            return body.hasTag(BLOCK) ?
-                    BodyKind.STATEMENT :
-                    BodyKind.EXPRESSION;
-        }
-    }
-
-    /**
      * A parenthesized subexpression ( ... )
      */
     public static class JCParens extends JCExpression implements ParenthesizedTree {
@@ -1565,7 +1447,7 @@
             return v.visitParenthesized(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return PARENS;
         }
     }
@@ -1591,7 +1473,7 @@
             return v.visitAssignment(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return ASSIGN;
         }
     }
@@ -1600,11 +1482,11 @@
      * An assignment with "+=", "|=" ...
      */
     public static class JCAssignOp extends JCExpression implements CompoundAssignmentTree {
-        private Tag opcode;
+        private int opcode;
         public JCExpression lhs;
         public JCExpression rhs;
         public Symbol operator;
-        protected JCAssignOp(Tag opcode, JCTree lhs, JCTree rhs, Symbol operator) {
+        protected JCAssignOp(int opcode, JCTree lhs, JCTree rhs, Symbol operator) {
             this.opcode = opcode;
             this.lhs = (JCExpression)lhs;
             this.rhs = (JCExpression)rhs;
@@ -1624,7 +1506,7 @@
             return v.visitCompoundAssignment(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return opcode;
         }
     }
@@ -1633,10 +1515,10 @@
      * A unary operation.
      */
     public static class JCUnary extends JCExpression implements UnaryTree {
-        private Tag opcode;
+        private int opcode;
         public JCExpression arg;
         public Symbol operator;
-        protected JCUnary(Tag opcode, JCExpression arg) {
+        protected JCUnary(int opcode, JCExpression arg) {
             this.opcode = opcode;
             this.arg = arg;
         }
@@ -1653,11 +1535,11 @@
             return v.visitUnary(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return opcode;
         }
 
-        public void setTag(Tag tag) {
+        public void setTag(int tag) {
             opcode = tag;
         }
     }
@@ -1666,11 +1548,11 @@
      * A binary operation.
      */
     public static class JCBinary extends JCExpression implements BinaryTree {
-        private Tag opcode;
+        private int opcode;
         public JCExpression lhs;
         public JCExpression rhs;
         public Symbol operator;
-        protected JCBinary(Tag opcode,
+        protected JCBinary(int opcode,
                          JCExpression lhs,
                          JCExpression rhs,
                          Symbol operator) {
@@ -1693,7 +1575,7 @@
             return v.visitBinary(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return opcode;
         }
     }
@@ -1719,7 +1601,7 @@
             return v.visitTypeCast(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TYPECAST;
         }
     }
@@ -1745,7 +1627,7 @@
             return v.visitInstanceOf(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TYPETEST;
         }
     }
@@ -1771,7 +1653,7 @@
             return v.visitArrayAccess(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return INDEXED;
         }
     }
@@ -1802,52 +1684,12 @@
         }
         public Name getIdentifier() { return name; }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return SELECT;
         }
     }
 
     /**
-     * Selects a member expression.
-     */
-    public static class JCMemberReference extends JCExpression implements MemberReferenceTree {
-        public ReferenceMode mode;
-        public Name name;
-        public JCExpression expr;
-        public List<JCExpression> typeargs;
-        public Type targetType;
-        public Symbol sym;
-
-        protected JCMemberReference(ReferenceMode mode, Name name, JCExpression expr, List<JCExpression> typeargs) {
-            this.mode = mode;
-            this.name = name;
-            this.expr = expr;
-            this.typeargs = typeargs;
-        }
-        @Override
-        public void accept(Visitor v) { v.visitReference(this); }
-
-        public Kind getKind() { return Kind.MEMBER_REFERENCE; }
-        @Override
-        public ReferenceMode getMode() { return mode; }
-        @Override
-        public JCExpression getQualifierExpression() { return expr; }
-        @Override
-        public Name getName() { return name; }
-        @Override
-        public List<JCExpression> getTypeArguments() { return typeargs; }
-
-        @Override
-        public <R,D> R accept(TreeVisitor<R,D> v, D d) {
-            return v.visitMemberReference(this, d);
-        }
-        @Override
-        public Tag getTag() {
-            return REFERENCE;
-        }
-    }
-
-    /**
      * An identifier
      * @param idname the name
      * @param sym the symbol
@@ -1868,8 +1710,7 @@
         public <R,D> R accept(TreeVisitor<R,D> v, D d) {
             return v.visitIdentifier(this, d);
         }
-        @Override
-        public Tag getTag() {
+        public int getTag() {
             return IDENT;
         }
     }
@@ -1935,7 +1776,7 @@
             return this;
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return LITERAL;
         }
     }
@@ -1983,7 +1824,7 @@
             return v.visitPrimitiveType(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TYPEIDENT;
         }
     }
@@ -2006,7 +1847,7 @@
             return v.visitArrayType(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TYPEARRAY;
         }
     }
@@ -2034,7 +1875,7 @@
             return v.visitParameterizedType(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TYPEAPPLY;
         }
     }
@@ -2062,7 +1903,7 @@
             return v.visitUnionType(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TYPEUNION;
         }
     }
@@ -2092,7 +1933,7 @@
             return v.visitTypeParameter(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TYPEPARAMETER;
         }
     }
@@ -2126,7 +1967,7 @@
             return v.visitWildcard(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return WILDCARD;
         }
     }
@@ -2147,7 +1988,7 @@
             throw new AssertionError("TypeBoundKind is not part of a public API");
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return TYPEBOUNDKIND;
         }
     }
@@ -2172,7 +2013,7 @@
             return v.visitAnnotation(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return ANNOTATION;
         }
     }
@@ -2199,7 +2040,7 @@
             return v.visitModifiers(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return MODIFIERS;
         }
     }
@@ -2224,7 +2065,7 @@
             return v.visitErroneous(this, d);
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return ERRONEOUS;
         }
     }
@@ -2248,7 +2089,7 @@
             throw new AssertionError("LetExpr is not part of a public API");
         }
         @Override
-        public Tag getTag() {
+        public int getTag() {
             return LETEXPR;
         }
     }
@@ -2320,9 +2161,9 @@
                           List<JCExpression> elems);
         JCParens Parens(JCExpression expr);
         JCAssign Assign(JCExpression lhs, JCExpression rhs);
-        JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
-        JCUnary Unary(Tag opcode, JCExpression arg);
-        JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
+        JCAssignOp Assignop(int opcode, JCTree lhs, JCTree rhs);
+        JCUnary Unary(int opcode, JCExpression arg);
+        JCBinary Binary(int opcode, JCExpression lhs, JCExpression rhs);
         JCTypeCast TypeCast(JCTree expr, JCExpression type);
         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
@@ -2372,7 +2213,6 @@
         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
         public void visitNewClass(JCNewClass that)           { visitTree(that); }
         public void visitNewArray(JCNewArray that)           { visitTree(that); }
-        public void visitLambda(JCLambda that)               { visitTree(that); }
         public void visitParens(JCParens that)               { visitTree(that); }
         public void visitAssign(JCAssign that)               { visitTree(that); }
         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
@@ -2382,7 +2222,6 @@
         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
-        public void visitReference(JCMemberReference that)   { visitTree(that); }
         public void visitIdent(JCIdent that)                 { visitTree(that); }
         public void visitLiteral(JCLiteral that)             { visitTree(that); }
         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
diff -u -r javac/tree/Pretty.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/Pretty.java
--- javac/tree/Pretty.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/Pretty.java	2011-06-27 15:21:47.000000000 -0500
@@ -28,8 +28,6 @@
 import java.io.*;
 import java.util.*;
 
-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
-
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.code.*;
@@ -38,8 +36,6 @@
 import com.sun.tools.javac.tree.JCTree.*;
 
 import static com.sun.tools.javac.code.Flags.*;
-import static com.sun.tools.javac.code.Flags.ANNOTATION;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
 
 /** Prints out a tree as an indented Java source program.
  *
@@ -314,7 +310,7 @@
 
     /** Is the given tree an enumerator definition? */
     boolean isEnumerator(JCTree t) {
-        return t.hasTag(VARDEF) && (((JCVariableDecl) t).mods.flags & ENUM) != 0;
+        return t.getTag() == JCTree.VARDEF && (((JCVariableDecl) t).mods.flags & ENUM) != 0;
     }
 
     /** Print unit consisting of package clause and import statements in toplevel,
@@ -335,9 +331,9 @@
         }
         boolean firstImport = true;
         for (List<JCTree> l = tree.defs;
-        l.nonEmpty() && (cdef == null || l.head.hasTag(IMPORT));
+        l.nonEmpty() && (cdef == null || l.head.getTag() == JCTree.IMPORT);
         l = l.tail) {
-            if (l.head.hasTag(IMPORT)) {
+            if (l.head.getTag() == JCTree.IMPORT) {
                 JCImport imp = (JCImport)l.head;
                 Name name = TreeInfo.name(imp.qualid);
                 if (name == name.table.names.asterisk ||
@@ -488,7 +484,7 @@
                 print("/*public static final*/ ");
                 print(tree.name);
                 if (tree.init != null) {
-                    if (sourceOutput && tree.init.hasTag(NEWCLASS)) {
+                    if (sourceOutput && tree.init.getTag() == JCTree.NEWCLASS) {
                         print(" /*enum*/ ");
                         JCNewClass init = (JCNewClass) tree.init;
                         if (init.args != null && init.args.nonEmpty()) {
@@ -549,7 +545,7 @@
             printStat(tree.body);
             align();
             print(" while ");
-            if (tree.cond.hasTag(PARENS)) {
+            if (tree.cond.getTag() == JCTree.PARENS) {
                 printExpr(tree.cond);
             } else {
                 print("(");
@@ -565,7 +561,7 @@
     public void visitWhileLoop(JCWhileLoop tree) {
         try {
             print("while ");
-            if (tree.cond.hasTag(PARENS)) {
+            if (tree.cond.getTag() == JCTree.PARENS) {
                 printExpr(tree.cond);
             } else {
                 print("(");
@@ -583,7 +579,7 @@
         try {
             print("for (");
             if (tree.init.nonEmpty()) {
-                if (tree.init.head.hasTag(VARDEF)) {
+                if (tree.init.head.getTag() == JCTree.VARDEF) {
                     printExpr(tree.init.head);
                     for (List<JCStatement> l = tree.init.tail; l.nonEmpty(); l = l.tail) {
                         JCVariableDecl vdef = (JCVariableDecl)l.head;
@@ -630,7 +626,7 @@
     public void visitSwitch(JCSwitch tree) {
         try {
             print("switch ");
-            if (tree.selector.hasTag(PARENS)) {
+            if (tree.selector.getTag() == JCTree.PARENS) {
                 printExpr(tree.selector);
             } else {
                 print("(");
@@ -669,7 +665,7 @@
     public void visitSynchronized(JCSynchronized tree) {
         try {
             print("synchronized ");
-            if (tree.lock.hasTag(PARENS)) {
+            if (tree.lock.getTag() == JCTree.PARENS) {
                 printExpr(tree.lock);
             } else {
                 print("(");
@@ -740,7 +736,7 @@
     public void visitIf(JCIf tree) {
         try {
             print("if ");
-            if (tree.cond.hasTag(PARENS)) {
+            if (tree.cond.getTag() == JCTree.PARENS) {
                 printExpr(tree.cond);
             } else {
                 print("(");
@@ -827,7 +823,7 @@
     public void visitApply(JCMethodInvocation tree) {
         try {
             if (!tree.typeargs.isEmpty()) {
-                if (tree.meth.hasTag(SELECT)) {
+                if (tree.meth.getTag() == JCTree.SELECT) {
                     JCFieldAccess left = (JCFieldAccess)tree.meth;
                     printExpr(left.selected);
                     print(".<");
@@ -886,7 +882,7 @@
             if (tree.elemtype != null) {
                 print("new ");
                 JCTree elem = tree.elemtype;
-                if (elem.hasTag(TYPEARRAY))
+                if (elem.getTag() == JCTree.TYPEARRAY)
                     printBaseElementType((JCArrayTypeTree) elem);
                 else
                     printExpr(elem);
@@ -909,17 +905,6 @@
         }
     }
 
-    public void visitLambda(JCLambda tree) {
-        try {
-            print("(");
-            printExprs(tree.params);
-            print(")->");
-            printExpr(tree.body);
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
-        }
-    }
-
     public void visitParens(JCParens tree) {
         try {
             print("(");
@@ -942,36 +927,36 @@
         }
     }
 
-    public String operatorName(JCTree.Tag tag) {
+    public String operatorName(int tag) {
         switch(tag) {
-            case POS:     return "+";
-            case NEG:     return "-";
-            case NOT:     return "!";
-            case COMPL:   return "~";
-            case PREINC:  return "++";
-            case PREDEC:  return "--";
-            case POSTINC: return "++";
-            case POSTDEC: return "--";
-            case NULLCHK: return "<*nullchk*>";
-            case OR:      return "||";
-            case AND:     return "&&";
-            case EQ:      return "==";
-            case NE:      return "!=";
-            case LT:      return "<";
-            case GT:      return ">";
-            case LE:      return "<=";
-            case GE:      return ">=";
-            case BITOR:   return "|";
-            case BITXOR:  return "^";
-            case BITAND:  return "&";
-            case SL:      return "<<";
-            case SR:      return ">>";
-            case USR:     return ">>>";
-            case PLUS:    return "+";
-            case MINUS:   return "-";
-            case MUL:     return "*";
-            case DIV:     return "/";
-            case MOD:     return "%";
+            case JCTree.POS:     return "+";
+            case JCTree.NEG:     return "-";
+            case JCTree.NOT:     return "!";
+            case JCTree.COMPL:   return "~";
+            case JCTree.PREINC:  return "++";
+            case JCTree.PREDEC:  return "--";
+            case JCTree.POSTINC: return "++";
+            case JCTree.POSTDEC: return "--";
+            case JCTree.NULLCHK: return "<*nullchk*>";
+            case JCTree.OR:      return "||";
+            case JCTree.AND:     return "&&";
+            case JCTree.EQ:      return "==";
+            case JCTree.NE:      return "!=";
+            case JCTree.LT:      return "<";
+            case JCTree.GT:      return ">";
+            case JCTree.LE:      return "<=";
+            case JCTree.GE:      return ">=";
+            case JCTree.BITOR:   return "|";
+            case JCTree.BITXOR:  return "^";
+            case JCTree.BITAND:  return "&";
+            case JCTree.SL:      return "<<";
+            case JCTree.SR:      return ">>";
+            case JCTree.USR:     return ">>>";
+            case JCTree.PLUS:    return "+";
+            case JCTree.MINUS:   return "-";
+            case JCTree.MUL:     return "*";
+            case JCTree.DIV:     return "/";
+            case JCTree.MOD:     return "%";
             default: throw new Error();
         }
     }
@@ -980,7 +965,7 @@
         try {
             open(prec, TreeInfo.assignopPrec);
             printExpr(tree.lhs, TreeInfo.assignopPrec + 1);
-            print(" " + operatorName(tree.getTag().noAssignOp()) + "= ");
+            print(" " + operatorName(tree.getTag() - JCTree.ASGOffset) + "= ");
             printExpr(tree.rhs, TreeInfo.assignopPrec);
             close(prec, TreeInfo.assignopPrec);
         } catch (IOException e) {
@@ -993,7 +978,7 @@
             int ownprec = TreeInfo.opPrec(tree.getTag());
             String opname = operatorName(tree.getTag());
             open(prec, ownprec);
-            if (!tree.getTag().isPostUnaryOp()) {
+            if (tree.getTag() <= JCTree.PREDEC) {
                 print(opname);
                 printExpr(tree.arg, ownprec);
             } else {
@@ -1065,21 +1050,6 @@
         }
     }
 
-    public void visitReference(JCMemberReference tree) {
-        try {
-            printExpr(tree.expr);
-            print("#");
-            if (tree.typeargs != null) {
-                print("<");
-                printExprs(tree.typeargs);
-                print(">");
-            }
-            print(tree.getMode() == ReferenceMode.INVOKE ? tree.name : "new");
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
-        }
-    }
-
     public void visitIdent(JCIdent tree) {
         try {
             print(tree.name);
@@ -1183,7 +1153,7 @@
         while (true) {
             elem = tree.elemtype;
             print("[]");
-            if (!elem.hasTag(TYPEARRAY)) break;
+            if (elem.getTag() != JCTree.TYPEARRAY) break;
             tree = (JCArrayTypeTree) elem;
         }
     }
diff -u -r javac/tree/TreeCopier.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeCopier.java
--- javac/tree/TreeCopier.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeCopier.java	2011-06-27 15:21:47.000000000 -0500
@@ -271,13 +271,6 @@
         return M.at(t.pos).NewClass(encl, typeargs, clazz, args, def);
     }
 
-    public JCTree visitLambdaExpression(LambdaExpressionTree node, P p) {
-        JCLambda t = (JCLambda) node;
-        List<JCVariableDecl> params = copy(t.params, p);
-        JCTree body = copy(t.body, p);
-        return M.at(t.pos).Lambda(params, body);
-    }
-
     public JCTree visitParenthesized(ParenthesizedTree node, P p) {
         JCParens t = (JCParens) node;
         JCExpression expr = copy(t.expr, p);
@@ -296,13 +289,6 @@
         return M.at(t.pos).Select(selected, t.name);
     }
 
-    public JCTree visitMemberReference(MemberReferenceTree node, P p) {
-        JCMemberReference t = (JCMemberReference) node;
-        JCExpression expr = copy(t.expr, p);
-        List<JCExpression> typeargs = copy(t.typeargs, p);
-        return M.at(t.pos).Reference(t.mode, t.name, expr, typeargs);
-    }
-
     public JCTree visitEmptyStatement(EmptyStatementTree node, P p) {
         JCSkip t = (JCSkip) node;
         return M.at(t.pos).Skip();
@@ -420,7 +406,7 @@
     public JCTree visitOther(Tree node, P p) {
         JCTree tree = (JCTree) node;
         switch (tree.getTag()) {
-            case LETEXPR: {
+            case JCTree.LETEXPR: {
                 LetExpr t = (LetExpr) node;
                 List<JCVariableDecl> defs = copy(t.defs, p);
                 JCTree expr = copy(t.expr, p);
diff -u -r javac/tree/TreeInfo.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeInfo.java
--- javac/tree/TreeInfo.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeInfo.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,16 +28,13 @@
 import com.sun.source.tree.Tree;
 import com.sun.tools.javac.comp.AttrContext;
 import com.sun.tools.javac.comp.Env;
+import java.util.Map;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.code.*;
-import com.sun.tools.javac.parser.EndPosTable;
 import com.sun.tools.javac.tree.JCTree.*;
 
 import static com.sun.tools.javac.code.Flags.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.*;
-import static com.sun.tools.javac.tree.JCTree.Tag.BLOCK;
-import static com.sun.tools.javac.tree.JCTree.Tag.SYNCHRONIZED;
 
 /** Utility class containing inspector methods for trees.
  *
@@ -59,70 +56,53 @@
 
     /** The names of all operators.
      */
-    private Name[] opname = new Name[Tag.getNumberOfOperators()];
-
-    private void setOpname(Tag tag, String name, Names names) {
-         setOpname(tag, names.fromString(name));
-     }
-     private void setOpname(Tag tag, Name name) {
-         opname[tag.operatorIndex()] = name;
-     }
+    private Name[] opname = new Name[JCTree.MOD - JCTree.POS + 1];
 
     private TreeInfo(Context context) {
         context.put(treeInfoKey, this);
 
         Names names = Names.instance(context);
-        setOpname(POS, "+", names);
-        setOpname(NEG, names.hyphen);
-        setOpname(NOT, "!", names);
-        setOpname(COMPL, "~", names);
-        setOpname(PREINC, "++", names);
-        setOpname(PREDEC, "--", names);
-        setOpname(POSTINC, "++", names);
-        setOpname(POSTDEC, "--", names);
-        setOpname(NULLCHK, "<*nullchk*>", names);
-        setOpname(OR, "||", names);
-        setOpname(AND, "&&", names);
-        setOpname(EQ, "==", names);
-        setOpname(NE, "!=", names);
-        setOpname(LT, "<", names);
-        setOpname(GT, ">", names);
-        setOpname(LE, "<=", names);
-        setOpname(GE, ">=", names);
-        setOpname(BITOR, "|", names);
-        setOpname(BITXOR, "^", names);
-        setOpname(BITAND, "&", names);
-        setOpname(SL, "<<", names);
-        setOpname(SR, ">>", names);
-        setOpname(USR, ">>>", names);
-        setOpname(PLUS, "+", names);
-        setOpname(MINUS, names.hyphen);
-        setOpname(MUL, names.asterisk);
-        setOpname(DIV, names.slash);
-        setOpname(MOD, "%", names);
+        opname[JCTree.POS     - JCTree.POS] = names.fromString("+");
+        opname[JCTree.NEG     - JCTree.POS] = names.hyphen;
+        opname[JCTree.NOT     - JCTree.POS] = names.fromString("!");
+        opname[JCTree.COMPL   - JCTree.POS] = names.fromString("~");
+        opname[JCTree.PREINC  - JCTree.POS] = names.fromString("++");
+        opname[JCTree.PREDEC  - JCTree.POS] = names.fromString("--");
+        opname[JCTree.POSTINC - JCTree.POS] = names.fromString("++");
+        opname[JCTree.POSTDEC - JCTree.POS] = names.fromString("--");
+        opname[JCTree.NULLCHK - JCTree.POS] = names.fromString("<*nullchk*>");
+        opname[JCTree.OR      - JCTree.POS] = names.fromString("||");
+        opname[JCTree.AND     - JCTree.POS] = names.fromString("&&");
+        opname[JCTree.EQ      - JCTree.POS] = names.fromString("==");
+        opname[JCTree.NE      - JCTree.POS] = names.fromString("!=");
+        opname[JCTree.LT      - JCTree.POS] = names.fromString("<");
+        opname[JCTree.GT      - JCTree.POS] = names.fromString(">");
+        opname[JCTree.LE      - JCTree.POS] = names.fromString("<=");
+        opname[JCTree.GE      - JCTree.POS] = names.fromString(">=");
+        opname[JCTree.BITOR   - JCTree.POS] = names.fromString("|");
+        opname[JCTree.BITXOR  - JCTree.POS] = names.fromString("^");
+        opname[JCTree.BITAND  - JCTree.POS] = names.fromString("&");
+        opname[JCTree.SL      - JCTree.POS] = names.fromString("<<");
+        opname[JCTree.SR      - JCTree.POS] = names.fromString(">>");
+        opname[JCTree.USR     - JCTree.POS] = names.fromString(">>>");
+        opname[JCTree.PLUS    - JCTree.POS] = names.fromString("+");
+        opname[JCTree.MINUS   - JCTree.POS] = names.hyphen;
+        opname[JCTree.MUL     - JCTree.POS] = names.asterisk;
+        opname[JCTree.DIV     - JCTree.POS] = names.slash;
+        opname[JCTree.MOD     - JCTree.POS] = names.fromString("%");
     }
 
-    public static List<JCExpression> args(JCTree t) {
-        switch (t.getTag()) {
-            case APPLY:
-                return ((JCMethodInvocation)t).args;
-            case NEWCLASS:
-                return ((JCNewClass)t).args;
-            default:
-                return null;
-        }
-    }
 
     /** Return name of operator with given tree tag.
      */
-    public Name operatorName(JCTree.Tag tag) {
-        return opname[tag.operatorIndex()];
+    public Name operatorName(int tag) {
+        return opname[tag - JCTree.POS];
     }
 
     /** Is tree a constructor declaration?
      */
     public static boolean isConstructor(JCTree tree) {
-        if (tree.hasTag(METHODDEF)) {
+        if (tree.getTag() == JCTree.METHODDEF) {
             Name name = ((JCMethodDecl) tree).name;
             return name == name.table.names.init;
         } else {
@@ -139,17 +119,17 @@
     }
 
     public static boolean isMultiCatch(JCCatch catchClause) {
-        return catchClause.param.vartype.hasTag(TYPEUNION);
+        return catchClause.param.vartype.getTag() == JCTree.TYPEUNION;
     }
 
     /** Is statement an initializer for a synthetic field?
      */
     public static boolean isSyntheticInit(JCTree stat) {
-        if (stat.hasTag(EXEC)) {
+        if (stat.getTag() == JCTree.EXEC) {
             JCExpressionStatement exec = (JCExpressionStatement)stat;
-            if (exec.expr.hasTag(ASSIGN)) {
+            if (exec.expr.getTag() == JCTree.ASSIGN) {
                 JCAssign assign = (JCAssign)exec.expr;
-                if (assign.lhs.hasTag(SELECT)) {
+                if (assign.lhs.getTag() == JCTree.SELECT) {
                     JCFieldAccess select = (JCFieldAccess)assign.lhs;
                     if (select.sym != null &&
                         (select.sym.flags() & SYNTHETIC) != 0) {
@@ -166,9 +146,9 @@
     /** If the expression is a method call, return the method name, null
      *  otherwise. */
     public static Name calledMethodName(JCTree tree) {
-        if (tree.hasTag(EXEC)) {
+        if (tree.getTag() == JCTree.EXEC) {
             JCExpressionStatement exec = (JCExpressionStatement)tree;
-            if (exec.expr.hasTag(APPLY)) {
+            if (exec.expr.getTag() == JCTree.APPLY) {
                 Name mname = TreeInfo.name(((JCMethodInvocation) exec.expr).meth);
                 return mname;
             }
@@ -212,7 +192,7 @@
 
     /** Return the first call in a constructor definition. */
     public static JCMethodInvocation firstConstructorCall(JCTree tree) {
-        if (!tree.hasTag(METHODDEF)) return null;
+        if (tree.getTag() != JCTree.METHODDEF) return null;
         JCMethodDecl md = (JCMethodDecl) tree;
         Names names = md.name.table.names;
         if (md.name != names.init) return null;
@@ -222,52 +202,24 @@
         while (stats.nonEmpty() && isSyntheticInit(stats.head))
             stats = stats.tail;
         if (stats.isEmpty()) return null;
-        if (!stats.head.hasTag(EXEC)) return null;
+        if (stats.head.getTag() != JCTree.EXEC) return null;
         JCExpressionStatement exec = (JCExpressionStatement) stats.head;
-        if (!exec.expr.hasTag(APPLY)) return null;
+        if (exec.expr.getTag() != JCTree.APPLY) return null;
         return (JCMethodInvocation)exec.expr;
     }
 
     /** Return true if a tree represents a diamond new expr. */
     public static boolean isDiamond(JCTree tree) {
         switch(tree.getTag()) {
-            case TYPEAPPLY: return ((JCTypeApply)tree).getTypeArguments().isEmpty();
-            case NEWCLASS: return isDiamond(((JCNewClass)tree).clazz);
+            case JCTree.TYPEAPPLY: return ((JCTypeApply)tree).getTypeArguments().isEmpty();
+            case JCTree.NEWCLASS: return isDiamond(((JCNewClass)tree).clazz);
             default: return false;
         }
     }
 
-    /**
-     * Return true if the AST corresponds to a static select of the kind A.B
-     */
-    public static boolean isStaticSelector(JCTree base, Names names) {
-        if (base == null)
-            return false;
-        switch (base.getTag()) {
-            case IDENT:
-                JCIdent id = (JCIdent)base;
-                return id.name != names._this &&
-                        id.name != names._super &&
-                        isStaticSym(base);
-            case SELECT:
-                return isStaticSym(base) &&
-                    isStaticSelector(((JCFieldAccess)base).selected, names);
-            case TYPEAPPLY:
-                return true;
-            default:
-                return false;
-        }
-    }
-    //where
-        private static boolean isStaticSym(JCTree tree) {
-            Symbol sym = symbol(tree);
-            return (sym.kind == Kinds.TYP ||
-                    sym.kind == Kinds.PCK);
-        }
-
     /** Return true if a tree represents the null literal. */
     public static boolean isNull(JCTree tree) {
-        if (!tree.hasTag(LITERAL))
+        if (tree.getTag() != JCTree.LITERAL)
             return false;
         JCLiteral lit = (JCLiteral) tree;
         return (lit.typetag == TypeTags.BOT);
@@ -277,7 +229,7 @@
      *  the block itself if it is empty.
      */
     public static int firstStatPos(JCTree tree) {
-        if (tree.hasTag(BLOCK) && ((JCBlock) tree).stats.nonEmpty())
+        if (tree.getTag() == JCTree.BLOCK && ((JCBlock) tree).stats.nonEmpty())
             return ((JCBlock) tree).stats.head.pos;
         else
             return tree.pos;
@@ -287,11 +239,11 @@
      *  defined endpos.
      */
     public static int endPos(JCTree tree) {
-        if (tree.hasTag(BLOCK) && ((JCBlock) tree).endpos != Position.NOPOS)
+        if (tree.getTag() == JCTree.BLOCK && ((JCBlock) tree).endpos != Position.NOPOS)
             return ((JCBlock) tree).endpos;
-        else if (tree.hasTag(SYNCHRONIZED))
+        else if (tree.getTag() == JCTree.SYNCHRONIZED)
             return endPos(((JCSynchronized) tree).body);
-        else if (tree.hasTag(TRY)) {
+        else if (tree.getTag() == JCTree.TRY) {
             JCTry t = (JCTry) tree;
             return endPos((t.finalizer != null)
                           ? t.finalizer
@@ -311,162 +263,162 @@
             return Position.NOPOS;
 
         switch(tree.getTag()) {
-            case APPLY:
-                return getStartPos(((JCMethodInvocation) tree).meth);
-            case ASSIGN:
-                return getStartPos(((JCAssign) tree).lhs);
-            case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
-            case SL_ASG: case SR_ASG: case USR_ASG:
-            case PLUS_ASG: case MINUS_ASG: case MUL_ASG:
-            case DIV_ASG: case MOD_ASG:
-                return getStartPos(((JCAssignOp) tree).lhs);
-            case OR: case AND: case BITOR:
-            case BITXOR: case BITAND: case EQ:
-            case NE: case LT: case GT:
-            case LE: case GE: case SL:
-            case SR: case USR: case PLUS:
-            case MINUS: case MUL: case DIV:
-            case MOD:
-                return getStartPos(((JCBinary) tree).lhs);
-            case CLASSDEF: {
-                JCClassDecl node = (JCClassDecl)tree;
-                if (node.mods.pos != Position.NOPOS)
-                    return node.mods.pos;
-                break;
-            }
-            case CONDEXPR:
-                return getStartPos(((JCConditional) tree).cond);
-            case EXEC:
-                return getStartPos(((JCExpressionStatement) tree).expr);
-            case INDEXED:
-                return getStartPos(((JCArrayAccess) tree).indexed);
-            case METHODDEF: {
-                JCMethodDecl node = (JCMethodDecl)tree;
-                if (node.mods.pos != Position.NOPOS)
-                    return node.mods.pos;
-                if (node.typarams.nonEmpty()) // List.nil() used for no typarams
-                    return getStartPos(node.typarams.head);
-                return node.restype == null ? node.pos : getStartPos(node.restype);
-            }
-            case SELECT:
-                return getStartPos(((JCFieldAccess) tree).selected);
-            case TYPEAPPLY:
-                return getStartPos(((JCTypeApply) tree).clazz);
-            case TYPEARRAY:
-                return getStartPos(((JCArrayTypeTree) tree).elemtype);
-            case TYPETEST:
-                return getStartPos(((JCInstanceOf) tree).expr);
-            case POSTINC:
-            case POSTDEC:
-                return getStartPos(((JCUnary) tree).arg);
-            case NEWCLASS: {
-                JCNewClass node = (JCNewClass)tree;
-                if (node.encl != null)
-                    return getStartPos(node.encl);
-                break;
-            }
-            case VARDEF: {
-                JCVariableDecl node = (JCVariableDecl)tree;
-                if (node.mods.pos != Position.NOPOS) {
-                    return node.mods.pos;
-                } else {
-                    return getStartPos(node.vartype);
-                }
-            }
-            case ERRONEOUS: {
-                JCErroneous node = (JCErroneous)tree;
-                if (node.errs != null && node.errs.nonEmpty())
-                    return getStartPos(node.errs.head);
-            }
+        case(JCTree.APPLY):
+            return getStartPos(((JCMethodInvocation) tree).meth);
+        case(JCTree.ASSIGN):
+            return getStartPos(((JCAssign) tree).lhs);
+        case(JCTree.BITOR_ASG): case(JCTree.BITXOR_ASG): case(JCTree.BITAND_ASG):
+        case(JCTree.SL_ASG): case(JCTree.SR_ASG): case(JCTree.USR_ASG):
+        case(JCTree.PLUS_ASG): case(JCTree.MINUS_ASG): case(JCTree.MUL_ASG):
+        case(JCTree.DIV_ASG): case(JCTree.MOD_ASG):
+            return getStartPos(((JCAssignOp) tree).lhs);
+        case(JCTree.OR): case(JCTree.AND): case(JCTree.BITOR):
+        case(JCTree.BITXOR): case(JCTree.BITAND): case(JCTree.EQ):
+        case(JCTree.NE): case(JCTree.LT): case(JCTree.GT):
+        case(JCTree.LE): case(JCTree.GE): case(JCTree.SL):
+        case(JCTree.SR): case(JCTree.USR): case(JCTree.PLUS):
+        case(JCTree.MINUS): case(JCTree.MUL): case(JCTree.DIV):
+        case(JCTree.MOD):
+            return getStartPos(((JCBinary) tree).lhs);
+        case(JCTree.CLASSDEF): {
+            JCClassDecl node = (JCClassDecl)tree;
+            if (node.mods.pos != Position.NOPOS)
+                return node.mods.pos;
+            break;
+        }
+        case(JCTree.CONDEXPR):
+            return getStartPos(((JCConditional) tree).cond);
+        case(JCTree.EXEC):
+            return getStartPos(((JCExpressionStatement) tree).expr);
+        case(JCTree.INDEXED):
+            return getStartPos(((JCArrayAccess) tree).indexed);
+        case(JCTree.METHODDEF): {
+            JCMethodDecl node = (JCMethodDecl)tree;
+            if (node.mods.pos != Position.NOPOS)
+                return node.mods.pos;
+            if (node.typarams.nonEmpty()) // List.nil() used for no typarams
+                return getStartPos(node.typarams.head);
+            return node.restype == null ? node.pos : getStartPos(node.restype);
+        }
+        case(JCTree.SELECT):
+            return getStartPos(((JCFieldAccess) tree).selected);
+        case(JCTree.TYPEAPPLY):
+            return getStartPos(((JCTypeApply) tree).clazz);
+        case(JCTree.TYPEARRAY):
+            return getStartPos(((JCArrayTypeTree) tree).elemtype);
+        case(JCTree.TYPETEST):
+            return getStartPos(((JCInstanceOf) tree).expr);
+        case(JCTree.POSTINC):
+        case(JCTree.POSTDEC):
+            return getStartPos(((JCUnary) tree).arg);
+        case(JCTree.NEWCLASS): {
+            JCNewClass node = (JCNewClass)tree;
+            if (node.encl != null)
+                return getStartPos(node.encl);
+            break;
+        }
+        case(JCTree.VARDEF): {
+            JCVariableDecl node = (JCVariableDecl)tree;
+            if (node.mods.pos != Position.NOPOS) {
+                return node.mods.pos;
+            } else {
+                return getStartPos(node.vartype);
+            }
+        }
+        case(JCTree.ERRONEOUS): {
+            JCErroneous node = (JCErroneous)tree;
+            if (node.errs != null && node.errs.nonEmpty())
+                return getStartPos(node.errs.head);
+        }
         }
         return tree.pos;
     }
 
     /** The end position of given tree, given  a table of end positions generated by the parser
      */
-    public static int getEndPos(JCTree tree, EndPosTable endPosTable) {
+    public static int getEndPos(JCTree tree, Map<JCTree, Integer> endPositions) {
         if (tree == null)
             return Position.NOPOS;
 
-        if (endPosTable == null) {
+        if (endPositions == null) {
             // fall back on limited info in the tree
             return endPos(tree);
         }
 
-        int mapPos = endPosTable.getEndPos(tree);
-        if (mapPos != Position.NOPOS)
+        Integer mapPos = endPositions.get(tree);
+        if (mapPos != null)
             return mapPos;
 
         switch(tree.getTag()) {
-            case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
-            case SL_ASG: case SR_ASG: case USR_ASG:
-            case PLUS_ASG: case MINUS_ASG: case MUL_ASG:
-            case DIV_ASG: case MOD_ASG:
-                return getEndPos(((JCAssignOp) tree).rhs, endPosTable);
-            case OR: case AND: case BITOR:
-            case BITXOR: case BITAND: case EQ:
-            case NE: case LT: case GT:
-            case LE: case GE: case SL:
-            case SR: case USR: case PLUS:
-            case MINUS: case MUL: case DIV:
-            case MOD:
-                return getEndPos(((JCBinary) tree).rhs, endPosTable);
-            case CASE:
-                return getEndPos(((JCCase) tree).stats.last(), endPosTable);
-            case CATCH:
-                return getEndPos(((JCCatch) tree).body, endPosTable);
-            case CONDEXPR:
-                return getEndPos(((JCConditional) tree).falsepart, endPosTable);
-            case FORLOOP:
-                return getEndPos(((JCForLoop) tree).body, endPosTable);
-            case FOREACHLOOP:
-                return getEndPos(((JCEnhancedForLoop) tree).body, endPosTable);
-            case IF: {
-                JCIf node = (JCIf)tree;
-                if (node.elsepart == null) {
-                    return getEndPos(node.thenpart, endPosTable);
-                } else {
-                    return getEndPos(node.elsepart, endPosTable);
-                }
-            }
-            case LABELLED:
-                return getEndPos(((JCLabeledStatement) tree).body, endPosTable);
-            case MODIFIERS:
-                return getEndPos(((JCModifiers) tree).annotations.last(), endPosTable);
-            case SYNCHRONIZED:
-                return getEndPos(((JCSynchronized) tree).body, endPosTable);
-            case TOPLEVEL:
-                return getEndPos(((JCCompilationUnit) tree).defs.last(), endPosTable);
-            case TRY: {
-                JCTry node = (JCTry)tree;
-                if (node.finalizer != null) {
-                    return getEndPos(node.finalizer, endPosTable);
-                } else if (!node.catchers.isEmpty()) {
-                    return getEndPos(node.catchers.last(), endPosTable);
-                } else {
-                    return getEndPos(node.body, endPosTable);
-                }
-            }
-            case WILDCARD:
-                return getEndPos(((JCWildcard) tree).inner, endPosTable);
-            case TYPECAST:
-                return getEndPos(((JCTypeCast) tree).expr, endPosTable);
-            case TYPETEST:
-                return getEndPos(((JCInstanceOf) tree).clazz, endPosTable);
-            case POS:
-            case NEG:
-            case NOT:
-            case COMPL:
-            case PREINC:
-            case PREDEC:
-                return getEndPos(((JCUnary) tree).arg, endPosTable);
-            case WHILELOOP:
-                return getEndPos(((JCWhileLoop) tree).body, endPosTable);
-            case ERRONEOUS: {
-                JCErroneous node = (JCErroneous)tree;
-                if (node.errs != null && node.errs.nonEmpty())
-                    return getEndPos(node.errs.last(), endPosTable);
-            }
+        case(JCTree.BITOR_ASG): case(JCTree.BITXOR_ASG): case(JCTree.BITAND_ASG):
+        case(JCTree.SL_ASG): case(JCTree.SR_ASG): case(JCTree.USR_ASG):
+        case(JCTree.PLUS_ASG): case(JCTree.MINUS_ASG): case(JCTree.MUL_ASG):
+        case(JCTree.DIV_ASG): case(JCTree.MOD_ASG):
+            return getEndPos(((JCAssignOp) tree).rhs, endPositions);
+        case(JCTree.OR): case(JCTree.AND): case(JCTree.BITOR):
+        case(JCTree.BITXOR): case(JCTree.BITAND): case(JCTree.EQ):
+        case(JCTree.NE): case(JCTree.LT): case(JCTree.GT):
+        case(JCTree.LE): case(JCTree.GE): case(JCTree.SL):
+        case(JCTree.SR): case(JCTree.USR): case(JCTree.PLUS):
+        case(JCTree.MINUS): case(JCTree.MUL): case(JCTree.DIV):
+        case(JCTree.MOD):
+            return getEndPos(((JCBinary) tree).rhs, endPositions);
+        case(JCTree.CASE):
+            return getEndPos(((JCCase) tree).stats.last(), endPositions);
+        case(JCTree.CATCH):
+            return getEndPos(((JCCatch) tree).body, endPositions);
+        case(JCTree.CONDEXPR):
+            return getEndPos(((JCConditional) tree).falsepart, endPositions);
+        case(JCTree.FORLOOP):
+            return getEndPos(((JCForLoop) tree).body, endPositions);
+        case(JCTree.FOREACHLOOP):
+            return getEndPos(((JCEnhancedForLoop) tree).body, endPositions);
+        case(JCTree.IF): {
+            JCIf node = (JCIf)tree;
+            if (node.elsepart == null) {
+                return getEndPos(node.thenpart, endPositions);
+            } else {
+                return getEndPos(node.elsepart, endPositions);
+            }
+        }
+        case(JCTree.LABELLED):
+            return getEndPos(((JCLabeledStatement) tree).body, endPositions);
+        case(JCTree.MODIFIERS):
+            return getEndPos(((JCModifiers) tree).annotations.last(), endPositions);
+        case(JCTree.SYNCHRONIZED):
+            return getEndPos(((JCSynchronized) tree).body, endPositions);
+        case(JCTree.TOPLEVEL):
+            return getEndPos(((JCCompilationUnit) tree).defs.last(), endPositions);
+        case(JCTree.TRY): {
+            JCTry node = (JCTry)tree;
+            if (node.finalizer != null) {
+                return getEndPos(node.finalizer, endPositions);
+            } else if (!node.catchers.isEmpty()) {
+                return getEndPos(node.catchers.last(), endPositions);
+            } else {
+                return getEndPos(node.body, endPositions);
+            }
+        }
+        case(JCTree.WILDCARD):
+            return getEndPos(((JCWildcard) tree).inner, endPositions);
+        case(JCTree.TYPECAST):
+            return getEndPos(((JCTypeCast) tree).expr, endPositions);
+        case(JCTree.TYPETEST):
+            return getEndPos(((JCInstanceOf) tree).clazz, endPositions);
+        case(JCTree.POS):
+        case(JCTree.NEG):
+        case(JCTree.NOT):
+        case(JCTree.COMPL):
+        case(JCTree.PREINC):
+        case(JCTree.PREDEC):
+            return getEndPos(((JCUnary) tree).arg, endPositions);
+        case(JCTree.WHILELOOP):
+            return getEndPos(((JCWhileLoop) tree).body, endPositions);
+        case(JCTree.ERRONEOUS): {
+            JCErroneous node = (JCErroneous)tree;
+            if (node.errs != null && node.errs.nonEmpty())
+                return getEndPos(node.errs.last(), endPositions);
+        }
         }
         return Position.NOPOS;
     }
@@ -482,7 +434,7 @@
             public JCTree getTree() { return tree; }
             public int getStartPosition() { return TreeInfo.getStartPos(tree); }
             public int getPreferredPosition() { return endPos; }
-            public int getEndPosition(EndPosTable endPosTable) {
+            public int getEndPosition(Map<JCTree, Integer> endPosTable) {
                 return TreeInfo.getEndPos(tree, endPosTable);
             }
         };
@@ -491,11 +443,11 @@
     /** The position of the finalizer of given try/synchronized statement.
      */
     public static int finalizerPos(JCTree tree) {
-        if (tree.hasTag(TRY)) {
+        if (tree.getTag() == JCTree.TRY) {
             JCTry t = (JCTry) tree;
             Assert.checkNonNull(t.finalizer);
             return firstStatPos(t.finalizer);
-        } else if (tree.hasTag(SYNCHRONIZED)) {
+        } else if (tree.getTag() == JCTree.SYNCHRONIZED) {
             return endPos(((JCSynchronized) tree).body);
         } else {
             throw new AssertionError();
@@ -595,9 +547,9 @@
     public static JCTree referencedStatement(JCLabeledStatement tree) {
         JCTree t = tree;
         do t = ((JCLabeledStatement) t).body;
-        while (t.hasTag(LABELLED));
+        while (t.getTag() == JCTree.LABELLED);
         switch (t.getTag()) {
-        case DOLOOP: case WHILELOOP: case FORLOOP: case FOREACHLOOP: case SWITCH:
+        case JCTree.DOLOOP: case JCTree.WHILELOOP: case JCTree.FORLOOP: case JCTree.FOREACHLOOP: case JCTree.SWITCH:
             return t;
         default:
             return tree;
@@ -607,7 +559,7 @@
     /** Skip parens and return the enclosed expression
      */
     public static JCExpression skipParens(JCExpression tree) {
-        while (tree.hasTag(PARENS)) {
+        while (tree.getTag() == JCTree.PARENS) {
             tree = ((JCParens) tree).expr;
         }
         return tree;
@@ -616,7 +568,7 @@
     /** Skip parens and return the enclosed expression
      */
     public static JCTree skipParens(JCTree tree) {
-        if (tree.hasTag(PARENS))
+        if (tree.getTag() == JCTree.PARENS)
             return skipParens((JCParens)tree);
         else
             return tree;
@@ -636,11 +588,11 @@
      */
     public static Name name(JCTree tree) {
         switch (tree.getTag()) {
-        case IDENT:
+        case JCTree.IDENT:
             return ((JCIdent) tree).name;
-        case SELECT:
+        case JCTree.SELECT:
             return ((JCFieldAccess) tree).name;
-        case TYPEAPPLY:
+        case JCTree.TYPEAPPLY:
             return name(((JCTypeApply) tree).clazz);
         default:
             return null;
@@ -653,9 +605,9 @@
     public static Name fullName(JCTree tree) {
         tree = skipParens(tree);
         switch (tree.getTag()) {
-        case IDENT:
+        case JCTree.IDENT:
             return ((JCIdent) tree).name;
-        case SELECT:
+        case JCTree.SELECT:
             Name sname = fullName(((JCFieldAccess) tree).selected);
             return sname == null ? null : sname.append('.', name(tree));
         default:
@@ -666,11 +618,11 @@
     public static Symbol symbolFor(JCTree node) {
         node = skipParens(node);
         switch (node.getTag()) {
-        case CLASSDEF:
+        case JCTree.CLASSDEF:
             return ((JCClassDecl) node).sym;
-        case METHODDEF:
+        case JCTree.METHODDEF:
             return ((JCMethodDecl) node).sym;
-        case VARDEF:
+        case JCTree.VARDEF:
             return ((JCVariableDecl) node).sym;
         default:
             return null;
@@ -680,9 +632,9 @@
     public static boolean isDeclaration(JCTree node) {
         node = skipParens(node);
         switch (node.getTag()) {
-        case CLASSDEF:
-        case METHODDEF:
-        case VARDEF:
+        case JCTree.CLASSDEF:
+        case JCTree.METHODDEF:
+        case JCTree.VARDEF:
             return true;
         default:
             return false;
@@ -695,11 +647,11 @@
     public static Symbol symbol(JCTree tree) {
         tree = skipParens(tree);
         switch (tree.getTag()) {
-        case IDENT:
+        case JCTree.IDENT:
             return ((JCIdent) tree).sym;
-        case SELECT:
+        case JCTree.SELECT:
             return ((JCFieldAccess) tree).sym;
-        case TYPEAPPLY:
+        case JCTree.TYPEAPPLY:
             return symbol(((JCTypeApply) tree).clazz);
         default:
             return null;
@@ -709,7 +661,7 @@
     /** Return true if this is a nonstatic selection. */
     public static boolean nonstaticSelect(JCTree tree) {
         tree = skipParens(tree);
-        if (!tree.hasTag(SELECT)) return false;
+        if (tree.getTag() != JCTree.SELECT) return false;
         JCFieldAccess s = (JCFieldAccess) tree;
         Symbol e = symbol(s.selected);
         return e == null || (e.kind != Kinds.PCK && e.kind != Kinds.TYP);
@@ -720,9 +672,9 @@
     public static void setSymbol(JCTree tree, Symbol sym) {
         tree = skipParens(tree);
         switch (tree.getTag()) {
-        case IDENT:
+        case JCTree.IDENT:
             ((JCIdent) tree).sym = sym; break;
-        case SELECT:
+        case JCTree.SELECT:
             ((JCFieldAccess) tree).sym = sym; break;
         default:
         }
@@ -733,13 +685,13 @@
      */
     public static long flags(JCTree tree) {
         switch (tree.getTag()) {
-        case VARDEF:
+        case JCTree.VARDEF:
             return ((JCVariableDecl) tree).mods.flags;
-        case METHODDEF:
+        case JCTree.METHODDEF:
             return ((JCMethodDecl) tree).mods.flags;
-        case CLASSDEF:
+        case JCTree.CLASSDEF:
             return ((JCClassDecl) tree).mods.flags;
-        case BLOCK:
+        case JCTree.BLOCK:
             return ((JCBlock) tree).flags;
         default:
             return 0;
@@ -787,155 +739,155 @@
 
     /** Map operators to their precedence levels.
      */
-    public static int opPrec(JCTree.Tag op) {
+    public static int opPrec(int op) {
         switch(op) {
-        case POS:
-        case NEG:
-        case NOT:
-        case COMPL:
-        case PREINC:
-        case PREDEC: return prefixPrec;
-        case POSTINC:
-        case POSTDEC:
-        case NULLCHK: return postfixPrec;
-        case ASSIGN: return assignPrec;
-        case BITOR_ASG:
-        case BITXOR_ASG:
-        case BITAND_ASG:
-        case SL_ASG:
-        case SR_ASG:
-        case USR_ASG:
-        case PLUS_ASG:
-        case MINUS_ASG:
-        case MUL_ASG:
-        case DIV_ASG:
-        case MOD_ASG: return assignopPrec;
-        case OR: return orPrec;
-        case AND: return andPrec;
-        case EQ:
-        case NE: return eqPrec;
-        case LT:
-        case GT:
-        case LE:
-        case GE: return ordPrec;
-        case BITOR: return bitorPrec;
-        case BITXOR: return bitxorPrec;
-        case BITAND: return bitandPrec;
-        case SL:
-        case SR:
-        case USR: return shiftPrec;
-        case PLUS:
-        case MINUS: return addPrec;
-        case MUL:
-        case DIV:
-        case MOD: return mulPrec;
-        case TYPETEST: return ordPrec;
+        case JCTree.POS:
+        case JCTree.NEG:
+        case JCTree.NOT:
+        case JCTree.COMPL:
+        case JCTree.PREINC:
+        case JCTree.PREDEC: return prefixPrec;
+        case JCTree.POSTINC:
+        case JCTree.POSTDEC:
+        case JCTree.NULLCHK: return postfixPrec;
+        case JCTree.ASSIGN: return assignPrec;
+        case JCTree.BITOR_ASG:
+        case JCTree.BITXOR_ASG:
+        case JCTree.BITAND_ASG:
+        case JCTree.SL_ASG:
+        case JCTree.SR_ASG:
+        case JCTree.USR_ASG:
+        case JCTree.PLUS_ASG:
+        case JCTree.MINUS_ASG:
+        case JCTree.MUL_ASG:
+        case JCTree.DIV_ASG:
+        case JCTree.MOD_ASG: return assignopPrec;
+        case JCTree.OR: return orPrec;
+        case JCTree.AND: return andPrec;
+        case JCTree.EQ:
+        case JCTree.NE: return eqPrec;
+        case JCTree.LT:
+        case JCTree.GT:
+        case JCTree.LE:
+        case JCTree.GE: return ordPrec;
+        case JCTree.BITOR: return bitorPrec;
+        case JCTree.BITXOR: return bitxorPrec;
+        case JCTree.BITAND: return bitandPrec;
+        case JCTree.SL:
+        case JCTree.SR:
+        case JCTree.USR: return shiftPrec;
+        case JCTree.PLUS:
+        case JCTree.MINUS: return addPrec;
+        case JCTree.MUL:
+        case JCTree.DIV:
+        case JCTree.MOD: return mulPrec;
+        case JCTree.TYPETEST: return ordPrec;
         default: throw new AssertionError();
         }
     }
 
-    static Tree.Kind tagToKind(JCTree.Tag tag) {
+    static Tree.Kind tagToKind(int tag) {
         switch (tag) {
         // Postfix expressions
-        case POSTINC:           // _ ++
+        case JCTree.POSTINC:           // _ ++
             return Tree.Kind.POSTFIX_INCREMENT;
-        case POSTDEC:           // _ --
+        case JCTree.POSTDEC:           // _ --
             return Tree.Kind.POSTFIX_DECREMENT;
 
         // Unary operators
-        case PREINC:            // ++ _
+        case JCTree.PREINC:            // ++ _
             return Tree.Kind.PREFIX_INCREMENT;
-        case PREDEC:            // -- _
+        case JCTree.PREDEC:            // -- _
             return Tree.Kind.PREFIX_DECREMENT;
-        case POS:               // +
+        case JCTree.POS:               // +
             return Tree.Kind.UNARY_PLUS;
-        case NEG:               // -
+        case JCTree.NEG:               // -
             return Tree.Kind.UNARY_MINUS;
-        case COMPL:             // ~
+        case JCTree.COMPL:             // ~
             return Tree.Kind.BITWISE_COMPLEMENT;
-        case NOT:               // !
+        case JCTree.NOT:               // !
             return Tree.Kind.LOGICAL_COMPLEMENT;
 
         // Binary operators
 
         // Multiplicative operators
-        case MUL:               // *
+        case JCTree.MUL:               // *
             return Tree.Kind.MULTIPLY;
-        case DIV:               // /
+        case JCTree.DIV:               // /
             return Tree.Kind.DIVIDE;
-        case MOD:               // %
+        case JCTree.MOD:               // %
             return Tree.Kind.REMAINDER;
 
         // Additive operators
-        case PLUS:              // +
+        case JCTree.PLUS:              // +
             return Tree.Kind.PLUS;
-        case MINUS:             // -
+        case JCTree.MINUS:             // -
             return Tree.Kind.MINUS;
 
         // Shift operators
-        case SL:                // <<
+        case JCTree.SL:                // <<
             return Tree.Kind.LEFT_SHIFT;
-        case SR:                // >>
+        case JCTree.SR:                // >>
             return Tree.Kind.RIGHT_SHIFT;
-        case USR:               // >>>
+        case JCTree.USR:               // >>>
             return Tree.Kind.UNSIGNED_RIGHT_SHIFT;
 
         // Relational operators
-        case LT:                // <
+        case JCTree.LT:                // <
             return Tree.Kind.LESS_THAN;
-        case GT:                // >
+        case JCTree.GT:                // >
             return Tree.Kind.GREATER_THAN;
-        case LE:                // <=
+        case JCTree.LE:                // <=
             return Tree.Kind.LESS_THAN_EQUAL;
-        case GE:                // >=
+        case JCTree.GE:                // >=
             return Tree.Kind.GREATER_THAN_EQUAL;
 
         // Equality operators
-        case EQ:                // ==
+        case JCTree.EQ:                // ==
             return Tree.Kind.EQUAL_TO;
-        case NE:                // !=
+        case JCTree.NE:                // !=
             return Tree.Kind.NOT_EQUAL_TO;
 
         // Bitwise and logical operators
-        case BITAND:            // &
+        case JCTree.BITAND:            // &
             return Tree.Kind.AND;
-        case BITXOR:            // ^
+        case JCTree.BITXOR:            // ^
             return Tree.Kind.XOR;
-        case BITOR:             // |
+        case JCTree.BITOR:             // |
             return Tree.Kind.OR;
 
         // Conditional operators
-        case AND:               // &&
+        case JCTree.AND:               // &&
             return Tree.Kind.CONDITIONAL_AND;
-        case OR:                // ||
+        case JCTree.OR:                // ||
             return Tree.Kind.CONDITIONAL_OR;
 
         // Assignment operators
-        case MUL_ASG:           // *=
+        case JCTree.MUL_ASG:           // *=
             return Tree.Kind.MULTIPLY_ASSIGNMENT;
-        case DIV_ASG:           // /=
+        case JCTree.DIV_ASG:           // /=
             return Tree.Kind.DIVIDE_ASSIGNMENT;
-        case MOD_ASG:           // %=
+        case JCTree.MOD_ASG:           // %=
             return Tree.Kind.REMAINDER_ASSIGNMENT;
-        case PLUS_ASG:          // +=
+        case JCTree.PLUS_ASG:          // +=
             return Tree.Kind.PLUS_ASSIGNMENT;
-        case MINUS_ASG:         // -=
+        case JCTree.MINUS_ASG:         // -=
             return Tree.Kind.MINUS_ASSIGNMENT;
-        case SL_ASG:            // <<=
+        case JCTree.SL_ASG:            // <<=
             return Tree.Kind.LEFT_SHIFT_ASSIGNMENT;
-        case SR_ASG:            // >>=
+        case JCTree.SR_ASG:            // >>=
             return Tree.Kind.RIGHT_SHIFT_ASSIGNMENT;
-        case USR_ASG:           // >>>=
+        case JCTree.USR_ASG:           // >>>=
             return Tree.Kind.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT;
-        case BITAND_ASG:        // &=
+        case JCTree.BITAND_ASG:        // &=
             return Tree.Kind.AND_ASSIGNMENT;
-        case BITXOR_ASG:        // ^=
+        case JCTree.BITXOR_ASG:        // ^=
             return Tree.Kind.XOR_ASSIGNMENT;
-        case BITOR_ASG:         // |=
+        case JCTree.BITOR_ASG:         // |=
             return Tree.Kind.OR_ASSIGNMENT;
 
         // Null check (implementation detail), for example, __.getClass()
-        case NULLCHK:
+        case JCTree.NULLCHK:
             return Tree.Kind.OTHER;
 
         default:
@@ -949,13 +901,13 @@
      */
     public static JCExpression typeIn(JCExpression tree) {
         switch (tree.getTag()) {
-        case IDENT: /* simple names */
-        case TYPEIDENT: /* primitive name */
-        case SELECT: /* qualified name */
-        case TYPEARRAY: /* array types */
-        case WILDCARD: /* wild cards */
-        case TYPEPARAMETER: /* type parameters */
-        case TYPEAPPLY: /* parameterized types */
+        case JCTree.IDENT: /* simple names */
+        case JCTree.TYPEIDENT: /* primitive name */
+        case JCTree.SELECT: /* qualified name */
+        case JCTree.TYPEARRAY: /* array types */
+        case JCTree.WILDCARD: /* wild cards */
+        case JCTree.TYPEPARAMETER: /* type parameters */
+        case JCTree.TYPEAPPLY: /* parameterized types */
             return tree;
         default:
             throw new AssertionError("Unexpected type tree: " + tree);
@@ -964,9 +916,9 @@
 
     public static JCTree innermostType(JCTree type) {
         switch (type.getTag()) {
-        case TYPEARRAY:
+        case JCTree.TYPEARRAY:
             return innermostType(((JCArrayTypeTree)type).elemtype);
-        case WILDCARD:
+        case JCTree.WILDCARD:
             return innermostType(((JCWildcard)type).inner);
         default:
             return type;
diff -u -r javac/tree/TreeMaker.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeMaker.java
--- javac/tree/TreeMaker.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeMaker.java	2011-06-27 15:21:47.000000000 -0500
@@ -351,14 +351,6 @@
         return tree;
     }
 
-    public JCLambda Lambda(List<JCVariableDecl> params,
-                           JCTree body)
-    {
-        JCLambda tree = new JCLambda(params, body);
-        tree.pos = pos;
-        return tree;
-    }
-
     public JCParens Parens(JCExpression expr) {
         JCParens tree = new JCParens(expr);
         tree.pos = pos;
@@ -371,19 +363,19 @@
         return tree;
     }
 
-    public JCAssignOp Assignop(JCTree.Tag opcode, JCTree lhs, JCTree rhs) {
+    public JCAssignOp Assignop(int opcode, JCTree lhs, JCTree rhs) {
         JCAssignOp tree = new JCAssignOp(opcode, lhs, rhs, null);
         tree.pos = pos;
         return tree;
     }
 
-    public JCUnary Unary(JCTree.Tag opcode, JCExpression arg) {
+    public JCUnary Unary(int opcode, JCExpression arg) {
         JCUnary tree = new JCUnary(opcode, arg);
         tree.pos = pos;
         return tree;
     }
 
-    public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs) {
+    public JCBinary Binary(int opcode, JCExpression lhs, JCExpression rhs) {
         JCBinary tree = new JCBinary(opcode, lhs, rhs, null);
         tree.pos = pos;
         return tree;
@@ -412,13 +404,6 @@
         tree.pos = pos;
         return tree;
     }
-
-    public JCMemberReference Reference(JCMemberReference.ReferenceMode mode, Name name,
-            JCExpression expr, List<JCExpression> typeargs) {
-        JCMemberReference tree = new JCMemberReference(mode, name, expr, typeargs);
-        tree.pos = pos;
-        return tree;
-    }
 
     public JCIdent Ident(Name name) {
         JCIdent tree = new JCIdent(name, null);
diff -u -r javac/tree/TreeScanner.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeScanner.java
--- javac/tree/TreeScanner.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeScanner.java	2011-06-27 15:21:47.000000000 -0500
@@ -212,11 +212,6 @@
         scan(tree.elems);
     }
 
-    public void visitLambda(JCLambda tree) {
-        scan(tree.body);
-        scan(tree.params);
-    }
-
     public void visitParens(JCParens tree) {
         scan(tree.expr);
     }
@@ -259,11 +254,6 @@
         scan(tree.selected);
     }
 
-    public void visitReference(JCMemberReference tree) {
-        scan(tree.expr);
-        scan(tree.typeargs);
-    }
-
     public void visitIdent(JCIdent tree) {
     }
 
diff -u -r javac/tree/TreeTranslator.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeTranslator.java
--- javac/tree/TreeTranslator.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/tree/TreeTranslator.java	2011-06-27 15:21:47.000000000 -0500
@@ -282,12 +282,6 @@
         result = tree;
     }
 
-    public void visitLambda(JCLambda tree) {
-        tree.params = translate(tree.params);
-        tree.body = translate(tree.body);
-        result = tree;
-    }
-
     public void visitNewArray(JCNewArray tree) {
         tree.elemtype = translate(tree.elemtype);
         tree.dims = translate(tree.dims);
@@ -346,11 +340,6 @@
         result = tree;
     }
 
-    public void visitReference(JCMemberReference tree) {
-        tree.expr = translate(tree.expr);
-        result = tree;
-    }
-
     public void visitIdent(JCIdent tree) {
         result = tree;
     }
diff -u -r javac/util/AbstractLog.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/AbstractLog.java
--- javac/util/AbstractLog.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/AbstractLog.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -95,19 +95,6 @@
     }
 
     /** Report an error, unless another error was already reported at same
-     *  source position.
-     *  @param flag   A flag to set on the diagnostic
-     *  @param pos    The source position at which to report the error.
-     *  @param key    The key for the localized error message.
-     *  @param args   Fields of the error message.
-     */
-    public void error(DiagnosticFlag flag, DiagnosticPosition pos, String key, Object ... args) {
-        JCDiagnostic d = diags.error(source, pos, key, args);
-        d.setFlag(flag);
-        report(d);
-    }
-
-    /** Report an error, unless another error was already reported at same
      *  source position.
      *  @param pos    The source position at which to report the error.
      *  @param key    The key for the localized error message.
diff -u -r javac/util/BaseFileManager.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/BaseFileManager.java
--- javac/util/BaseFileManager.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/BaseFileManager.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,11 @@
 
 package com.sun.tools.javac.util;
 
+import com.sun.tools.javac.code.Source;
+import com.sun.tools.javac.main.JavacOption;
+import com.sun.tools.javac.main.OptionName;
+import com.sun.tools.javac.main.RecognizedOptions;
+import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
@@ -46,19 +51,9 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.Set;
 import javax.tools.JavaFileObject;
 import javax.tools.JavaFileObject.Kind;
 
-import com.sun.tools.javac.code.Lint;
-import com.sun.tools.javac.code.Source;
-import com.sun.tools.javac.file.FSInfo;
-import com.sun.tools.javac.file.Locations;
-import com.sun.tools.javac.main.Option;
-import com.sun.tools.javac.main.OptionHelper;
-import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;
-import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;
-
 /**
  * Utility methods for building a filemanager.
  * There are no references here to file-system specific objects such as
@@ -68,21 +63,15 @@
     protected BaseFileManager(Charset charset) {
         this.charset = charset;
         byteBufferCache = new ByteBufferCache();
-        locations = createLocations();
     }
 
     /**
      * Set the context for JavacPathFileManager.
      */
-    public void setContext(Context context) {
+    protected void setContext(Context context) {
         log = Log.instance(context);
         options = Options.instance(context);
         classLoaderClass = options.get("procloader");
-        locations.update(log, options, Lint.instance(context), FSInfo.instance(context));
-    }
-
-    protected Locations createLocations() {
-        return new Locations();
     }
 
     /**
@@ -99,10 +88,8 @@
 
     protected String classLoaderClass;
 
-    protected Locations locations;
-
     protected Source getSource() {
-        String sourceName = options.get(Option.SOURCE);
+        String sourceName = options.get(OptionName.SOURCE);
         Source source = null;
         if (sourceName != null)
             source = Source.lookup(sourceName);
@@ -146,31 +133,15 @@
 
     // <editor-fold defaultstate="collapsed" desc="Option handling">
     public boolean handleOption(String current, Iterator<String> remaining) {
-        OptionHelper helper = new GrumpyHelper(log) {
-            @Override
-            public String get(Option option) {
-                return options.get(option.getText());
-            }
-
-            @Override
-            public void put(String name, String value) {
-                options.put(name, value);
-            }
-
-            @Override
-            public void remove(String name) {
-                options.remove(name);
-            }
-        };
-        for (Option o: javacFileManagerOptions) {
+        for (JavacOption o: javacFileManagerOptions) {
             if (o.matches(current))  {
                 if (o.hasArg()) {
                     if (remaining.hasNext()) {
-                        if (!o.process(helper, current, remaining.next()))
+                        if (!o.process(options, current, remaining.next()))
                             return true;
                     }
                 } else {
-                    if (!o.process(helper, current))
+                    if (!o.process(options, current))
                         return true;
                 }
                 // operand missing, or process returned false
@@ -181,11 +152,12 @@
         return false;
     }
     // where
-        private static Set<Option> javacFileManagerOptions =
-            Option.getJavacFileManagerOptions();
+        private static JavacOption[] javacFileManagerOptions =
+            RecognizedOptions.getJavacFileManagerOptions(
+            new RecognizedOptions.GrumpyHelper());
 
     public int isSupportedOption(String option) {
-        for (Option o : javacFileManagerOptions) {
+        for (JavacOption o : javacFileManagerOptions) {
             if (o.matches(option))
                 return o.hasArg() ? 1 : 0;
         }
@@ -207,7 +179,7 @@
     }
 
     public String getEncodingName() {
-        String encName = options.get(Option.ENCODING);
+        String encName = options.get(OptionName.ENCODING);
         if (encName == null)
             return getDefaultEncodingName();
         else
@@ -350,46 +322,16 @@
 
     // <editor-fold defaultstate="collapsed" desc="Content cache">
     public CharBuffer getCachedContent(JavaFileObject file) {
-        ContentCacheEntry e = contentCache.get(file);
-        if (e == null)
-            return null;
-
-        if (!e.isValid(file)) {
-            contentCache.remove(file);
-            return null;
-        }
-
-        return e.getValue();
+        SoftReference<CharBuffer> r = contentCache.get(file);
+        return (r == null ? null : r.get());
     }
 
     public void cache(JavaFileObject file, CharBuffer cb) {
-        contentCache.put(file, new ContentCacheEntry(file, cb));
-    }
-
-    public void flushCache(JavaFileObject file) {
-        contentCache.remove(file);
+        contentCache.put(file, new SoftReference<CharBuffer>(cb));
     }
 
-    protected final Map<JavaFileObject, ContentCacheEntry> contentCache
-            = new HashMap<JavaFileObject, ContentCacheEntry>();
-
-    protected static class ContentCacheEntry {
-        final long timestamp;
-        final SoftReference<CharBuffer> ref;
-
-        ContentCacheEntry(JavaFileObject file, CharBuffer cb) {
-            this.timestamp = file.getLastModified();
-            this.ref = new SoftReference<CharBuffer>(cb);
-        }
-
-        boolean isValid(JavaFileObject file) {
-            return timestamp == file.getLastModified();
-        }
-
-        CharBuffer getValue() {
-            return ref.get();
-        }
-    }
+    protected final Map<JavaFileObject, SoftReference<CharBuffer>> contentCache
+            = new HashMap<JavaFileObject, SoftReference<CharBuffer>>();
     // </editor-fold>
 
     public static Kind getKind(String name) {
diff -u -r javac/util/DiagnosticSource.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/DiagnosticSource.java
--- javac/util/DiagnosticSource.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/DiagnosticSource.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,7 +32,6 @@
 import javax.tools.JavaFileObject;
 
 import com.sun.tools.javac.file.JavacFileManager;
-import com.sun.tools.javac.parser.EndPosTable;
 import com.sun.tools.javac.tree.JCTree;
 
 import static com.sun.tools.javac.util.LayoutCharacters.*;
@@ -129,11 +128,11 @@
         }
     }
 
-    public EndPosTable getEndPosTable() {
+    public Map<JCTree, Integer> getEndPosTable() {
         return endPosTable;
     }
 
-    public void setEndPosTable(EndPosTable t) {
+    public void setEndPosTable(Map<JCTree, Integer> t) {
         if (endPosTable != null && endPosTable != t)
             throw new IllegalStateException("endPosTable already set");
         endPosTable = t;
@@ -200,7 +199,7 @@
     /** The underlying file object. */
     protected JavaFileObject fileObject;
 
-    protected EndPosTable endPosTable;
+    protected Map<JCTree, Integer> endPosTable;
 
     /** A soft reference to the content of the file object. */
     protected SoftReference<char[]> refBuf;
diff -u -r javac/util/JavacMessages.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/JavacMessages.java
--- javac/util/JavacMessages.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/JavacMessages.java	2011-06-27 15:21:47.000000000 -0500
@@ -82,14 +82,14 @@
     }
 
     /** Creates a JavacMessages object.
-     * @param bundleName the name to identify the resource bundle of localized messages.
+     * @param bundleName the name to identify the resource buundle of localized messages.
      */
     public JavacMessages(String bundleName) throws MissingResourceException {
         this(bundleName, null);
     }
 
     /** Creates a JavacMessages object.
-     * @param bundleName the name to identify the resource bundle of localized messages.
+     * @param bundleName the name to identify the resource buundle of localized messages.
      */
     public JavacMessages(String bundleName, Locale locale) throws MissingResourceException {
         bundleNames = List.nil();
diff -u -r javac/util/JCDiagnostic.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/JCDiagnostic.java
--- javac/util/JCDiagnostic.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/JCDiagnostic.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,7 +35,6 @@
 
 import com.sun.tools.javac.api.DiagnosticFormatter;
 import com.sun.tools.javac.code.Lint.LintCategory;
-import com.sun.tools.javac.parser.EndPosTable;
 import com.sun.tools.javac.tree.JCTree;
 
 import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticType.*;
@@ -71,16 +70,7 @@
             this(JavacMessages.instance(context), "compiler");
             context.put(diagnosticFactoryKey, this);
 
-            final Options options = Options.instance(context);
-            initOptions(options);
-            options.addListener(new Runnable() {
-               public void run() {
-                   initOptions(options);
-               }
-            });
-        }
-
-        private void initOptions(Options options) {
+            Options options = Options.instance(context);
             if (options.isSet("onlySyntaxErrorsUnrecoverable"))
                 defaultErrorFlags.add(DiagnosticFlag.RECOVERABLE);
         }
@@ -314,7 +304,7 @@
         /** If there is a tree node, and if endPositions are available, get
          *  the end position of the tree node. Otherwise, just returns the
          *  same as getPreferredPosition(). */
-        int getEndPosition(EndPosTable endPosTable);
+        int getEndPosition(Map<JCTree, Integer> endPosTable);
     }
 
     /**
@@ -338,7 +328,7 @@
             return pos;
         }
 
-        public int getEndPosition(EndPosTable endPosTable) {
+        public int getEndPosition(Map<JCTree, Integer> endPosTable) {
             return pos;
         }
 
diff -u -r javac/util/Log.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/Log.java
--- javac/util/Log.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/Log.java	2011-06-27 15:21:47.000000000 -0500
@@ -29,19 +29,19 @@
 import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
 import javax.tools.DiagnosticListener;
 import javax.tools.JavaFileObject;
 
 import com.sun.tools.javac.api.DiagnosticFormatter;
-import com.sun.tools.javac.main.Main;
-import com.sun.tools.javac.main.Option;
-import com.sun.tools.javac.parser.EndPosTable;
+import com.sun.tools.javac.main.OptionName;
+import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
 
-import static com.sun.tools.javac.main.Option.*;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /** A class for error logs. Reports errors and warnings, and
  *  keeps track of error numbers and positions.
@@ -60,31 +60,19 @@
     public static final Context.Key<PrintWriter> outKey =
         new Context.Key<PrintWriter>();
 
-    /* TODO: Should unify this with prefix handling in JCDiagnostic.Factory. */
-    public enum PrefixKind {
-        JAVAC("javac."),
-        COMPILER_MISC("compiler.misc.");
-        PrefixKind(String v) {
-            value = v;
-        }
-        public String key(String k) {
-            return value + k;
-        }
-        final String value;
-    }
-
-    public enum WriterKind { NOTICE, WARNING, ERROR };
+    //@Deprecated
+    public final PrintWriter errWriter;
 
-    protected PrintWriter errWriter;
+    //@Deprecated
+    public final PrintWriter warnWriter;
 
-    protected PrintWriter warnWriter;
-
-    protected PrintWriter noticeWriter;
+    //@Deprecated
+    public final PrintWriter noticeWriter;
 
     /** The maximum number of errors/warnings that are reported.
      */
-    protected int MaxErrors;
-    protected int MaxWarnings;
+    public final int MaxErrors;
+    public final int MaxWarnings;
 
     /** Switch: prompt user on each error.
      */
@@ -135,6 +123,7 @@
 
     /** Construct a log with given I/O redirections.
      */
+    @Deprecated
     protected Log(Context context, PrintWriter errWriter, PrintWriter warnWriter, PrintWriter noticeWriter) {
         super(JCDiagnostic.Factory.instance(context));
         context.put(logKey, this);
@@ -142,42 +131,30 @@
         this.warnWriter = warnWriter;
         this.noticeWriter = noticeWriter;
 
+        Options options = Options.instance(context);
+        this.dumpOnError = options.isSet(DOE);
+        this.promptOnError = options.isSet(PROMPT);
+        this.emitWarnings = options.isUnset(XLINT_CUSTOM, "none");
+        this.suppressNotes = options.isSet("suppressNotes");
+        this.MaxErrors = getIntOption(options, XMAXERRS, getDefaultMaxErrors());
+        this.MaxWarnings = getIntOption(options, XMAXWARNS, getDefaultMaxWarnings());
+
+        boolean rawDiagnostics = options.isSet("rawDiagnostics");
+        messages = JavacMessages.instance(context);
+        this.diagFormatter = rawDiagnostics ? new RawDiagnosticFormatter(options) :
+                                              new BasicDiagnosticFormatter(options, messages);
         @SuppressWarnings("unchecked") // FIXME
         DiagnosticListener<? super JavaFileObject> dl =
             context.get(DiagnosticListener.class);
         this.diagListener = dl;
 
-        messages = JavacMessages.instance(context);
-        messages.add(Main.javacBundleName);
-
-        final Options options = Options.instance(context);
-        initOptions(options);
-        options.addListener(new Runnable() {
-            public void run() {
-                initOptions(options);
-            }
-        });
+        String ek = options.get("expectKeys");
+        if (ek != null)
+            expectDiagKeys = new HashSet<String>(Arrays.asList(ek.split(", *")));
     }
     // where
-        private void initOptions(Options options) {
-            this.dumpOnError = options.isSet(DOE);
-            this.promptOnError = options.isSet(PROMPT);
-            this.emitWarnings = options.isUnset(XLINT_CUSTOM, "none");
-            this.suppressNotes = options.isSet("suppressNotes");
-            this.MaxErrors = getIntOption(options, XMAXERRS, getDefaultMaxErrors());
-            this.MaxWarnings = getIntOption(options, XMAXWARNS, getDefaultMaxWarnings());
-
-            boolean rawDiagnostics = options.isSet("rawDiagnostics");
-            this.diagFormatter = rawDiagnostics ? new RawDiagnosticFormatter(options) :
-                                                  new BasicDiagnosticFormatter(options, messages);
-
-            String ek = options.get("expectKeys");
-            if (ek != null)
-                expectDiagKeys = new HashSet<String>(Arrays.asList(ek.split(", *")));
-        }
-
-        private int getIntOption(Options options, Option option, int defaultValue) {
-            String s = options.get(option);
+        private int getIntOption(Options options, OptionName optionName, int defaultValue) {
+            String s = options.get(optionName);
             try {
                 if (s != null) {
                     int n = Integer.parseInt(s);
@@ -203,7 +180,7 @@
 
     /** The default writer for diagnostics
      */
-    static PrintWriter defaultWriter(Context context) {
+    static final PrintWriter defaultWriter(Context context) {
         PrintWriter result = context.get(outKey);
         if (result == null)
             context.put(outKey, result = new PrintWriter(System.err));
@@ -248,9 +225,9 @@
         return diagListener != null;
     }
 
-    public void setEndPosTable(JavaFileObject name, EndPosTable endPosTable) {
+    public void setEndPosTable(JavaFileObject name, Map<JCTree, Integer> table) {
         name.getClass(); // null check
-        getSource(name).setEndPosTable(endPosTable);
+        getSource(name).setEndPosTable(table);
     }
 
     /** Return current sourcefile.
@@ -271,36 +248,6 @@
         this.diagFormatter = diagFormatter;
     }
 
-    public PrintWriter getWriter(WriterKind kind) {
-        switch (kind) {
-            case NOTICE:    return noticeWriter;
-            case WARNING:   return warnWriter;
-            case ERROR:     return errWriter;
-            default:        throw new IllegalArgumentException();
-        }
-    }
-
-    public void setWriter(WriterKind kind, PrintWriter pw) {
-        pw.getClass();
-        switch (kind) {
-            case NOTICE:    noticeWriter = pw;  break;
-            case WARNING:   warnWriter = pw;    break;
-            case ERROR:     errWriter = pw;     break;
-            default:        throw new IllegalArgumentException();
-        }
-    }
-
-    public void setWriters(PrintWriter pw) {
-        pw.getClass();
-        noticeWriter = warnWriter = errWriter = pw;
-    }
-
-    public void setWriters(Log other) {
-        this.noticeWriter = other.noticeWriter;
-        this.warnWriter = other.warnWriter;
-        this.errWriter = other.errWriter;
-    }
-
     /** Flush the logs
      */
     public void flush() {
@@ -309,10 +256,6 @@
         noticeWriter.flush();
     }
 
-    public void flush(WriterKind kind) {
-        getWriter(kind).flush();
-    }
-
     /** Returns true if an error needs to be reported for a given
      * source name and pos.
      */
@@ -332,6 +275,7 @@
     public void prompt() {
         if (promptOnError) {
             System.err.println(localize("resume.abort"));
+            char ch;
             try {
                 while (true) {
                     switch (System.in.read()) {
@@ -358,7 +302,7 @@
             return;
         int col = source.getColumnNumber(pos, false);
 
-        printRawLines(writer, line);
+        printLines(writer, line);
         for (int i = 0; i < col - 1; i++) {
             writer.print((line.charAt(i) == '\t') ? "\t" : " ");
         }
@@ -366,48 +310,10 @@
         writer.flush();
     }
 
-    public void printNewline() {
-        noticeWriter.println();
-    }
-
-    public void printNewline(WriterKind wk) {
-        getWriter(wk).println();
-    }
-
-    public void printLines(String key, Object... args) {
-        printRawLines(noticeWriter, localize(key, args));
-    }
-
-    public void printLines(PrefixKind pk, String key, Object... args) {
-        printRawLines(noticeWriter, localize(pk, key, args));
-    }
-
-    public void printLines(WriterKind wk, String key, Object... args) {
-        printRawLines(getWriter(wk), localize(key, args));
-    }
-
-    public void printLines(WriterKind wk, PrefixKind pk, String key, Object... args) {
-        printRawLines(getWriter(wk), localize(pk, key, args));
-    }
-
-    /** Print the text of a message, translating newlines appropriately
-     *  for the platform.
-     */
-    public void printRawLines(String msg) {
-        printRawLines(noticeWriter, msg);
-    }
-
-    /** Print the text of a message, translating newlines appropriately
-     *  for the platform.
-     */
-    public void printRawLines(WriterKind kind, String msg) {
-        printRawLines(getWriter(kind), msg);
-    }
-
     /** Print the text of a message, translating newlines appropriately
      *  for the platform.
      */
-    public static void printRawLines(PrintWriter writer, String msg) {
+    public static void printLines(PrintWriter writer, String msg) {
         int nl;
         while ((nl = msg.indexOf('\n')) != -1) {
             writer.println(msg.substring(0, nl));
@@ -416,16 +322,30 @@
         if (msg.length() != 0) writer.println(msg);
     }
 
+    /** Print the text of a message to the errWriter stream,
+     *  translating newlines appropriately for the platform.
+     */
+    public void printErrLines(String key, Object... args) {
+        printLines(errWriter, localize(key, args));
+    }
+
+    /** Print the text of a message to the noticeWriter stream,
+     *  translating newlines appropriately for the platform.
+     */
+    public void printNoteLines(String key, Object... args) {
+        printLines(noticeWriter, localize(key, args));
+    }
+
     /**
      * Print the localized text of a "verbose" message to the
      * noticeWriter stream.
      */
     public void printVerbose(String key, Object... args) {
-        printRawLines(noticeWriter, localize("verbose." + key, args));
+        printLines(noticeWriter, localize("verbose." + key, args));
     }
 
     protected void directError(String key, Object... args) {
-        printRawLines(errWriter, localize(key, args));
+        printErrLines(key, args);
         errWriter.flush();
     }
 
@@ -511,7 +431,7 @@
 
         PrintWriter writer = getWriterForDiagnosticType(diag.getType());
 
-        printRawLines(writer, diagFormatter.format(diag, messages.getCurrentLocale()));
+        printLines(writer, diagFormatter.format(diag, messages.getCurrentLocale()));
 
         if (promptOnError) {
             switch (diag.getType()) {
@@ -554,7 +474,7 @@
      *  @param args   Fields to substitute into the string.
      */
     public static String getLocalizedString(String key, Object ... args) {
-        return JavacMessages.getDefaultLocalizedString(PrefixKind.COMPILER_MISC.key(key), args);
+        return JavacMessages.getDefaultLocalizedString("compiler.misc." + key, args);
     }
 
     /** Find a localized string in the resource bundle.
@@ -562,23 +482,9 @@
      *  @param args   Fields to substitute into the string.
      */
     public String localize(String key, Object... args) {
-        return localize(PrefixKind.COMPILER_MISC, key, args);
+        return messages.getLocalizedString("compiler.misc." + key, args);
     }
 
-    /** Find a localized string in the resource bundle.
-     *  @param key    The key for the localized string.
-     *  @param args   Fields to substitute into the string.
-     */
-    public String localize(PrefixKind pk, String key, Object... args) {
-        if (useRawMessages)
-            return pk.key(key);
-        else
-            return messages.getLocalizedString(pk.key(key), args);
-    }
-    // where
-        // backdoor hook for testing, should transition to use -XDrawDiagnostics
-        private static boolean useRawMessages = false;
-
 /***************************************************************************
  * raw error messages without internationalization; used for experimentation
  * and quick prototyping
@@ -588,12 +494,12 @@
      */
     private void printRawError(int pos, String msg) {
         if (source == null || pos == Position.NOPOS) {
-            printRawLines(errWriter, "error: " + msg);
+            printLines(errWriter, "error: " + msg);
         } else {
             int line = source.getLineNumber(pos);
             JavaFileObject file = source.getFile();
             if (file != null)
-                printRawLines(errWriter,
+                printLines(errWriter,
                            file.getName() + ":" +
                            line + ": " + msg);
             printErrLine(pos, errWriter);
diff -u -r javac/util/Names.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/Names.java
--- javac/util/Names.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/Names.java	2011-06-27 15:21:47.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -47,127 +47,108 @@
         return instance;
     }
 
-    // operators and punctuation
-    public final Name asterisk;
-    public final Name comma;
-    public final Name empty;
+    public final Name slash;
     public final Name hyphen;
+    public final Name T;
+    public final Name slashequals;
+    public final Name deprecated;
+    public final Name init;
+    public final Name clinit;
+    public final Name error;
+    public final Name any;
+    public final Name empty;
     public final Name one;
     public final Name period;
+    public final Name comma;
     public final Name semicolon;
-    public final Name slash;
-    public final Name slashequals;
-
-    // keywords
-    public final Name _class;
-    public final Name _default;
-    public final Name _super;
+    public final Name asterisk;
     public final Name _this;
-
-    // field and method names
-    public final Name _name;
-    public final Name addSuppressed;
-    public final Name any;
-    public final Name append;
-    public final Name clinit;
-    public final Name clone;
-    public final Name close;
-    public final Name compareTo;
-    public final Name desiredAssertionStatus;
-    public final Name equals;
-    public final Name error;
-    public final Name family;
-    public final Name finalize;
-    public final Name forName;
-    public final Name getClass;
-    public final Name getClassLoader;
-    public final Name getComponentType;
-    public final Name getDeclaringClass;
-    public final Name getMessage;
-    public final Name hasNext;
-    public final Name hashCode;
-    public final Name init;
-    public final Name initCause;
-    public final Name iterator;
-    public final Name length;
-    public final Name next;
-    public final Name ordinal;
-    public final Name serialVersionUID;
-    public final Name toString;
-    public final Name value;
-    public final Name valueOf;
-    public final Name values;
-
-    // class names
-    public final Name java_io_Serializable;
-    public final Name java_lang_AutoCloseable;
+    public final Name _super;
+    public final Name _default;
+    public final Name _class;
+    public final Name java_lang;
+    public final Name java_lang_Object;
     public final Name java_lang_Class;
     public final Name java_lang_Cloneable;
+    public final Name java_io_Serializable;
+    public final Name serialVersionUID;
     public final Name java_lang_Enum;
-    public final Name java_lang_Object;
     public final Name java_lang_invoke_MethodHandle;
-
-    // names of builtin classes
-    public final Name Array;
-    public final Name Bound;
-    public final Name Method;
-
-    // package names
-    public final Name java_lang;
-
-    // attribute names
-    public final Name Annotation;
-    public final Name AnnotationDefault;
-    public final Name Bridge;
-    public final Name CharacterRangeTable;
-    public final Name Code;
-    public final Name CompilationID;
+    public final Name package_info;
     public final Name ConstantValue;
-    public final Name Deprecated;
-    public final Name EnclosingMethod;
-    public final Name Enum;
-    public final Name Exceptions;
-    public final Name InnerClasses;
     public final Name LineNumberTable;
     public final Name LocalVariableTable;
     public final Name LocalVariableTypeTable;
-    public final Name RuntimeInvisibleAnnotations;
-    public final Name RuntimeInvisibleParameterAnnotations;
-    public final Name RuntimeInvisibleTypeAnnotations;
-    public final Name RuntimeVisibleAnnotations;
-    public final Name RuntimeVisibleParameterAnnotations;
-    public final Name RuntimeVisibleTypeAnnotations;
-    public final Name Signature;
-    public final Name SourceFile;
-    public final Name SourceID;
+    public final Name CharacterRangeTable;
     public final Name StackMap;
     public final Name StackMapTable;
+    public final Name SourceID;
+    public final Name CompilationID;
+    public final Name Code;
+    public final Name Exceptions;
+    public final Name SourceFile;
+    public final Name InnerClasses;
     public final Name Synthetic;
-    public final Name Value;
+    public final Name Bridge;
+    public final Name Deprecated;
+    public final Name Enum;
+    public final Name _name;
+    public final Name Signature;
     public final Name Varargs;
-
-    // members of java.lang.annotation.ElementType
-    public final Name ANNOTATION_TYPE;
-    public final Name CONSTRUCTOR;
+    public final Name Annotation;
+    public final Name RuntimeVisibleAnnotations;
+    public final Name RuntimeInvisibleAnnotations;
+    public final Name RuntimeVisibleTypeAnnotations;
+    public final Name RuntimeInvisibleTypeAnnotations;
+    public final Name RuntimeVisibleParameterAnnotations;
+    public final Name RuntimeInvisibleParameterAnnotations;
+    public final Name Value;
+    public final Name EnclosingMethod;
+    public final Name desiredAssertionStatus;
+    public final Name append;
+    public final Name family;
+    public final Name forName;
+    public final Name toString;
+    public final Name length;
+    public final Name valueOf;
+    public final Name value;
+    public final Name getMessage;
+    public final Name getClass;
+    public final Name TYPE;
+    public final Name TYPE_USE;
+    public final Name TYPE_PARAMETER;
     public final Name FIELD;
-    public final Name LOCAL_VARIABLE;
     public final Name METHOD;
-    public final Name PACKAGE;
     public final Name PARAMETER;
-    public final Name TYPE;
-    public final Name TYPE_PARAMETER;
-    public final Name TYPE_USE;
-
-    // members of java.lang.annotation.RetentionPolicy
+    public final Name CONSTRUCTOR;
+    public final Name LOCAL_VARIABLE;
+    public final Name ANNOTATION_TYPE;
+    public final Name PACKAGE;
+    public final Name SOURCE;
     public final Name CLASS;
     public final Name RUNTIME;
-    public final Name SOURCE;
-
-    // other identifiers
-    public final Name T;
-    public final Name deprecated;
+    public final Name Array;
+    public final Name Method;
+    public final Name Bound;
+    public final Name clone;
+    public final Name getComponentType;
+    public final Name getClassLoader;
+    public final Name initCause;
+    public final Name values;
+    public final Name iterator;
+    public final Name hasNext;
+    public final Name next;
+    public final Name AnnotationDefault;
+    public final Name ordinal;
+    public final Name equals;
+    public final Name hashCode;
+    public final Name compareTo;
+    public final Name getDeclaringClass;
     public final Name ex;
-    public final Name package_info;
+    public final Name finalize;
+    public final Name java_lang_AutoCloseable;
+    public final Name close;
+    public final Name addSuppressed;
 
     public final Name.Table table;
 
@@ -175,127 +156,116 @@
         Options options = Options.instance(context);
         table = createTable(options);
 
-        // operators and punctuation
-        asterisk = fromString("*");
-        comma = fromString(",");
-        empty = fromString("");
-        hyphen = fromString("-");
-        one = fromString("1");
-        period = fromString(".");
-        semicolon = fromString(";");
         slash = fromString("/");
+        hyphen = fromString("-");
+        T = fromString("T");
         slashequals = fromString("/=");
+        deprecated = fromString("deprecated");
 
-        // keywords
-        _class = fromString("class");
-        _default = fromString("default");
-        _super = fromString("super");
-        _this = fromString("this");
-
-        // field and method names
-        _name = fromString("name");
-        addSuppressed = fromString("addSuppressed");
-        any = fromString("<any>");
-        append = fromString("append");
+        init = fromString("<init>");
         clinit = fromString("<clinit>");
-        clone = fromString("clone");
-        close = fromString("close");
-        compareTo = fromString("compareTo");
-        desiredAssertionStatus = fromString("desiredAssertionStatus");
-        equals = fromString("equals");
         error = fromString("<error>");
-        family = fromString("family");
-        finalize = fromString("finalize");
-        forName = fromString("forName");
-        getClass = fromString("getClass");
-        getClassLoader = fromString("getClassLoader");
-        getComponentType = fromString("getComponentType");
-        getDeclaringClass = fromString("getDeclaringClass");
-        getMessage = fromString("getMessage");
-        hasNext = fromString("hasNext");
-        hashCode = fromString("hashCode");
-        init = fromString("<init>");
-        initCause = fromString("initCause");
-        iterator = fromString("iterator");
-        length = fromString("length");
-        next = fromString("next");
-        ordinal = fromString("ordinal");
-        serialVersionUID = fromString("serialVersionUID");
-        toString = fromString("toString");
-        value = fromString("value");
-        valueOf = fromString("valueOf");
-        values = fromString("values");
+        any = fromString("<any>");
+        empty = fromString("");
+        one = fromString("1");
+        period = fromString(".");
+        comma = fromString(",");
+        semicolon = fromString(";");
+        asterisk = fromString("*");
+        _this = fromString("this");
+        _super = fromString("super");
+        _default = fromString("default");
 
-        // class names
-        java_io_Serializable = fromString("java.io.Serializable");
-        java_lang_AutoCloseable = fromString("java.lang.AutoCloseable");
+        _class = fromString("class");
+        java_lang = fromString("java.lang");
+        java_lang_Object = fromString("java.lang.Object");
         java_lang_Class = fromString("java.lang.Class");
         java_lang_Cloneable = fromString("java.lang.Cloneable");
+        java_io_Serializable = fromString("java.io.Serializable");
         java_lang_Enum = fromString("java.lang.Enum");
-        java_lang_Object = fromString("java.lang.Object");
         java_lang_invoke_MethodHandle = fromString("java.lang.invoke.MethodHandle");
-
-        // names of builtin classes
-        Array = fromString("Array");
-        Bound = fromString("Bound");
-        Method = fromString("Method");
-
-        // package names
-        java_lang = fromString("java.lang");
-
-        // attribute names
-        Annotation = fromString("Annotation");
-        AnnotationDefault = fromString("AnnotationDefault");
-        Bridge = fromString("Bridge");
-        CharacterRangeTable = fromString("CharacterRangeTable");
-        Code = fromString("Code");
-        CompilationID = fromString("CompilationID");
+        package_info = fromString("package-info");
+        serialVersionUID = fromString("serialVersionUID");
         ConstantValue = fromString("ConstantValue");
-        Deprecated = fromString("Deprecated");
-        EnclosingMethod = fromString("EnclosingMethod");
-        Enum = fromString("Enum");
-        Exceptions = fromString("Exceptions");
-        InnerClasses = fromString("InnerClasses");
         LineNumberTable = fromString("LineNumberTable");
         LocalVariableTable = fromString("LocalVariableTable");
         LocalVariableTypeTable = fromString("LocalVariableTypeTable");
-        RuntimeInvisibleAnnotations = fromString("RuntimeInvisibleAnnotations");
-        RuntimeInvisibleParameterAnnotations = fromString("RuntimeInvisibleParameterAnnotations");
-        RuntimeInvisibleTypeAnnotations = fromString("RuntimeInvisibleTypeAnnotations");
-        RuntimeVisibleAnnotations = fromString("RuntimeVisibleAnnotations");
-        RuntimeVisibleParameterAnnotations = fromString("RuntimeVisibleParameterAnnotations");
-        RuntimeVisibleTypeAnnotations = fromString("RuntimeVisibleTypeAnnotations");
-        Signature = fromString("Signature");
-        SourceFile = fromString("SourceFile");
-        SourceID = fromString("SourceID");
+        CharacterRangeTable = fromString("CharacterRangeTable");
         StackMap = fromString("StackMap");
         StackMapTable = fromString("StackMapTable");
+        SourceID = fromString("SourceID");
+        CompilationID = fromString("CompilationID");
+        Code = fromString("Code");
+        Exceptions = fromString("Exceptions");
+        SourceFile = fromString("SourceFile");
+        InnerClasses = fromString("InnerClasses");
         Synthetic = fromString("Synthetic");
-        Value = fromString("Value");
+        Bridge = fromString("Bridge");
+        Deprecated = fromString("Deprecated");
+        Enum = fromString("Enum");
+        _name = fromString("name");
+        Signature = fromString("Signature");
         Varargs = fromString("Varargs");
+        Annotation = fromString("Annotation");
+        RuntimeVisibleAnnotations = fromString("RuntimeVisibleAnnotations");
+        RuntimeInvisibleAnnotations = fromString("RuntimeInvisibleAnnotations");
+        RuntimeVisibleTypeAnnotations = fromString("RuntimeVisibleTypeAnnotations");
+        RuntimeInvisibleTypeAnnotations = fromString("RuntimeInvisibleTypeAnnotations");
+        RuntimeVisibleParameterAnnotations = fromString("RuntimeVisibleParameterAnnotations");
+        RuntimeInvisibleParameterAnnotations = fromString("RuntimeInvisibleParameterAnnotations");
+        Value = fromString("Value");
+        EnclosingMethod = fromString("EnclosingMethod");
 
-        // members of java.lang.annotation.ElementType
-        ANNOTATION_TYPE = fromString("ANNOTATION_TYPE");
-        CONSTRUCTOR = fromString("CONSTRUCTOR");
+        desiredAssertionStatus = fromString("desiredAssertionStatus");
+
+        append = fromString("append");
+        family = fromString("family");
+        forName = fromString("forName");
+        toString = fromString("toString");
+        length = fromString("length");
+        valueOf = fromString("valueOf");
+        value = fromString("value");
+        getMessage = fromString("getMessage");
+        getClass = fromString("getClass");
+
+        TYPE = fromString("TYPE");
+        TYPE_USE = fromString("TYPE_USE");
+        TYPE_PARAMETER = fromString("TYPE_PARAMETER");
         FIELD = fromString("FIELD");
-        LOCAL_VARIABLE = fromString("LOCAL_VARIABLE");
         METHOD = fromString("METHOD");
-        PACKAGE = fromString("PACKAGE");
         PARAMETER = fromString("PARAMETER");
-        TYPE = fromString("TYPE");
-        TYPE_PARAMETER = fromString("TYPE_PARAMETER");
-        TYPE_USE = fromString("TYPE_USE");
+        CONSTRUCTOR = fromString("CONSTRUCTOR");
+        LOCAL_VARIABLE = fromString("LOCAL_VARIABLE");
+        ANNOTATION_TYPE = fromString("ANNOTATION_TYPE");
+        PACKAGE = fromString("PACKAGE");
 
-        // members of java.lang.annotation.RetentionPolicy
+        SOURCE = fromString("SOURCE");
         CLASS = fromString("CLASS");
         RUNTIME = fromString("RUNTIME");
-        SOURCE = fromString("SOURCE");
 
-        // other identifiers
-        T = fromString("T");
-        deprecated = fromString("deprecated");
+        Array = fromString("Array");
+        Method = fromString("Method");
+        Bound = fromString("Bound");
+        clone = fromString("clone");
+        getComponentType = fromString("getComponentType");
+        getClassLoader = fromString("getClassLoader");
+        initCause = fromString("initCause");
+        values = fromString("values");
+        iterator = fromString("iterator");
+        hasNext = fromString("hasNext");
+        next = fromString("next");
+        AnnotationDefault = fromString("AnnotationDefault");
+        ordinal = fromString("ordinal");
+        equals = fromString("equals");
+        hashCode = fromString("hashCode");
+        compareTo = fromString("compareTo");
+        getDeclaringClass = fromString("getDeclaringClass");
         ex = fromString("ex");
-        package_info = fromString("package-info");
+        finalize = fromString("finalize");
+
+        java_lang_AutoCloseable = fromString("java.lang.AutoCloseable");
+        close = fromString("close");
+        addSuppressed = fromString("addSuppressed");
     }
 
     protected Name.Table createTable(Options options) {
diff -u -r javac/util/Options.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/Options.java
--- javac/util/Options.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/Options.java	2011-06-27 15:21:47.000000000 -0500
@@ -26,8 +26,8 @@
 package com.sun.tools.javac.util;
 
 import java.util.*;
-import com.sun.tools.javac.main.Option;
-import static com.sun.tools.javac.main.Option.*;
+import com.sun.tools.javac.main.OptionName;
+import static com.sun.tools.javac.main.OptionName.*;
 
 /** A table of all command-line options.
  *  If an option has an argument, the option name is mapped to the argument.
@@ -71,8 +71,8 @@
     /**
      * Get the value for an option.
      */
-    public String get(Option option) {
-        return values.get(option.text);
+    public String get(OptionName name) {
+        return values.get(name.optionName);
     }
 
     /**
@@ -101,15 +101,15 @@
     /**
      * Check if the value for an option has been set.
      */
-    public boolean isSet(Option option) {
-        return (values.get(option.text) != null);
+    public boolean isSet(OptionName name) {
+        return (values.get(name.optionName) != null);
     }
 
     /**
      * Check if the value for a choice option has been set to a specific value.
      */
-    public boolean isSet(Option option, String value) {
-        return (values.get(option.text + value) != null);
+    public boolean isSet(OptionName name, String value) {
+        return (values.get(name.optionName + value) != null);
     }
 
     /**
@@ -122,23 +122,23 @@
     /**
      * Check if the value for an option has not been set.
      */
-    public boolean isUnset(Option option) {
-        return (values.get(option.text) == null);
+    public boolean isUnset(OptionName name) {
+        return (values.get(name.optionName) == null);
     }
 
     /**
      * Check if the value for a choice option has not been set to a specific value.
      */
-    public boolean isUnset(Option option, String value) {
-        return (values.get(option.text + value) == null);
+    public boolean isUnset(OptionName name, String value) {
+        return (values.get(name.optionName + value) == null);
     }
 
     public void put(String name, String value) {
         values.put(name, value);
     }
 
-    public void put(Option option, String value) {
-        values.put(option.text, value);
+    public void put(OptionName name, String value) {
+        values.put(name.optionName, value);
     }
 
     public void putAll(Options options) {
@@ -157,19 +157,6 @@
         return values.size();
     }
 
-    // light-weight notification mechanism
-
-    private List<Runnable> listeners = List.nil();
-
-    public void addListener(Runnable listener) {
-        listeners = listeners.prepend(listener);
-    }
-
-    public void notifyListeners() {
-        for (Runnable r: listeners)
-            r.run();
-    }
-
     /** Check for a lint suboption. */
     public boolean lint(String s) {
         // return true if either the specific option is enabled, or
diff -u -r javac/util/RichDiagnosticFormatter.java /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/RichDiagnosticFormatter.java
--- javac/util/RichDiagnosticFormatter.java	2012-05-17 08:20:51.000000000 -0500
+++ /tmp/diff_stuff/jdk7/src/share/classes/com/sun/tools/javac/util/RichDiagnosticFormatter.java	2011-06-27 15:21:47.000000000 -0500
@@ -412,7 +412,7 @@
         @Override
         public String visitMethodSymbol(MethodSymbol s, Locale locale) {
             String ownerName = visit(s.owner, locale);
-            if (s.isStaticOrInstanceInit()) {
+            if ((s.flags() & BLOCK) != 0) {
                return ownerName;
             } else {
                 String ms = (s.name == s.name.table.names.init)
@@ -540,22 +540,13 @@
                                          bounds.head.tag == NONE ||
                                          bounds.head.tag == ERROR;
 
-                if ((t.tsym.flags() & SYNTHETIC) == 0) {
-                    //this is a true typevar
-                    JCDiagnostic d = diags.fragment("where.typevar" +
+
+                JCDiagnostic d = diags.fragment("where.typevar" +
                         (boundErroneous ? ".1" : ""), t, bounds,
                         Kinds.kindName(t.tsym.location()), t.tsym.location());
-                    whereClauses.get(WhereClauseKind.TYPEVAR).put(t, d);
-                    symbolPreprocessor.visit(t.tsym.location(), null);
-                    visit(bounds);
-                } else {
-                    Assert.check(!boundErroneous);
-                    //this is a fresh (synthetic) tvar
-                    JCDiagnostic d = diags.fragment("where.fresh.typevar", t, bounds);
-                    whereClauses.get(WhereClauseKind.TYPEVAR).put(t, d);
-                    visit(bounds);
-                }
-
+                whereClauses.get(WhereClauseKind.TYPEVAR).put(t, d);
+                symbolPreprocessor.visit(t.tsym.location(), null);
+                visit(bounds);
             }
             return null;
         }
